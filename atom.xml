<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FILE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-24T12:33:49.049Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Les</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2021/03/09/%E5%88%86%E5%B8%83%E5%BC%8F_%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/03/09/分布式_分布式锁的实现/</id>
    <published>2021-03-09T06:57:15.000Z</published>
    <updated>2021-06-24T12:33:49.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h4><p>首先，类比单进程的锁，我们来看下分布式锁要支持那些特性，才是一个可用的解决方案。<br><strong>基本特性（能用）</strong></p><ol><li>互斥性：需要保证锁只能被分布式系统中的某台服务器的某个线程获取。</li><li>不死锁：如果获得锁的线程发生崩溃而没有释放锁，需要保证锁能释放被其他线程获取。</li></ol><p><strong>高级特性（好用）</strong></p><ol><li>可重入：获取锁的线程可多次获得锁，避免死锁。</li><li>阻塞锁：线程阻塞的锁，简化客户端的实现。</li><li>高可用：提供获得锁和释放锁的HA。</li><li>锁性能：高效获得和释放锁。</li><li>公平与非公平： 公平锁是指按照请求加锁的顺序获得锁，非公平锁真好相反请求加锁是无序的</li><li>TryLock（）：当在一端时间获取不到锁，自动放弃获取锁</li></ol><p>上述的基本的特性，实际上和JVM级别的锁的特性是相同的，所以为了设计一把好的分布式锁尽量满足上述的特性。</p><h4 id="MySql-实现分布式锁"><a href="#MySql-实现分布式锁" class="headerlink" title="MySql 实现分布式锁"></a>MySql 实现分布式锁</h4><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</p><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁:"></a><strong>悲观锁</strong>:</h5><p>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p><p>创建这样一张数据库表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`resource_lock`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"> <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line"> <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line"> <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p><strong>上锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> resource_lock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   ResourceLock rlock = exeSql(<span class="string">"select * from resource_lock where resource_name = name for update"</span>);</span><br><span class="line">     <span class="keyword">if</span> (rlock == <span class="keyword">null</span>) &#123;</span><br><span class="line">           exeSql(<span class="string">"insert into resource_lock(reosurce_name,owner,count) values (name, 'ip',0)"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>解锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><p>存在的问题，往往就是考虑上述的几个特性是否满足。所以上述的实现方法中存在一下几个问题：</p><blockquote><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p><p>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p><p>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</p><p>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p></blockquote><h5 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h5><p>表中添加一个时间戳或者版本号的字段来实现，<code>update xx set version = new... where id = y and version = old</code> 当更新不成功，客户端重试，重新读取最新的版本号或时间戳，再次尝试更新，类似 <code>CAS</code> 机制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`resource`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`resource_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'资源名'</span>,</span><br><span class="line">  <span class="string">`share`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</span><br><span class="line">    <span class="string">`version`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_resource_name`</span> (<span class="string">`resource_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'资源'</span>;</span><br></pre></td></tr></table></figure><p>既然是CAS思想， 缺点必然包括 高并发场景下，线程内的<code>自旋操作</code>会耗费一定的CPU资源。</p><p>加行锁的性能上有一定的开销</p><h4 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h4><p><strong>特点：</strong>CAP模型属于<strong>AP</strong> | 无一致性算法 | <strong>性能好</strong></p><blockquote><ol><li>加锁机制：根据 hash 节点选择一个客户端执行 lua 脚本</li><li>锁互斥机制：再来一个客户端执行同样的 lua 脚本会提示已经存在锁，然后进入循环一直尝试加锁</li><li>可重入机制</li><li>watch dog 自动延期机制</li><li>释放锁机制</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">        <span class="comment">//设置锁</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//获取锁成功</span></span><br><span class="line">            <span class="comment">//若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">            <span class="comment">//通过过期时间删除锁</span></span><br><span class="line">            jedis.expire(lockKey, expireTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 lockKey 存在，则返回失败，否则返回成功。设置成功之后，为了能在完成同步代码之后成功释放锁，方法中使用 expire() 方法给 lockKey 设置一个过期时间，确认 key 值删除，避免出现锁无法释放，导致下一个线程无法获取到锁，即死锁问题。</p><p>但是 setnx + expire 两个命令放在程序里执行，不是原子操作，容易出现问题。</p><p>如果程序设置锁之后，此时，在设置过期时间之前，程序崩溃了，如果 lockKey 没有设置上过期时间，将会出现<code>死锁问题</code>.</p><p>解决以上问题 ，有两个办法：</p><p><strong>1）方式一：</strong>lua脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁脚本，KEYS[1] 要加锁的key，ARGV[1]是UUID随机值，ARGV[2]是过期时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCRIPT_LOCK = <span class="string">"if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then redis.call('pexpire', KEYS[1], ARGV[2]) return 1 else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁脚本，KEYS[1]要解锁的key，ARGV[1]是UUID随机值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCRIPT_UNLOCK = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br></pre></td></tr></table></figure><p><strong>2）方式二：</strong>set原生命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"PX"</span>, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"OK"</span>.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Zookeeper-实现分布式锁"><a href="#Zookeeper-实现分布式锁" class="headerlink" title="Zookeeper 实现分布式锁"></a>Zookeeper 实现分布式锁</h4><p><strong>特点：</strong>CAP模型属于<strong>CP</strong> | <strong>ZAB</strong>一致性算法实现 | <strong>稳定性好</strong></p><blockquote><p>下面简要描述下<strong>临时有序节点</strong>方式的实现原理如下：</p><ol><li>启动客户端，确认链接到了服务器</li><li>多个客户端并发的在特定路径下创建临时性顺序节点</li><li>客户端判断自己的创建的顺序节点是否是最小的，如果是最小的，则获取锁成功</li><li>第三步若判定失败，则采用 zk 的 watch 机制监听自己的前一个顺序节点，等待前一个节点的删除（放锁）事件，再开始第三步判定。</li></ol></blockquote><p>相关设计点：</p><ul><li>由于临时节点在客户端断开后自动删除，可解决<strong>死锁</strong>问题。</li><li>当自身节点的序号不是最小的时候，通过监听机制，一直等到自身节点序号为最小，可实现<strong>阻塞锁</strong>。</li><li>在创建节点是，客户端把自身信息写入节点，获取所有，通过节点信息判断，可实现<strong>锁重入</strong>。</li><li>由于ZK本身为集群部署，可解决<strong>单点</strong>问题，实现HA。</li></ul><p><strong>优点:</strong></p><p>天生设计定位是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</p><p>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</p><p>如果客户端宕机，也没关系，临时节点会自动删除，触发监听器通知下一个节点。</p><p>有效的避免了惊群效应.</p><blockquote><p>惊群效应. 对于操作系统来说，多个进程/线程在等待同一资源是，也会产生类似的效果，其结果就是每当资源可用，所有的进程/线程都来竞争资源。</p><p>危害:</p><ol><li>巨大服务器性能消耗</li><li>可能发生宕机</li><li>巨大的网络冲击</li></ol></blockquote><p><strong>缺点</strong>：</p><p>若有大量的客户端频繁的申请加锁、释放锁，对于ZK集群的压力会比较大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h3&gt;&lt;h4 id=&quot;什么是分布式锁&quot;&gt;&lt;a href=&quot;#什么是分布式锁&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>6.284_Lab2_A</title>
    <link href="http://yoursite.com/2021/02/20/MIT_6.284_Lab2A/"/>
    <id>http://yoursite.com/2021/02/20/MIT_6.284_Lab2A/</id>
    <published>2021-02-20T13:44:15.000Z</published>
    <updated>2021-06-24T12:32:36.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-824-Lab-2-Raft"><a href="#6-824-Lab-2-Raft" class="headerlink" title="6.824 Lab 2: Raft"></a>6.824 Lab 2: Raft</h1><p><img src="image-20210409225547695.png" alt="png"></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This is the first in a series of labs in which you’ll build a fault-tolerant key/value storage system. In this lab you’ll implement Raft, a replicated state machine protocol. In the next lab you’ll build a key/value service on top of Raft. Then you will “shard” your service over multiple replicated state machines for higher performance.</p><p>A replicated service achieves fault tolerance by storing complete copies of its state (i.e., data) on multiple replica servers. Replication allows the service to continue operating even if some of its servers experience failures (crashes or a broken or flaky network). The challenge is that failures may cause the replicas to hold differing copies of the data.</p><p>Raft organizes client requests into a sequence, called the log, and ensures that all the replica servers see the same log. Each replica executes client requests in log order, applying them to its local copy of the service’s state. Since all the live replicas see the same log contents, they all execute the same requests in the same order, and thus continue to have identical service state. If a server fails but later recovers, Raft takes care of bringing its log up to date. Raft will continue to operate as long as at least a majority of the servers are alive and can talk to each other. If there is no such majority, Raft will make no progress, but will pick up where it left off as soon as a majority can communicate again.</p><p>In this lab you’ll implement Raft as a Go object type with associated methods, meant to be used as a module in a larger service. A set of Raft instances talk to each other with RPC to maintain replicated logs. Your Raft interface will support an indefinite sequence of numbered commands, also called log entries. The entries are numbered with <em>index numbers</em>. The log entry with a given index will eventually be committed. At that point, your Raft should send the log entry to the larger service for it to execute.</p><p>You should follow the design in the <a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf" target="_blank" rel="noopener">extended Raft paper</a>, with particular attention to Figure 2. You’ll implement most of what’s in the paper, including saving persistent state and reading it after a node fails and then restarts. You will not implement cluster membership changes (Section 6).</p><p>You may find this <a href="https://thesquareplanet.com/blog/students-guide-to-raft/" target="_blank" rel="noopener">guide</a> useful, as well as this advice about <a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt" target="_blank" rel="noopener">locking</a> and <a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt" target="_blank" rel="noopener">structure</a> for concurrency. For a wider perspective, have a look at Paxos, Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication, and <a href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf" target="_blank" rel="noopener">Bolosky et al.</a> (Note: the student’s guide was written several years ago, and part 2D in particular has since changed. Make sure you understand why a particular implementation strategy makes sense before blindly following it!)</p><p>We also provide a <a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf" target="_blank" rel="noopener">diagram of Raft interactions</a> that can help clarify how your Raft code interacts with the layers on top of it.</p><p>This lab is due in four parts. You must submit each part on the corresponding due date.</p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>If you have done Lab 1, you already have a copy of the lab source code. If not, you can find directions for obtaining the source via git in the <a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html" target="_blank" rel="noopener">Lab 1 instructions</a>.</p><p>We supply you with skeleton code <code>src/raft/raft.go</code>. We also supply a set of tests, which you should use to drive your implementation efforts, and which we’ll use to grade your submitted lab. The tests are in <code>src/raft/test_test.go</code>.</p><p>To get up and running, execute the following commands. Don’t forget the <code>git pull</code> to get the latest software.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/6.824</span><br><span class="line">$ git pull</span><br><span class="line">...</span><br><span class="line">$ cd src/raft</span><br><span class="line">$ go test -race</span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">--- FAIL: TestInitialElection2A (5.04s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">--- FAIL: TestReElection2A (5.03s)</span><br><span class="line">        config.go:326: expected one leader, got none</span><br><span class="line">...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="The-code"><a href="#The-code" class="headerlink" title="The code"></a>The code</h3><p>Implement Raft by adding code to <code>raft/raft.go</code>. In that file you’ll find skeleton code, plus examples of how to send and receive RPCs.</p><p>Your implementation must support the following interface, which the tester and (eventually) your key/value server will use. You’ll find more details in comments in <code>raft.go</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// create a new Raft server instance:</span><br><span class="line">rf := Make(peers, me, persister, applyCh)</span><br><span class="line"></span><br><span class="line">// start agreement on a new log entry:</span><br><span class="line">rf.Start(command interface&#123;&#125;) (index, term, isleader)</span><br><span class="line"></span><br><span class="line">// ask a Raft for its current term, and whether it thinks it is leader</span><br><span class="line">rf.GetState() (term, isLeader)</span><br><span class="line"></span><br><span class="line">// each time a new entry is committed to the log, each Raft peer</span><br><span class="line">// should send an ApplyMsg to the service (or tester).</span><br><span class="line">type ApplyMsg</span><br></pre></td></tr></table></figure><p>A service calls <code>Make(peers,me,…)</code> to create a Raft peer. The peers argument is an array of network identifiers of the Raft peers (including this one), for use with RPC. The <code>me</code> argument is the index of this peer in the peers array. <code>Start(command)</code> asks Raft to start the processing to append the command to the replicated log. <code>Start()</code> should return immediately, without waiting for the log appends to complete. The service expects your implementation to send an <code>ApplyMsg</code> for each newly committed log entry to the <code>applyCh</code> channel argument to <code>Make()</code>.</p><p><code>raft.go</code> contains example code that sends an RPC (<code>sendRequestVote()</code>) and that handles an incoming RPC (<code>RequestVote()</code>). Your Raft peers should exchange RPCs using the labrpc Go package (source in <code>src/labrpc</code>). The tester can tell <code>labrpc</code> to delay RPCs, re-order them, and discard them to simulate various network failures. While you can temporarily modify <code>labrpc</code>, make sure your Raft works with the original <code>labrpc</code>, since that’s what we’ll use to test and grade your lab. Your Raft instances must interact only with RPC; for example, they are not allowed to communicate using shared Go variables or files.</p><p>Subsequent labs build on this lab, so it is important to give yourself enough time to write solid code.</p><h3 id="Part-2A-leader-election-moderate"><a href="#Part-2A-leader-election-moderate" class="headerlink" title="Part 2A: leader election (moderate)"></a>Part 2A: leader election (<a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html" target="_blank" rel="noopener">moderate</a>)</h3><p>Implement Raft leader election and heartbeats (<code>AppendEntries</code> RPCs with no log entries). The goal for Part 2A is for a single leader to be elected, for the leader to remain the leader if there are no failures, and for a new leader to take over if the old leader fails or if packets to/from the old leader are lost. Run <code>go test -run 2A -race</code> to test your 2A code.</p><ul><li>You can’t easily run your Raft implementation directly; instead you should run it by way of the tester, i.e. <code>go test -run 2A -race</code>.</li><li>Follow the paper’s Figure 2. At this point you care about sending and receiving RequestVote RPCs, the Rules for Servers that relate to elections, and the State related to leader election.</li><li>Add the Figure 2 state for leader election to the <code>Raft</code> struct in <code>raft.go</code>. You’ll also need to define a struct to hold information about each log entry.</li><li>Fill in the <code>RequestVoteArgs</code> and <code>RequestVoteReply</code> structs. Modify <code>Make()</code> to create a background goroutine that will kick off leader election periodically by sending out <code>RequestVote</code> RPCs when it hasn’t heard from another peer for a while. This way a peer will learn who is the leader, if there is already a leader, or become the leader itself. Implement the <code>RequestVote()</code> RPC handler so that servers will vote for one another.</li><li>To implement heartbeats, define an <code>AppendEntries</code> RPC struct (though you may not need all the arguments yet), and have the leader send them out periodically. Write an <code>AppendEntries</code> RPC handler method that resets the election timeout so that other servers don’t step forward as leaders when one has already been elected.</li><li>Make sure the election timeouts in different peers don’t always fire at the same time, or else all peers will vote only for themselves and no one will become the leader.</li><li>The tester requires that the leader send heartbeat RPCs no more than ten times per second.</li><li>The tester requires your Raft to elect a new leader within five seconds of the failure of the old leader (if a majority of peers can still communicate). Remember, however, that leader election may require multiple rounds in case of a split vote (which can happen if packets are lost or if candidates unluckily choose the same random backoff times). You must pick election timeouts (and thus heartbeat intervals) that are short enough that it’s very likely that an election will complete in less than five seconds even if it requires multiple rounds.</li><li>The paper’s Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds. Because the tester limits you to 10 heartbeats per second, you will have to use an election timeout larger than the paper’s <strong>150 to 300 milliseconds</strong>, but not too large, because then you may fail to elect a leader within five seconds.</li><li>You may find Go’s <a href="https://golang.org/pkg/math/rand/" target="_blank" rel="noopener">rand</a> useful.</li><li>You’ll need to write code that takes actions periodically or after delays in time. The easiest way to do this is to create a goroutine with a loop that calls <a href="https://golang.org/pkg/time/#Sleep" target="_blank" rel="noopener">time.Sleep()</a>; (see the <code>ticker()</code> goroutine that <code>Make()</code> creates for this purpose). Don’t use Go’s <code>time.Timer</code> or <code>time.Ticker</code>, which are difficult to use correctly.</li><li>The <a href="https://pdos.csail.mit.edu/6.824/labs/guidance.html" target="_blank" rel="noopener">Guidance page</a> has some tips on how to develop and debug your code.</li><li>If your code has trouble passing the tests, read the paper’s Figure 2 again; the full logic for leader election is spread over multiple parts of the figure.</li><li>Don’t forget to implement <code>GetState()</code>.</li><li>The tester calls your Raft’s <code>rf.Kill()</code> when it is permanently shutting down an instance. You can check whether <code>Kill()</code> has been called using <code>rf.killed()</code>. You may want to do this in all loops, to avoid having dead Raft instances print confusing messages.</li><li>Go RPC sends only struct fields whose names start with capital letters. Sub-structures must also have capitalized field names (e.g. fields of log records in an array). The <code>labgob</code> package will warn you about this; don’t ignore the warnings.</li></ul><p>Be sure you pass the 2A tests before submitting Part 2A, so that you see something like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run 2A -race</span><br><span class="line">Test (2A): initial election ...</span><br><span class="line">  ... Passed --   4.0  3   32    9170    0</span><br><span class="line">Test (2A): election after network failure ...</span><br><span class="line">  ... Passed --   6.1  3   70   13895    0</span><br><span class="line">PASS</span><br><span class="line">ok      raft    10.187s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Each “Passed” line contains five numbers; these are the time that the test took in seconds, the number of Raft peers (usually 3 or 5), the number of RPCs sent during the test, the total number of bytes in the RPC messages, and the number of log entries that Raft reports were committed. Your numbers will differ from those shown here. You can ignore the numbers if you like, but they may help you sanity-check the number of RPCs that your implementation sends. For all of labs 2, 3, and 4, the grading script will fail your solution if it takes more than 600 seconds for all of the tests (<code>go test</code>), or if any individual test takes more than 120 seconds.</p><p><img src="image-20210410171642563.png" alt="png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="keyword">int</span></span><br><span class="line">CandidateId  <span class="keyword">int</span></span><br><span class="line">LastLogIndex <span class="keyword">int</span></span><br><span class="line">LastLogTerm  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// example RequestVote RPC reply structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">Term    <span class="keyword">int</span></span><br><span class="line">Granted <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">RequestVote</span><span class="params">(args *RequestVoteArgs, reply *RequestVoteReply)</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line"><span class="comment">// 我接受到了投票请求</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.如果请求者的任期比我还小, 不给投票</span></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">DPrintf(<span class="string">"[RequestVote] me=%v, too old term dont give vote, currentTerm=%v"</span>, rf.me, rf.currentTerm)</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Granted = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.请求者的任期更大, 我成为Follower</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">DPrintf(<span class="string">"[RequestVote] %v get bigger term=%v from %v"</span>, rf.me, args.Term, args.CandidateId)</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.role = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.votedFor == args.CandidateId || rf.votedFor == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// Follower have voted to him or havenot vote yet, then give out tickect.</span></span><br><span class="line">DPrintf(<span class="string">"[RequestVote] %v give vote to %v, lastLogIndex=%v, lastLogTerm=%v, his LastLogIndex=%v, LastLogTerm=%v"</span>, rf.me, args.CandidateId, <span class="number">0</span>, <span class="number">0</span>, args.LastLogIndex, args.LastLogTerm)</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">reply.Granted = <span class="literal">true</span></span><br><span class="line">rf.refreshElectionTimeout()</span><br><span class="line">rf.persist()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Follower has voted to other Candidate.</span></span><br><span class="line">DPrintf(<span class="string">"[RequestVote] %v this term has voted to %v"</span>, rf.me, rf.votedFor)</span><br><span class="line">reply.Granted = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">startElectionTimeOutTask</span><span class="params">(term <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> rf.currentTerm != term || rf.role != Candidate &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对自己投票.</span></span><br><span class="line">rf.votedFor = rf.me</span><br><span class="line">rf.getVotedTickets = <span class="number">1</span></span><br><span class="line">lastLogIndex := <span class="number">0</span></span><br><span class="line">lastLogTerm := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> server := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line"><span class="keyword">if</span> server == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.askForVote(server, term, lastLogIndex, lastLogTerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">askForVote</span><span class="params">(server <span class="keyword">int</span>, sendTerm <span class="keyword">int</span>, lastLogIndex <span class="keyword">int</span>, lastLogTerm <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 发送参数.</span></span><br><span class="line">requestArgs := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         sendTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: lastLogIndex,</span><br><span class="line">LastLogTerm:  lastLogTerm,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用结果.</span></span><br><span class="line">reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok := rf.sendRequestVote(server, requestArgs, reply); !ok &#123;</span><br><span class="line"><span class="comment">// 发送失败,rpc调用出问题.</span></span><br><span class="line">DPrintf(<span class="string">"[askForVote] %v send requestVote to %v, error"</span>, rf.me, server)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="comment">// 发送过去之后. 返回结果.</span></span><br><span class="line"><span class="comment">// 0.返回结果之后查看当前节点状态, 现在节点的任期或者角色已经变更.</span></span><br><span class="line"><span class="keyword">if</span> sendTerm &lt; rf.currentTerm || rf.role != Candidate &#123;</span><br><span class="line">DPrintf(<span class="string">"[askForVote] information, "</span>+</span><br><span class="line"><span class="string">"startTerm=%v, currentTerm=%v, role=%v"</span>, sendTerm, rf.currentTerm, rf.role)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.目标节点的任期更大</span></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; sendTerm &#123;</span><br><span class="line">rf.currentTerm = max(reply.Term, rf.currentTerm)</span><br><span class="line">rf.role = Follower</span><br><span class="line">DPrintf(<span class="string">"[askForVote] %v term update during requestVote from %v, now term=%v"</span>, rf.me, server, rf.currentTerm)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 收到投票.检查自己的票数是否足够.</span></span><br><span class="line"><span class="keyword">if</span> reply.Granted &amp;&amp; sendTerm == rf.currentTerm &#123;</span><br><span class="line">rf.getVotedTickets++</span><br><span class="line">DPrintf(<span class="string">"[askForVote] %v get vote from "</span>+</span><br><span class="line"><span class="string">"requestVote from %v, now term=%v"</span>, rf.me, server, sendTerm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.getVotedTickets &gt;= rf.getMajority() &#123;</span><br><span class="line">rf.role = Leader</span><br><span class="line">rf.changToLeader()</span><br><span class="line">DPrintf(<span class="string">"[askForVote] %v is leader now with term %v"</span>, rf.me, sendTerm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6-824-Lab-2-Raft&quot;&gt;&lt;a href=&quot;#6-824-Lab-2-Raft&quot; class=&quot;headerlink&quot; title=&quot;6.824 Lab 2: Raft&quot;&gt;&lt;/a&gt;6.824 Lab 2: Raft&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;im
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="http://yoursite.com/2020/12/09/%E6%BA%90%E7%A0%81_ReadWriteLock/"/>
    <id>http://yoursite.com/2020/12/09/源码_ReadWriteLock/</id>
    <published>2020-12-09T08:33:07.000Z</published>
    <updated>2021-06-24T12:34:06.372Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>具有与ReentrantLock类似的<strong>公平锁和非公平锁</strong>的实现：默认的支持非公平锁，对于二者而言，非公平锁的吞吐量由于公平锁；</p></li><li><p>支持重入：读线程获取读锁之后能够再次获取读锁，写线程获取写锁之后能再次获取写锁，也可以获取读锁。</p></li><li><p>锁能降级：遵循获取写锁、获取读锁在释放写锁的顺序，即写锁能够降级为读锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock-AQS"><a href="#ReentrantReadWriteLock-AQS" class="headerlink" title="ReentrantReadWriteLock. AQS"></a>ReentrantReadWriteLock. AQS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>); <span class="comment">// readLock 和普通的独占锁一样.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>); <span class="comment">// 写锁是一个共享锁. 读写锁源码主不同的地方.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Walkthrough:</span></span><br><span class="line"><span class="comment">         * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">         * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">         *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">         *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">         *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">         *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">         *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">         *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">         *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">         * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">         *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">         *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//如果当前有写线程并且本线程不是写线程，不符合重入，失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//得到读锁的个数</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="comment">//如果读不应该阻塞并且读锁的个数小于最大值65535，并且可以成功更新状态值,成功</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//如果当前读锁为0</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//第一个读线程就是当前线程</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前线程重入了，记录firstReaderHoldCount</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前读线程和第一个读线程不同,记录每一个线程读的次数</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">// 当前线程读取此次数, 使用的是一个HoldCounter 类, 记录了</span></span><br><span class="line">                    <span class="comment">//count 和 ThreadId 避免直接使用THread, 因为由于引用要造成垃圾.</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，循环尝试</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">//一旦有别的线程获得了写锁，返回-1，失败</span></span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//如果读线程需要阻塞</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//说明有别的读线程占有了锁</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter; <span class="comment">// 当前线程 cachedHoldCounter</span></span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get(); <span class="comment">// ThreadLocal</span></span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果读锁达到了最大值，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//如果成功更改状态，成功返回</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*对于公平锁，只要队列中有线程在等待，那么将会返回true，也就意味着读线程需要阻塞；对于非公平锁，如果当前有线程获取了写锁，则返回true。一旦不阻塞，那么读线程将会有机会获得读锁。*/</span></span><br></pre></td></tr></table></figure><ul><li>写锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sync.acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 和普通的锁差不多的, 多咧点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">//得到调用lock方法的当前线程</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//得到写锁的个数</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">//如果当前有写锁或者读锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果写锁为0或者当前线程不是独占线程（不符合重入），返回false</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//如果写锁的个数超过了最大值，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// 写锁重入，返回true</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前没有写锁或者读锁，如果写线程应该阻塞或者CAS失败，返回false</span></span><br><span class="line">       <span class="comment">// FairSync的实现是如果等待队列中有等待线程，当前方法则返回false，说明公平模式下，只要队列中有线程在等待，那么后来的这个线程也是需要记入队列等待的；NonfairSync writerShouldBlock中的直接返回的直接是false，说明不需要阻塞。从上面的代码可以得出，当没有锁时，如果使用的非公平模式下的写锁的话，那么返回false，直接通过CAS就可以获得写锁。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//否则将当前线程置为获得写锁的线程,返回true</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前没有写锁或读锁时，第一个获取锁的线程都会成功，无论该锁是写锁还是读锁。</li><li>如果当前已经有了读锁，那么这时获取写锁将失败，获取读锁有可能成功也有可能失败</li><li>如果当前已经有了写锁，那么这时获取读锁或写锁，如果线程相同（可重入），那么成功；否则失败</li></ul><p>读释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">// arg = 1</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**一旦没有锁了，就返回true，否则false；返回true后，那么则需要释放等待队列中的线程，这时读线程和写线程都有可能再获得锁。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//得到调用unlock的线程</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//如果是第一个获得读锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，是HoldCounter中计数-1</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">//释放一把读锁</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="comment">//如果CAS更新状态成功，返回读锁是否等于0；失败的话，则重试</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>写锁释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果当前没有线程持有写锁，但是还要释放写锁，抛出异常</span></span><br><span class="line"><span class="comment">得到解除一把写锁后的状态，如果没有写锁了，那么将AQS的线程置为null</span></span><br><span class="line"><span class="comment">不管第二步中是否需要将AQS的线程置为null，AQS的状态总是要更新的</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果没有线程持有写锁，但是仍要释放，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//如果没有写锁了，那么将AQS的线程置为null</span></span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;具有与ReentrantLock类似的&lt;strong&gt;公平锁和非公平锁&lt;/strong&gt;的实现：默认的支持非公平锁，对于二者而言，非公平锁的吞吐量由于公平锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持重入：读线程获取读锁之后能够再次获取读锁，写线程获取写锁之
      
    
    </summary>
    
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://yoursite.com/2020/12/09/%E6%BA%90%E7%A0%81_ReentantLock/"/>
    <id>http://yoursite.com/2020/12/09/源码_ReentantLock/</id>
    <published>2020-12-09T06:57:15.000Z</published>
    <updated>2021-06-24T12:34:15.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ReentrantLock-AQS"><a href="#ReentrantLock-AQS" class="headerlink" title="ReentrantLock. AQS"></a>ReentrantLock. AQS</h3><h4 id="公平锁-与-非公平锁"><a href="#公平锁-与-非公平锁" class="headerlink" title="公平锁 与 非公平锁"></a>公平锁 与 非公平锁</h4><ul><li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li><li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0</strong>：新结点入队时的默认状态。</li></ul><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><ul><li>fair 直接调用acquire  非公平多了一点逻辑.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 公平 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平 -&gt; 实际上就是多了当调用lock方法的时候, 锁是否空闲, 如果空闲就不会去执行加入Waiter的队列.</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* fair</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123; <span class="comment">// acquires = 1；</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 没有上锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 抢锁成功, 设置为当前独占.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; </span><br><span class="line">    <span class="comment">// 当前线程和已经获得锁的线程是不是同一个 ——&gt; 重入， state + 1；</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建节点逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果当前不能获得锁(锁不空闲). 那么新建一个等待的节点, 该节点包含了当前线程</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">// mode = NUll</span></span><br><span class="line">    <span class="comment">// EXCLUSIVE（独占）和SHARED（共享)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span></span><br><span class="line"><span class="comment">            this.nextWaiter = mode;</span></span><br><span class="line"><span class="comment">            this.thread = thread;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    </span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果前驱节点不等于空 -&gt;老老实实加入队列中. </span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前驱节点为空. 说明当前节点是可能加入队列的第一个节点</span></span><br><span class="line">   <span class="comment">// enq(node);方法如下</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize </span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 保证头节点只初始化一次</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 初始化一个空节点之后, 将当前节点加入队列, 实际上以及是第二个节点 . 但是第一个节点Thread 为空.</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加入等待逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); </span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果是第一个线程节点 判断当前节点的前驱是不是head</span></span><br><span class="line">                <span class="comment">// 如果是head 说明当前线程是在队列中的第一个. 那么就要一直去争取锁.</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是队列头, 先尝试之后再阻塞. </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有趣的再次调用逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//因为pre 的waitStatus 开始都是0, 前驱几点的装填改变是通过后继几点的操作.</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 如果等于 -1;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// 一开始是0 ; 然后将其置为 -1; .</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第一次调用该方法. 返回false -&gt; </span></span><br><span class="line">    <span class="comment">// 即就是现实了正如方法名字所写的.shouldParkAfterFailedAcquire, 就会返回上层方法, 再此尝试去获得锁. </span></span><br><span class="line">    <span class="comment">// 如果没有获得成功, 上一轮已经修改成了-1, 所以返回true. 执行后面的阻塞操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后将线程状状态改变.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//将当前线程 park掉.阻塞</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞之后如何唤醒.</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 等待节点不为空, 并且waitStatus 被修改过, 即后继有节点.</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123; <span class="comment">// node = head</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);  <span class="comment">//线程阻塞的时候被修改过. 首先将状态置为0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next; <span class="comment">// 这是真正的节点.</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 节点被cancelled掉了. 删掉节点.</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// 队列中取消阻塞的第一个节点.</span></span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 取消阻塞状态. 返回到阻塞点. 并且开始尝试去获取锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ReentrantLock-AQS&quot;&gt;&lt;a href=&quot;#ReentrantLock-AQS&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock. AQS&quot;&gt;&lt;/a&gt;ReentrantLock. AQS&lt;/h3&gt;&lt;h4 id=&quot;公平锁
      
    
    </summary>
    
    
      <category term="源码" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之ReplicateLog</title>
    <link href="http://yoursite.com/2020/11/22/Raft_AppendEntries/"/>
    <id>http://yoursite.com/2020/11/22/Raft_AppendEntries/</id>
    <published>2020-11-22T05:40:15.000Z</published>
    <updated>2021-06-24T12:31:50.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ReplicateLog"><a href="#ReplicateLog" class="headerlink" title="ReplicateLog"></a>ReplicateLog</h3><p><img src="1.png" alt="png"></p><p><strong>ReplicateLog</strong>是整个Raft中的关键地方.所有的信息都是通过AppendEntries的方式通知到所有节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReplicateLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.group().isStandalone()) &#123;</span><br><span class="line">        context.log().advanceCommitIndex(context.log().getNextIndex() - <span class="number">1</span>, role.getTerm());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 GroupMembers 信息决定发送的数据</span></span><br><span class="line">    <span class="keyword">for</span> (GroupMember member : context.group().listReplicationTarget()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (member.shouldReplicate(context.config().getLogReplicationReadTimeout())) &#123;</span><br><span class="line">            doReplicateLog(member, context.config().getMaxReplicationEntries());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry包括几种信息:</p><ol><li><p>no-op. 存粹的心跳.</p></li><li><p>普通信息. curd</p></li><li><p>配置信息. 整个集群的配置.</p><p>​                                                                                                                                                                            </p><p><img src="2.png" alt="png">                                        </p></li></ol><h4 id="NoOpEntry"><a href="#NoOpEntry" class="headerlink" title="NoOpEntry"></a>NoOpEntry</h4><p>普通的心跳信息，当节点当选Leader之后。没有Client的数据请求， Leader需要和Follower保证相互之间是活着的。Leader将一直发送该消息。</p><h4 id="GeneralEntry"><a href="#GeneralEntry" class="headerlink" title="GeneralEntry"></a>GeneralEntry</h4><h5 id="create-and-send"><a href="#create-and-send" class="headerlink" title="create and send"></a>create and send</h5><p>这个通过GenerEntry让节点之间保持最终一致性.</p><ul><li><p>每个节点都是有Log信息的，画了一个简图：</p><p><img src="3.png" alt="png">    </p></li></ul><p>我们可以看到一个Sequence，保存着所有的Entry。每个Entry中存有三大件 Kind ， Index ， Term. LogReplicate 就是根据 index 和 Term来进行判断的。Snapshot是在某个时候的数据快照。帮忙节点快速恢复数据。最后将数据提交到State machine。 下面哪个空白的是ConfigChangeLog.</p><p>那么给Follower发送些什么数据呢-&gt;这就要根据Leader节点记录的每一个Follower信息了。</p><ul><li>Group</li></ul><p><img src="4.png" alt="png">    </p><p>当前Leader中的Follower信息.Follower的地址,是否删除, 是否正在复制.还有比较关键的就是 NextIndex和 MatchIndex.</p><p>Follower通过比较Log的nextLogIndex, 和 GroupMember的 NextIndex.来决定发送的数据.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendEntriesRpc <span class="title">createAppendEntriesRpc</span><span class="params">(<span class="keyword">int</span> term, NodeId selfId, <span class="keyword">int</span> nextIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextLogIndex = entrySequence.getNextLogIndex();</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">if</span> (nextIndex &lt;= snapshot.getLastIncludedIndex()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EntryInSnapshotException(nextIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    AppendEntriesRpc rpc = <span class="keyword">new</span> AppendEntriesRpc();</span><br><span class="line">    rpc.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">    rpc.setTerm(term);</span><br><span class="line">    rpc.setLeaderId(selfId);</span><br><span class="line">    rpc.setLeaderCommit(commitIndex);</span><br><span class="line">    <span class="keyword">if</span> (nextIndex == snapshot.getLastIncludedIndex() + <span class="number">1</span>) &#123;</span><br><span class="line">        rpc.setPrevLogIndex(snapshot.getLastIncludedIndex());</span><br><span class="line">        rpc.setPrevLogTerm(snapshot.getLastIncludedTerm());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry entry = entrySequence.getEntry(nextIndex - <span class="number">1</span>);</span><br><span class="line">        rpc.setPrevLogIndex(entry.getIndex());</span><br><span class="line">        rpc.setPrevLogTerm(entry.getTerm());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entrySequence.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex =  nextLogIndex;</span><br><span class="line">        <span class="comment">//2.1</span></span><br><span class="line">        rpc.setEntries(entrySequence.subList(nextIndex, maxIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rpc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>值得注意的是： Leader 根据每个member的信息不同是发送的不同的数据。</p><ol><li><p><strong>snapshot.LastIndex &gt; member.nextIndex</strong></p><p>member的<strong>nextIndex</strong>比我快照的<strong>最后**</strong>Index**都小,那么肯定是首先发送一个快照信息给member</p></li><li><p><strong>leader.nextlogindex &gt; member.nextIndex</strong></p><p><strong>leader</strong>的<strong>nextLogindex</strong> 大于<strong>member</strong>的<strong>index</strong> 这是最常规的.所以将Leader比member新的部分(subSequence)添加到AppendEntries里面。</p></li></ol></li><li><p>知道什么时候发送些什么之后我们再来看看AppendEntries本身应该发送些什么数据。在论文中我们可以看到</p><p><img src="5.png" alt="png">    </p><p>preLogIndex 和 prevLogTerm：他们用于和Follower进行日志的配置。</p><p>leaderCommit 将 Follower的Commit更新，避免Leader还没有Commit，Follower就Commit了</p><p>entries 自然就是Leader的角度看 Follower 所需要的信息。</p></li></ul><h4 id="receive-and-reply"><a href="#receive-and-reply" class="headerlink" title="receive and reply"></a>receive and reply</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AppendEntriesRpc rpc = rpcMessage.get();</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &lt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    becomeFollower(rpc.getTerm(), <span class="keyword">null</span>, rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rpc.term == my term</span></span><br><span class="line"><span class="keyword">switch</span> (role.getName()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOLLOWER:</span><br><span class="line">        <span class="comment">// reset election timeout and append entries</span></span><br><span class="line">        becomeFollower(rpc.getTerm(), ((FollowerNodeRole) role).getVotedFor(), rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">    <span class="keyword">case</span> CANDIDATE:</span><br><span class="line">        <span class="comment">// more than one candidate but another node won the election</span></span><br><span class="line">        becomeFollower(rpc.getTerm(), <span class="keyword">null</span>, rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">    <span class="keyword">case</span> LEADER:</span><br><span class="line">        <span class="comment">// todo the another leader how can deal with this condition</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unexpected node role ["</span> + role.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rpc.Term &lt; role.Term 任期不同请求来的Term没有我本身的Term大呢. 将单前节点的Term发送回去。</li><li>rpc.Term &gt; role.Term 任期不同比我的任期大,肯定是我的leader. 根据来的信息进行数据更新, 返回更新结果。</li><li>rpc.Term = role.Term  根据当前节点的角色不同 （Follower 和 Candidate），根据来的信息进行数据更新返回更新结果。</li></ul><p>值得注意的， 节点在收到消息之后角色为（Follower 和 Candidate）都会重置 ElectionTimeout。</p><p><strong>节点的数据同步</strong></p><p>当然所有数据也是通过节点的Log首先commit， 然后根据Leader的(apply)commitIndex， 进行apply.</p><ul><li>首先判断rpc.prevLogIndex rpc，prevLogTrem与当前节点的Index是否能够匹配的上。及查询当前节点是否有prevLogIndex数据-&gt; 1.根据快照 2. 更具log序列获取。</li><li>确保当前节点存在pervLog数据时， 删除Follower的未匹配（followerEntryMeta.Term() != leaderEntry.Term()）节点。</li><li>为当前节点log 添加新的节点信息同样如果是ConfigChange信息将会特别的添加到ConfigList</li></ul><h4 id="appendEntriesResult"><a href="#appendEntriesResult" class="headerlink" title="appendEntriesResult"></a>appendEntriesResult</h4><ul><li>在上述 rpc.Term &lt; role.Term的时候我们返回回来的Term，因为 Leader遇到了更大的Term，所以变为Follower</li><li>检测当前节点角色.如果以及不是leader了那就没有必要处理result</li><li>根据返回消息的节点获取Leader中保存的member信息， member被删除了或者不是major的一员就不用处理。</li><li>返回消息是成功的话，将Leader的member信息更新， 并且根据Group中超过半数匹配的Index进行apply，到状态机。</li><li>继续doReplicateLog</li></ul><h4 id="GroupConfigEntry"><a href="#GroupConfigEntry" class="headerlink" title="GroupConfigEntry"></a>GroupConfigEntry</h4><p>这一部分留到改变配置的时候再做详细的分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ReplicateLog&quot;&gt;&lt;a href=&quot;#ReplicateLog&quot; class=&quot;headerlink&quot; title=&quot;ReplicateLog&quot;&gt;&lt;/a&gt;ReplicateLog&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之VoteRequest</title>
    <link href="http://yoursite.com/2020/11/15/Raft_VoteRequest/"/>
    <id>http://yoursite.com/2020/11/15/Raft_VoteRequest/</id>
    <published>2020-11-15T05:40:15.000Z</published>
    <updated>2021-06-24T12:32:12.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeaderElection"><a href="#LeaderElection" class="headerlink" title="LeaderElection"></a>LeaderElection</h3><p>在之前我们在connector的阶段以及简单使用VoteRequestRPC作为例子来说明底层的网络通信.一节我将详细记录LeaderElection阶段的实现.</p><p><img src="1.png" alt="png"></p><p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。Raft算法将时间分为一个个的<strong>任期（term）</strong>，每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p><h4 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h4><p>在之前的概述中我们大概介绍了Raft算法中节点存在有3个角色。即Leader， Candidate， Follower。并且角色中保存着任期（Term）</p><p><img src="2.png" alt="png"></p><p><strong>Candidate</strong>：其中Candidate是最为简单的，因为它只在节点选举阶段短暂存在， 节点的觉大多数时间都是Leader或者Follower。</p><p><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志（包括心跳， configChange和普通请求数据），当日志同步到大多数节点上后告诉Follower提交日志。</p><p><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p><p><img src="3.png" alt="png"></p><h4 id="ElectionTimeout"><a href="#ElectionTimeout" class="headerlink" title="ElectionTimeout"></a>ElectionTimeout</h4><p>从上述UML图中我们可以看到，这里在Follower和Candidate中都已一个electionTimeout字段。ElectionTimeout类中封装了倒计时的Future.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ElectionTimeout <span class="title">scheduleElectionTimeout</span><span class="params">(@Nonnull Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * task : context.taskExecutor().submit(this::doProcessElectionTimeout, LOGGING_FUTURE_CALLBACK);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> timeout = electionTimeoutRandom.nextInt(maxElectionTimeout - minElectionTimeout) + minElectionTimeout;</span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.schedule(task, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElectionTimeout(scheduledFuture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Follower在运行的时候就会有一个electionTimeout倒计时钟，防止节点长时间没有收到消息。</p><ul><li>所以当Follower 和Candidate收到来自其他节点的消息的时候都会重置electionTimeout。</li><li>当超时还没有收到消息节点将会转换为Candidate并发起投票请求。</li></ul><h4 id="投票请求（candidate）"><a href="#投票请求（candidate）" class="headerlink" title="投票请求（candidate）"></a>投票请求（candidate）</h4><p>问题来了，节点同时启动到底是谁成为Candidate呢。其实electionTimout的倒计时时间每个节点都在在一个范围内取得随机值。谁先触发超时，谁就先成为Candidate并发起投票请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">changeToRole(<span class="keyword">new</span> CandidateNodeRole(oldTerm + <span class="number">1</span>, scheduleElectionTimeout()));</span><br><span class="line">            EntryMeta lastEntryMeta = context.log().getLastEntryMeta();</span><br><span class="line">            RequestVoteRpc rpc = <span class="keyword">new</span> RequestVoteRpc();</span><br><span class="line">            rpc.setTerm(newTerm);</span><br><span class="line">            rpc.setCandidateId(context.selfId());</span><br><span class="line">            rpc.setLastLogIndex(lastEntryMeta.getIndex());</span><br><span class="line">            rpc.setLastLogTerm(lastEntryMeta.getTerm());</span><br><span class="line">context.connector().sendRequestVote(rpc, context.group().listEndpointOfMajorExceptSelf());</span><br></pre></td></tr></table></figure><h4 id="收到投票请求（members）"><a href="#收到投票请求（members）" class="headerlink" title="收到投票请求（members）"></a>收到投票请求（members）</h4><p>当其他节点收到这个投票请求。根据请求的Term和角色进行相应的回复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip non-major node, it maybe removed node</span></span><br><span class="line"><span class="keyword">if</span> (!context.group().isMemberOfMajor(rpcMessage.getSourceNodeId())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reply current term if result's term is smaller than current one</span></span><br><span class="line">RequestVoteRpc rpc = rpcMessage.get();</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &lt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// step down if result's term is larger than current term</span></span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> voteForCandidate = !context.log().isNewerThan(rpc.getLastLogIndex(), rpc.getLastLogTerm());</span><br><span class="line">    becomeFollower(rpc.getTerm(), (voteForCandidate ? rpc.getCandidateId() : <span class="keyword">null</span>), <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(rpc.getTerm(), voteForCandidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (role.getName()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOLLOWER:</span><br><span class="line">        FollowerNodeRole follower = (FollowerNodeRole) role;</span><br><span class="line">        NodeId votedFor = follower.getVotedFor();</span><br><span class="line">        <span class="comment">// reply vote granted for</span></span><br><span class="line">        <span class="comment">// 1. not voted and candidate's log is newer than self</span></span><br><span class="line">        <span class="comment">// 2. voted for candidate</span></span><br><span class="line">        <span class="keyword">if</span> ((votedFor == <span class="keyword">null</span> &amp;&amp; !context.log().isNewerThan(rpc.getLastLogIndex(), rpc.getLastLogTerm())) ||</span><br><span class="line">                Objects.equals(votedFor, rpc.getCandidateId())) &#123;</span><br><span class="line">            becomeFollower(role.getTerm(), rpc.getCandidateId(), <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(rpc.getTerm(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">case</span> CANDIDATE: <span class="comment">// voted for self</span></span><br><span class="line">    <span class="keyword">case</span> LEADER:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unexpected node role ["</span> + role.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先检测是不是我配置文件配置的一家人啊。正所谓不是一家人不进一家门。 不是 不投票（避免新配置的节点干坏事）</p></li><li><p>再来看看你的任期有没有我的任期大。哟你的任期还没有我的任期高呢 你有什么资格 。 不投票</p><p>rpc.getTerm() &lt; role.getTerm()</p></li><li><p>你的任期比我的高，你是爸爸。 再看看Logindex 呢。 如果logIndex比我的小。 不投票 否则立马成为你的马仔Follower并投票。</p></li><li><p>当任期相等，需要看看当前我的自己的角色是什么啊。是follower更具index判断投票与否，是candidate 已经给自己投票了。leader肯定久更不会投票了 。</p></li></ul><p>总结一下 ： 节点收到消息之后，给Candidate投票的情况其实就很明确的两种情况</p><ul><li><ol><li>节点的任期（Term）小于请求的任期。</li></ol></li><li><ol><li>任期相等的时候，还需要判断下当前节点的角色，本身是Follower，根据logindex来判断是否投票，切换领导。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpcMessage.getChannel().writeRequestVoteResult(result);</span><br></pre></td></tr></table></figure><p>节点收到消息并且处理完之后肯等就是返回处理结果了。</p><h4 id="收到投票结果（candidate）"><a href="#收到投票结果（candidate）" class="headerlink" title="收到投票结果（candidate）"></a>收到投票结果（candidate）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    <span class="comment">// remote node have large term， I will never become a Leader -&gt; change to follower</span></span><br><span class="line">    becomeFollower(result.getTerm(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check role  </span></span><br><span class="line"><span class="keyword">if</span> (role.getName() != RoleName.CANDIDATE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do nothing if not vote granted</span></span><br><span class="line"><span class="keyword">if</span> (!result.isVoteGranted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> currentVotesCount = ((CandidateNodeRole) role).getVotesCount() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> countOfMajor = context.group().getCountOfMajor();</span><br><span class="line">role.cancelTimeoutOrTask();</span><br><span class="line"><span class="keyword">if</span> (currentVotesCount &gt; countOfMajor / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// become leader</span></span><br><span class="line">    resetReplicatingStates();</span><br><span class="line">    changeToRole(<span class="keyword">new</span> LeaderNodeRole(role.getTerm(), scheduleLogReplicationTask()));</span><br><span class="line">    context.log().appendEntry(role.getTerm()); <span class="comment">// no-op log</span></span><br><span class="line">    context.connector().resetChannels(); <span class="comment">// close all inbound channels</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update votes count</span></span><br><span class="line">    changeToRole(<span class="keyword">new</span> CandidateNodeRole(role.getTerm(), currentVotesCount, scheduleElectionTimeout()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当candidate收到投票结果之后</p><ul><li>如果收到的结果中任期（Term） 比自己的高。说明member的任期高，并且没有给我投票的。而且自己遇到了高任期就该立马认怂。成为Follower</li><li>如果我当前已经不是Candidate了那投票也就没有意义了。</li><li>查看投票结果<ul><li>如果投票True说明我获取到了当前票。计算我的总票数<ul><li>如果总票数 大于一半 - 成为Leader ——&gt;去做leader该做的事情</li><li>否则更新自己的票数，继续等待投票</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeaderElection&quot;&gt;&lt;a href=&quot;#LeaderElection&quot; class=&quot;headerlink&quot; title=&quot;LeaderElection&quot;&gt;&lt;/a&gt;LeaderElection&lt;/h3&gt;&lt;p&gt;在之前我们在connector的阶段以及简单
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之Executor , Scheduler</title>
    <link href="http://yoursite.com/2020/11/14/Raft_RPC_Executor/"/>
    <id>http://yoursite.com/2020/11/14/Raft_RPC_Executor/</id>
    <published>2020-11-14T08:23:12.000Z</published>
    <updated>2021-06-24T12:34:29.897Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="png"></p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p><img src="2.png" alt="png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在每个节点中我们主要的任务有两个最基础的任务, 1. 是ElectionTimeout 任务,选举时发挥作用, 首先timeout的转换为Candidate. 还有就是我日志复制需要一个Leader需要定时调度发送AppendEntries. (心跳, 数据, 配置修改).</p><p>所以在在发送这些请求或者执行这些任务的时候.我需要新开线程进行执行.-&gt;防止阻塞.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    Future&lt;?&gt; submit(<span class="meta">@Nonnull</span> Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit callable task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;  result type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    &lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(@Nonnull Callable&lt;V&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task with callback.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task     task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(@Nonnull Runnable task, @Nonnull FutureCallback&lt;Object&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task with callbacks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callbacks callbacks, should not be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(@Nonnull Runnable task, @Nonnull Collection&lt;FutureCallback&lt;Object&gt;&gt; callbacks)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shutdown.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule log replication task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> log replication task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function">LogReplicationTask <span class="title">scheduleLogReplicationTask</span><span class="params">(@Nonnull Runnable task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule election timeout.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> election timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function">ElectionTimeout <span class="title">scheduleElectionTimeout</span><span class="params">(@Nonnull Runnable task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="png"></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>所有的操作实际上都将由Execute中的线程完成.</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度任务:</p><ol><li>ElectionTimeout任务.时间超时就会执行相应的逻辑.</li><li>LogReplication任务.定时的发送LogReplication数据包.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务调度&quot;&gt;&lt;a href=&quot;#任务调度&quot; class=&quot;headerlink&quot; title=&quot;任务调度&quot;&gt;&lt;/a&gt;任务调度&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;2.png&quot; alt=&quot;png&quot;&gt;
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之Connector</title>
    <link href="http://yoursite.com/2020/11/13/Raft_RPC_Connector/"/>
    <id>http://yoursite.com/2020/11/13/Raft_RPC_Connector/</id>
    <published>2020-11-13T04:40:15.000Z</published>
    <updated>2021-06-24T12:32:21.505Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="png"></p><h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p><img src="2.png" alt="png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>connector</strong> 是Raft中基础的一部分.每个节点需要和其他节点相互连接.所有的RPC都是通过最终都是要经过Connector中通过节点之间的TCP连接.负责将数据传输</p><p>因为每个节点既可以作为Server . 也可以作为Client. 所以我们需要由 InboundChannelGroup 和 OutboundChannelGroup 分别记录与每个节点的网络连接。</p><ul><li><p><strong>InboundChannelGroup</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;NioChannel&gt; channels = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>OutboundChannelGroup</strong></p><p>OutboundChannelGroup 相对就要复杂一些了。我们将Out 看作Client. 所以我们需要复制connect， 并且记录Channel. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as a client</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundChannelGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(OutboundChannelGroup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeId selfNodeId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeoutMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;NodeId, Future&lt;NioChannel&gt;&gt; channelMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    OutboundChannelGroup(EventLoopGroup workerGroup, EventBus eventBus, NodeId selfNodeId, <span class="keyword">int</span> logReplicationInterval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.workerGroup = workerGroup;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.selfNodeId = selfNodeId;</span><br><span class="line">        <span class="keyword">this</span>.connectTimeoutMillis = logReplicationInterval / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NioChannel <span class="title">connect</span><span class="params">(NodeId nodeId, Address address)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, <span class="title">connectTimeoutMillis</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ToRemoteHandler(eventBus, nodeId, selfNodeId));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.connect(address.getHost(), address.getPort()).sync();</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to connect"</span>, future.cause());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; connected"</span>, nodeId);</span><br><span class="line">        Channel nettyChannel = future.channel();</span><br><span class="line">        nettyChannel.closeFuture().addListener((ChannelFutureListener) cf -&gt; &#123;</span><br><span class="line">            logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; disconnected"</span>, nodeId);</span><br><span class="line">            channelMap.remove(nodeId);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioChannel(nettyChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以我们的Connector 全权负责网络的连接与数据的传输。 具体的逻辑不管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioConnector</span> <span class="keyword">implements</span> <span class="title">Connector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(OutboundChannelGroup<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup bossNioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup workerNioEventLoopGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> workerGroupShared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InboundChannelGroup inboundChannelGroup = <span class="keyword">new</span> InboundChannelGroup();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OutboundChannelGroup outboundChannelGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool((r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">thread  new <span class="title">Thread</span><span class="params">(r)</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioConnector</span><span class="params">(NioEventLoopGroup workerNioEventLoopGroup, <span class="keyword">boolean</span> workerGroupShared,</span></span></span><br><span class="line"><span class="function"><span class="params">                        NodeId selfNodeId, EventBus eventBus,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> port, <span class="keyword">int</span> logReplicationInterval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerNioEventLoopGroup = workerNioEventLoopGroup;</span><br><span class="line">        <span class="keyword">this</span>.workerGroupShared = workerGroupShared;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        outboundChannelGroup = <span class="keyword">new</span> OutboundChannelGroup(workerNioEventLoopGroup, eventBus, selfNodeId, logReplicationInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// should not call more than once</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(bossNioEventLoopGroup, workerNioEventLoopGroup)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> FromRemoteHandler(eventBus, inboundChannelGroup));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        logger.debug(<span class="string">"node listen on port &#123;&#125;"</span>, port);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverBootstrap.bind(port).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectorException(<span class="string">"failed to bind port"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequestVote</span><span class="params">(@Nonnull RequestVoteRpc rpc, @Nonnull Collection&lt;NodeEndpoint&gt; destinationEndpoints)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replyRequestVote</span><span class="params">(@Nonnull RequestVoteResult result, @Nonnull RequestVoteRpcMessage rpcMessage)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="png"></p><p>我通过上图来说明一下我们整个Connector网络数据发送的过程.</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>我们以Outbound为起始. 向指定node发送 一个数据 比如  RequestVoteRPC. </p><p>作为发送端. 我们从Node的Config数据. 获取到所有节点的 address. </p><ol><li>当前节点connect远程的节点. </li><li>当channelActive之后. 当前节点 将该Channel 记录下来.</li><li>当前节点再将当前节点信息通过Channel 发送给远程节点。</li><li>远程节点记录当前节点的信息并且把该channel记录。</li></ol><p>在ToRemoteHandler 和 FromRemoteHandler 中都传入了对应节点的EvetBus， 以便用RPC信息来通知Node执行相应的逻辑。</p><h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p><img src="4.png" alt="png"></p><p>建立连接之后就可以进行对应的数据的传输</p><ol><li>Candidate 发送 -&gt; 调用Connector的SendRequetVoteRPC 到指定的Node ，地址 ID 等配置中有。</li><li>Netty 底层的编码节码粘包拆包等细节处理-&gt; 远程节点收到。</li><li>远程节点判定是RequestVoteRPC， 包装Channel信息包装到RPCMessage中-&gt; event.post 通知订阅方法。onReceiveRequestVoteRpc.</li><li>Node 订阅方法触发 -&gt;处理逻辑.</li><li>逻辑处理完毕之后-&gt; 回复, 将回复信息RequestVoteRPCResult写入刚才 PRCMessage中的Chanel.</li><li>Netty 底层的编码节码粘包拆包等细节处理-&gt; RPC请求发送者收到回复.</li><li>Candidate 判定是RequestVoteRPCResult，  event.post 通知订阅方法。onReceiveRequestVoteResult</li><li>订阅方法触发-&gt;处理逻辑</li></ol><h3 id="RPC类图"><a href="#RPC类图" class="headerlink" title="RPC类图."></a>RPC类图.</h3><p><img src="rpc_uml.png" alt="png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Connector&quot;&gt;&lt;a href=&quot;#Connector&quot; class=&quot;headerlink&quot; title=&quot;Connector&quot;&gt;&lt;/a&gt;Connector&lt;/h2&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之RPC</title>
    <link href="http://yoursite.com/2020/11/11/Raft_PRC_Message/"/>
    <id>http://yoursite.com/2020/11/11/Raft_PRC_Message/</id>
    <published>2020-11-11T08:40:15.000Z</published>
    <updated>2021-06-24T12:32:02.295Z</updated>
    
    <content type="html"><![CDATA[<p>RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想.<br>RPC 最核心要解决的问题就是在分布式系统间，如何执行另外一个地址空间上的函数、方法，就仿佛在本地调用一样<br>RPC 主要需要处理几个核心的问题.1：代理  2.通讯  3：序列化 4：服务实例化</p><p>在我Raft中只有三种RPC请求. 所以我们不通过代理的方式进行</p><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信:"></a>网络通信:</h3><p>Netty 是一个广泛使用的 Java 网络编程框架.隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。</p><p>通过Netty 很容易实现一个高性能的网络通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// connector 初始化 之后就已经在监听了.</span></span><br><span class="line">    ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            .group(bossNioEventLoopGroup, workerNioEventLoopGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> FromRemoteHandler(eventBus, inboundChannelGroup));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    logger.debug(<span class="string">"node listen on port &#123;&#125;"</span>, port);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverBootstrap.bind(port).sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConnectorException(<span class="string">"failed to bind port"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NioChannel <span class="title">connect</span><span class="params">(NodeId nodeId, Address address)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 连接到开启监听的服务器</span></span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(workerGroup)</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, <span class="title">connectTimeoutMillis</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ToRemoteHandler(eventBus, nodeId, selfNodeId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 数据序列化处理都是再Encoder 和 Decoder， Handler 包含了一些逻辑。</span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(address.getHost(), address.getPort()).sync();</span><br><span class="line">    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to connect"</span>, future.cause());</span><br><span class="line">    &#125;</span><br><span class="line">    logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; connected"</span>, nodeId);</span><br><span class="line">    Channel nettyChannel = future.channel();</span><br><span class="line">    nettyChannel.closeFuture().addListener((ChannelFutureListener) cf -&gt; &#123;</span><br><span class="line">        logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; disconnected"</span>, nodeId);</span><br><span class="line">        channelMap.remove(nodeId);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioChannel(nettyChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化:"></a>序列化:</h3><p>Java 的序列化工具有很多.例如(<strong>Protobuf、Thrift、Avro</strong>)查询比较之后我选择了ProtoBuf (主要是资料多!)</p><p>Googel 的 ProtoBuf :protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p><blockquote><p><strong>语言无关、平台无关</strong>。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台</p><p><strong>高效</strong>。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单</p><p><strong>扩展性、兼容性好</strong>。你可以更新数据结构，而不影响和破坏原有的旧程序</p></blockquote><div class="table-container"><table><thead><tr><th>序列化工具</th><th>序列化速度</th><th>序列化文件大小</th><th>编程模型复杂度</th><th>社区活跃度</th><th>jar包大小</th></tr></thead><tbody><tr><td>kryo</td><td>极快</td><td>小</td><td>简单</td><td>高</td><td>132kb</td></tr><tr><td>fst-serializer</td><td>快</td><td>小</td><td>非常简单</td><td>高</td><td>246kb</td></tr><tr><td>protobuffer</td><td>快</td><td>较大</td><td>较复杂</td><td>稳定</td><td>329kb</td></tr><tr><td>fastjson</td><td>较快</td><td>较大</td><td>简单</td><td>一般</td><td>338kb</td></tr><tr><td>jackson</td><td>一般</td><td>较大</td><td>简单</td><td>稳定</td><td>1.1mb</td></tr><tr><td>gson</td><td>较慢</td><td>较大</td><td>简单</td><td>稳定</td><td>189kb</td></tr></tbody></table></div><p><strong>高效</strong>。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单</p><p><strong>扩展性、兼容性好</strong>。你可以更新数据结构，而不影响和破坏原有的旧程序.</p><p> 需要预先创建Message 即 <strong>.proto文件定义数据结构.</strong> </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">option java_package = &quot;org.les&quot;;</span><br><span class="line">option java_outer_classname = &quot;Protos&quot;;</span><br><span class="line">// common</span><br><span class="line">message NodeEndpoint &#123;</span><br><span class="line">    string id = 1;</span><br><span class="line">    string host = 2;</span><br><span class="line">    int32 port = 3;</span><br><span class="line">&#125;</span><br><span class="line">message RequestVoteRpc &#123;</span><br><span class="line">    int32 term = 1;</span><br><span class="line">    string candidate_id = 2;</span><br><span class="line">    int32 last_log_index = 3;</span><br><span class="line">    int32 last_log_term = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protoc 编译</strong> .proto 文件生成读写接口</p><p>在windows如何使用protoc 编译.proto文件<a href="https://leleyi.github.io/2020/10/28/windows protobuf/#more" target="_blank" rel="noopener">简单的windows protobuf .proto文件编译 | FILE (leleyi.github.io)</a> 见该文章.</p><p><strong>调用接口实现序列化、反序列化以及读写</strong></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>在发出 ProtoMsg.Message 消息前，还需要对二进制消息进一步封装。</p><p>需要预先规定好数据的格式。如下： Type + Length + VAR 分别占了4， 4 + len（VAR）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Protos.RequestVoteRpc protoRpc = Protos.RequestVoteRpc.newBuilder()</span><br><span class="line">                    .setTerm(rpc.getTerm())</span><br><span class="line">                    .setCandidateId(rpc.getCandidateId().getValue())</span><br><span class="line">                    .setLastLogIndex(rpc.getLastLogIndex())</span><br><span class="line">                    .setLastLogTerm(rpc.getLastLogTerm())</span><br><span class="line">                    .build();</span><br><span class="line">     <span class="keyword">this</span>.writeMessage(out, MessageConstants.TYPE, protoResult);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ByteBuf out, <span class="keyword">int</span> messageType, MessageLite message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteArrayOutputStream byteOutput = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    message.writeTo(byteOutput);</span><br><span class="line">    out.writeInt(messageType);</span><br><span class="line">    <span class="keyword">this</span>.writeBytes(out, byteOutput.toByteArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ByteBuf out, <span class="keyword">int</span> messageType, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4 + 4 + VAR</span></span><br><span class="line">    out.writeInt(messageType);</span><br><span class="line">    <span class="keyword">this</span>.writeBytes(out, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(ByteBuf out, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    out.writeInt(bytes.length);</span><br><span class="line">    out.writeBytes(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码器-通过先前的-统一规定-对信息进行解码。"><a href="#解码器-通过先前的-统一规定-对信息进行解码。" class="headerlink" title="解码器 通过先前的 统一规定 对信息进行解码。"></a>解码器 通过先前的 统一规定 对信息进行解码。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> availableBytes = in.readableBytes();</span><br><span class="line"><span class="keyword">if</span> (availableBytes &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.markReaderIndex();</span><br><span class="line"><span class="keyword">int</span> messageType = in.readInt();</span><br><span class="line"><span class="keyword">int</span> payloadLength = in.readInt();</span><br><span class="line"><span class="keyword">if</span> (in.readableBytes() &lt; payloadLength) &#123;</span><br><span class="line">    in.resetReaderIndex();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     ByteBuf frame = Unpooled.buffer(length);</span><br><span class="line">     in.readBytes(frame);</span><br><span class="line">    <span class="comment">// 处理数据帧。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty中的Handler 来处理具体的任务逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> remoteId != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> channel != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前收到的消息.</span></span><br><span class="line">    <span class="comment">// 收到请求投票</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RequestVoteRpc) &#123;</span><br><span class="line">        System.out.println(<span class="string">"type requestVote"</span>);</span><br><span class="line">        RequestVoteRpc rpc = (RequestVoteRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> RequestVoteRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到投票结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RequestVoteResult) &#123;</span><br><span class="line">        eventBus.post(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到追加信息</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> AppendEntriesRpc) &#123;</span><br><span class="line">        AppendEntriesRpc rpc = (AppendEntriesRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> AppendEntriesRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到追加信息结果 同样是 heart beart信息.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> AppendEntriesResult) &#123;</span><br><span class="line">        AppendEntriesResult result = (AppendEntriesResult) msg;</span><br><span class="line">        <span class="keyword">if</span> (lastAppendEntriesRpc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"no last append entries rpc"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(result.getRpcMessageId(), lastAppendEntriesRpc.getMessageId())) &#123;</span><br><span class="line">                logger.warn(<span class="string">"incorrect append entries rpc message id &#123;&#125;, expected &#123;&#125;"</span>, result.getRpcMessageId(), lastAppendEntriesRpc.getMessageId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eventBus.post(<span class="keyword">new</span> AppendEntriesResultMessage(result, remoteId, lastAppendEntriesRpc));</span><br><span class="line">                lastAppendEntriesRpc = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> InstallSnapshotRpc) &#123;</span><br><span class="line">        InstallSnapshotRpc rpc = (InstallSnapshotRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> InstallSnapshotRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> InstallSnapshotResult) &#123;</span><br><span class="line">        InstallSnapshotResult result = (InstallSnapshotResult) msg;</span><br><span class="line">        <span class="keyword">assert</span> lastInstallSnapshotRpc != <span class="keyword">null</span>;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> InstallSnapshotResultMessage(result, remoteId, lastInstallSnapshotRpc));</span><br><span class="line">        lastInstallSnapshotRpc = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到收到消息同解码之后.根据消息类型进行对应的程序调用. 这里用到的是观察者的方式.通过事件通知相应订阅者.</p><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p><strong>EventBus</strong> 是一个开源库，它利用发布/订阅者者模式来对项目进行解耦。Publisher（发布者）通过post（）方法，把Event事件发布出去，Subscriber（订阅者）在onEvent（）方法中接收事件.</p><p>上述的post方法主要做了这么几件事：</p><ol><li><p>根据传入的Event获取对应的订阅列表subscribers</p></li><li><p>遍历subscribers</p></li><li><p>如果订阅者是异步的，那么就使用线程池启动执行任务</p></li><li><p>如果是同步的那么就调用handleEvent方法向订阅者发布消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnReceiveRequestVoteRpc</span><span class="params">(RequestVoteRpcMessage rpcMessage)</span> </span>&#123;</span><br><span class="line">    context.taskExecutor().submit(()</span><br><span class="line">            -&gt; context.connector().replyRequestVote(doProcessRequestVoteRpc(rpcMessage), rpcMessage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>例如: RequestVotePRC  调用之后. 通过 Ecoder 编码 - 网络传输 - Dcoder 解码  -&gt; 根据请求类型 进行事件的POST. 而订阅者的订阅方法 触发执行逻辑.</p><p>参考:</p><p><a href="https://www.cnblogs.com/luozhiyun/p/11324181.html" target="_blank" rel="noopener">https://www.cnblogs.com/luozhiyun/p/11324181.html</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/overview</a></p><p><a href="https://www.baeldung.com/netty" target="_blank" rel="noopener">https://www.baeldung.com/netty</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想.&lt;br&gt;RPC 最核心要解决的问题就是在分布式系统间，如何执行另外一个地址空间上的函数、方法，就仿佛在本地调用一样&lt;br&gt;RPC 
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_理论知识</title>
    <link href="http://yoursite.com/2020/11/09/Raft_Base/"/>
    <id>http://yoursite.com/2020/11/09/Raft_Base/</id>
    <published>2020-11-09T08:40:15.000Z</published>
    <updated>2021-04-01T13:19:50.870Z</updated>
    
    <content type="html"><![CDATA[<p>CAP原则又称CAP定理[2000]，指的是在一个分布式系统中，<strong>一致性</strong>（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。<br><strong>一致性：</strong>多个数据副本之间数据能否保持一致。<br><strong>可用性：</strong>读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。<br><strong>分区容错性：</strong>单台服务器，或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务，并且满足设计好的一致性和可用性。</p><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p><p><strong>最终一致性</strong>（Eventually Consistent）：最终一致性是强调系统中所有的数据副本，在经过一段时间的同步之后，最终能够达到一直的状态。即没有保证实时的数据一致。</p><p>Raft算法为了保证高可用，并不是强一致性，而是最终一致性。</p><p><strong>1.分布式一致性算法</strong><br>Paxos<br><strong>Raft</strong>：Raft more understandable than Paxos and also provides a better foundation for building practical systems<br>ZAB</p><h3 id="一、Raft算法概述"><a href="#一、Raft算法概述" class="headerlink" title="一、Raft算法概述"></a>一、Raft算法概述</h3><p><strong>Raft</strong>是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法。</p><p>它将分布式一致性分解为多个子问题：Leader选举（Leader election）、日志复制（Log replication）、安全性（Safety）、日志压缩（Log compaction）等<br><strong>Leader：</strong>接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</p><p><strong>Follower：</strong>接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p><p><strong>Candidate：</strong>Leader选举过程中的临时角色</p><p><img src="1.png" alt="png"></p><p>  可以看出所有节点启动时都是<strong>Follower</strong>状态；在一段时间内如果没有收到来自<strong>leader</strong>的心跳，从Follower切换到candidate，发起选举；如果收到majority的造成票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到Follower。</p><p>Raft 算法将时间划分成为任意不同长度的任期（Term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（<strong>election</strong>），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p><p><strong>Term：</strong></p><p>Term（任期）以选举（Election）开始，然后就是一段或长或短的稳定工作期（normal Operation）</p><p><img src="2.png" alt="png"></p><h3 id="二、Leader选举"><a href="#二、Leader选举" class="headerlink" title="二、Leader选举"></a>二、Leader选举</h3><p>每个节点都会有一个 <strong>ElectionTimeout </strong>计时，如果该节点在该时间内没有收到来自 Leader 或者其他Node 的信息，那么该节点就会发起选举。</p><ul><li>增加节点本地的 current term，切换到candidate状态</li><li>投自己一票</li><li>并行给其他节点发送 <em>RequestVote RPCs</em></li><li><p>等待其他节点的回复</p><p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p></li></ul><ul><li>收到majority的投票（含自己的一票），则赢得选举，成为Leader </li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>一段时间内没有收到majority投票，则保持Candidate状态，重新发出选举。</li></ul><h3 id="三、日志复制（保证数据一致性）"><a href="#三、日志复制（保证数据一致性）" class="headerlink" title="三、日志复制（保证数据一致性）"></a>三、日志复制（保证数据一致性）</h3><blockquote><p>当选Leader 之后 就会调用 AppendEntriesRPC 将发送 no-op Log</p></blockquote><p>客户端收到的请求之后 Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC复制日志条目.</p><ul><li>Leader 追加日志条目</li><li>Leader 发送<em>AppendEntries RPC</em></li><li>Leader 等待多数人回应</li><li>Leader 将条目应用到状态机</li><li>Leader 回复 Client</li><li>Leader 通知 Follower 申请日志</li></ul><p> <strong>日志由有序编号（log index）的日志item组成</strong>。<strong>每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令</strong>。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p><p><img src="3.png" alt="png"></p><p>提交的日志都将通过<strong>状态机</strong>持久化到磁盘中</p><p><strong>日志的一致性</strong></p><p><img src="4.png" alt="png"></p><p>复制时保证数据一致</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的（原因：leader 最多在一个任期里的一个日志索引位置创建一条日志条目，日志条目在日志的位置从来不会改变）。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的（原因：每次 RPC 发送附加日志时，leader 会把这条日志条目的前面的日志的下标和任期号一起发送给 Follower，如果 Follower 发现和自己的日志不匹配，那么就拒绝接受这条日志，这个称之为一致性检查）。</li></ul><p>Leader崩溃导致数据不一致.</p><p><strong>一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生</strong>。丢失的或者多出来的条目可能会持续多个任期。</p><ul><li>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</li><li>具体的操作是：Leader会从后往前试，每次 AppendEntries 失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位置点（基于上述的两条保证），然后向后逐条覆盖Followers在该位置之后的条目。</li></ul><p><strong>Replicated 状态机</strong> </p><p>一致性算法都会涉及到状态机，而状态机保证系统从一个一致的状态开始，以相同的顺序执行一些列指令最终会达到另一个一致的状态。</p><h3 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h3><p><img src="5.png" alt="png"></p><ul><li>拥有<strong>最新的已提交的log entry的Follower才有资格成为leader</strong>。</li><li><strong>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志</strong>，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li></ul><h3 id="五、日志压缩"><a href="#五、日志压缩" class="headerlink" title="五、日志压缩"></a>五、日志压缩</h3><p><img src="6.png" alt="png"></p><p>在实际的系统中，不能让<strong>日志无限增长</strong>，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行<strong>snapshot</strong>来解决，snapshot之前的日志都可以丢弃（以前的数据已经落盘了）。每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p><p>【<strong>Snapshot中包含以下内容</strong>】：</p><ul><li><strong>日志元数据，最后一条已提交的 log entry的 log index和term</strong>。这两个值在snapshot之后的第一条log entry的<em>AppendEntries RPC</em>的完整性检查的时候会被用上。</li><li><strong>系统当前状态</strong>。</li></ul><p>  当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用<em>InstalledSnapshot RPC</em></p><p>  做snapshot既不要做的太频繁，否则<strong>消耗磁盘带宽</strong>， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。<strong>推荐当日志达到某个固定的大小做一次snapshot</strong>。</p><p>  做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h3 id="六、成员变更"><a href="#六、成员变更" class="headerlink" title="六、成员变更"></a>六、成员变更</h3><p><img src="7.png" alt="png"></p><p>我们先将成员变更请求当成普通的写请求，由领导者得到多数节点响应后，每个节点提交成员变更日志，将从旧成员配置（$C<em>{old}$）切换到新成员配置（$C</em>{new}$)。但每个节点提交成员变更日志的时刻可能不同，这将造成各个服务器切换配置的时刻也不同，这就有可能选出两个领导者，破坏安全性。</p><p>考虑以下这种情况：集群配额从 3 台机器变成了 5 台，可能存在这样的一个时间点，两个不同的领导者在同一个任期里都可以被选举成功（双主问题），一个是通过旧的配置，一个通过新的配置。简而言之，成员变更存在的问题是增加或者减少的成员太多了，导致旧成员组和新成员组没有交集，因此出现了双主节点.</p><p><strong>Raft解决方法是每次成员变更只允许增加或删除一个成员（如果要变更多个成员，连续变更多次）</strong>。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC."></a>RPC.</h3><p>在上述 我们有三种 RPC 请求. </p><p>RequestVoteRPC : 候选人发送投票请求.</p><p>AppendEntriesRPC: 日志复制. 包括了 no-op (刚成为Leader). 普通的Entries 如(CURD).成员变更的信息.</p><p>InstallSnapshotRPC: 通过快照给落后的Follower. 或者时刚来的Follower.</p><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/98627822" target="_blank" rel="noopener">RAFT算法详解_青萍之末的博客-CSDN博客_raft算法</a></p><p><a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">Raft Consensus Algorithm</a></p><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm (raft.github.io)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAP原则又称CAP定理[2000]，指的是在一个分布式系统中，&lt;strong&gt;一致性&lt;/strong&gt;（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>linux中v2ray以及proxychains</title>
    <link href="http://yoursite.com/2020/11/09/Tool_v2ray/"/>
    <id>http://yoursite.com/2020/11/09/Tool_v2ray/</id>
    <published>2020-11-09T04:40:15.000Z</published>
    <updated>2021-04-01T13:18:39.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="V2Ray-搭建"><a href="#V2Ray-搭建" class="headerlink" title="V2Ray 搭建"></a>V2Ray 搭建</h3><ul><li><p>安装 wget</p></li><li><p>下载脚本</p><p>安装完 wget 之后就可以进行下载操作了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash go.sh</span><br></pre></td></tr></table></figure></li></ul><pre><code>显示一下信息代表安装成功:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ts@ubuntu v2ray]$ sudo bash go.sh Installing V2Ray v3.14 on x86_64Downloading V2Ray.%Total%Received%XferdAverageSpeedTimeTimeTimeCurrentDloadUploadTotalSpentLeftSpeed10060806080022290--:--:----:--:----:--:--22351008482k1008482k002501k00:00:030:00:03--:--:--2813kExtracting V2Ray package to /tmp/v2ray.Archive:/tmp/v2ray/v2ray.zip   creating:/tmp/v2ray/v2ray-v3.14-linux-64/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/geoip.dat    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/geosite.dat    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/readme.md     creating:/tmp/v2ray/v2ray-v3.14-linux-64/systemd/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/systemd/v2ray.service     creating:/tmp/v2ray/v2ray-v3.14-linux-64/systemv/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/systemv/v2ray    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/v2ctl   extracting:/tmp/v2ray/v2ray-v3.14-linux-64/v2ctl.sig    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/v2ray   extracting:/tmp/v2ray/v2ray-v3.14-linux-64/v2ray.sig    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/vpoint_socks_vmess.json    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/vpoint_vmess_freedom.json  PORT:13437UUID:f500ecf5-e135-49c6-9ce2-78eb490d0aa9Created symlink from/etc/systemd/system/multi-user.target.wants/v2ray.service to /etc/systemd/system/v2ray.service.V2Ray v3.14is installed.</span><br></pre></td></tr></table></figure>好了到这里我们就搭建成功了</code></pre><ul><li><p>如果要更新</p><p>更新 V2Ray 的方法是再次执行安装脚本！再次执行安装脚本！再次执行安装脚本！</p></li></ul><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>在首次安装完成之后，V2Ray 不会自动启动，需要手动运行上述启动命令。</p><p>而在已经运行 V2Ray 的 VPS 上再次执行安装脚本，安装脚本会自动停止 V2Ray 进程，升级 V2Ray 程序，然后自动运行 V2Ray。在升级过程中，配置文件不会被修改。</p><ul><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装完成之后，需要对服务器端、客户端进行配置才能进行使用，配置文件位于 / etc/v2ray/config.json：</p><p>v2ray 支持多种协议，针对不同的协议需要进行不同的配置，下面是各种协议对应的服务端配置：</p><ul><li><p>vmess 协议配置</p><p>按照上面的步骤安装完之后就是类似与下面的配置，如果你想使用 vmess 协议，基本不用修改，就可以使用客户端进行连接。</p><p>查看配置文件 (该配置在后面链接时使用):</p><p>如果你已经有window的可用户端, 可以直接到处config.json</p></li></ul><p><img src="1.png" alt="png"></p><p><img src="2.png" alt="png"></p><p><img src="3.png" alt="png"></p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>注意：有些系统需要开放端口或者关闭防火墙才能连接。停止防火墙请执行:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>重启防火墙:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>查看防火墙状态 not running 表示已关闭:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reloa</span><br></pre></td></tr></table></figure></code></pre><h3 id="ProxyChain-使用"><a href="#ProxyChain-使用" class="headerlink" title="ProxyChain  使用"></a>ProxyChain  使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install proxychains</span><br><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>加上一行你自己的配置端口配置</p><p><img src="4.png" alt="png"></p><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains git clone https://github.com/haad/proxychains.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;V2Ray-搭建&quot;&gt;&lt;a href=&quot;#V2Ray-搭建&quot; class=&quot;headerlink&quot; title=&quot;V2Ray 搭建&quot;&gt;&lt;/a&gt;V2Ray 搭建&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 wget&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载脚本&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的windows protobuf  .proto文件编译</title>
    <link href="http://yoursite.com/2020/10/28/OP_windows%20protobuf/"/>
    <id>http://yoursite.com/2020/10/28/OP_windows protobuf/</id>
    <published>2020-10-28T09:57:15.000Z</published>
    <updated>2021-05-18T02:14:07.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="windows-protobuf-proto文件编译器"><a href="#windows-protobuf-proto文件编译器" class="headerlink" title="windows protobuf  .proto文件编译器"></a>windows protobuf  .proto文件编译器</h3><p><a href="https://repo1.maven.org/maven2/com/google/protobuf/protoc/" target="_blank" rel="noopener">com/google/protobuf/protoc)</a></p><p>选择你对应的编译器版本,这里我选择的是3.6.0版本的</p><p><img src="1.png" alt="png"></p><p>下载protoc-3.6.0-windows-x86_64.exe </p><p>cmd 进入到你的protoc-3.6.0-windows-x86_64.exe文件的目录</p><p>执行 protoc.exe path/to/your/proto/file —java_out=OUTPUT_DIR</p><p><img src="2.png" alt="png"></p><p><img src="3.png" alt="png"></p><p>生成成功.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;windows-protobuf-proto文件编译器&quot;&gt;&lt;a href=&quot;#windows-protobuf-proto文件编译器&quot; class=&quot;headerlink&quot; title=&quot;windows protobuf  .proto文件编译器&quot;&gt;&lt;/a&gt;win
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_理论知识</title>
    <link href="http://yoursite.com/2020/08/22/Raft/"/>
    <id>http://yoursite.com/2020/08/22/Raft/</id>
    <published>2020-08-22T09:40:33.000Z</published>
    <updated>2021-06-24T12:31:31.521Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mr-dai.github.io/raft/" target="_blank" rel="noopener">转载 Raft 总结 - Robert Peng’s Blog (mr-dai.github.io)</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了令进程实现高可用，我们可以对进程进行备份，而实现进程的主从备份有两种方法：</p><ul><li><strong>State Transfer</strong>（状态转移）：主服务器将状态的所有变化都传输给备份服务器</li><li><strong>Replicated State Machine</strong>（备份状态机）：将需要备份的服务器视为一个确定性状态机 —— 主备以相同的状态启动，以相同顺序导入相同的输入，最后它们就会进入相同的状态、给出相同的输出</li></ul><p>其中 Replicated State Machine 是较为常用的主从备份实现方式。常见的 Replicated State Machine 架构如下：</p><p><a href="/img/raft/rsm-architecture.png"><img src="https://mr-dai.github.io/img/raft/rsm-architecture.png" alt></a></p><ol><li>客户端向服务发起请求，执行指定操作</li><li>共识模块将该操作以日志的形式备份到其他备份实例上</li><li>当日志安全备份后，指定操作被应用于上层状态机</li><li>服务返回操作结果至客户端</li></ol><p>由此，我们很容易得出结论：在 Replicated State Machine 中，分布式共识算法的职责就是<strong>按照固定的顺序将指定的日志内容备份到集群的其他实例上</strong>。包括我们在<a href="/primary-backup-replication/">上一篇论文阅读</a>中提到的 VMWare FT 协议、广为人知的 Paxos 协议以及这次我们即将学习的 Raft 协议，它们完成的工作都是如此。</p><p>在 Raft 协议出现（2014 年）之前，Paxos 协议几乎成了分布式共识算法的唯一标准：有着大量以 Paxos 为基础开发的正在实际使用中的分布式共识算法，也有着大量与 Paxos 相关的文献，MIT 6.824 也是直到 2016 年才从 Paxos 改为教学 Raft。即便如此，Paxos 算法的名声也不算好，它的复杂程度广为人知。为此，斯坦福大学的研究人员研究了很多方法来简化 Paxos，最终主要通过问题拆分、状态空间降维等方式完成了简化，由此诞生出 Raft 算法。</p><p>好了，说了这么多，我们就来看看 Raft 到底有多简单吧。</p><h2 id="Raft-性质与集群交互"><a href="#Raft-性质与集群交互" class="headerlink" title="Raft 性质与集群交互"></a>Raft 性质与集群交互</h2><p>在行文上，Raft 的论文首先在图 2 和图 3 中给出了 Raft 算法组成的简单描述以及 Raft 所能为系统提供的性质。首先我们先来说说 Raft 所提供的性质：</p><ul><li>Election Safety（选举安全）：在任意给定的 Term 中，至多一个节点会被选举为 Leader</li><li>Leader Append-Only（Leader 只追加）：Leader 绝不会覆写或删除其所记录的日志，只会追加日志</li><li>Log Matching（日志匹配）：若两份日志在给定 Term 及给定 index 值处有相同的记录，那么两份日志在该位置及之前的所有内容完全一致</li><li>Leader Completeness（Leader 完整性）：若给定日志记录在某一个 Term 中已经被提交（后续会解释何为 “提交”），那么后续所有 Term 的 Leader 都将包含该日志记录</li><li>State Machine Safety（状态机安全性）：如果一个服务器在给定 index 值处将某个日志记录应用于其上层状态机，那么其他服务器在该 index 值处都只会应用相同的日志记录</li></ul><p>一个 Raft 集群由若干个节点组成。节点可能处于以下三种角色的其中之一：Leader、Follower 或 Candidate，职责分别如下：</p><ul><li>Leader 负责从客户端处接收新的日志记录，备份到其他服务器上，并在日志安全备份后通知其他服务器将该日志记录应用到位于其上层的状态机上</li><li>Follower 总是处于被动状态，接收来自 Leader 和 Candidate 的请求，而自身不会发出任何请求</li><li>Candidate 会在 Leader 选举时负责投票选出 Leader</li></ul><p>在采用 Leader-Follower 架构的语境下，Raft 将其需要解决的共识问题拆分为了以下 3 个问题：</p><ul><li>Leader 选举：已有 Leader 失效后需要选举出一个新的 Leader</li><li>日志备份：Leader 从客户端处接收日志记录，备份到其他服务器上</li><li>安全性：如果某个服务器为其上层状态机应用了某个日志记录，那么其他服务器在该 index 值处则不能应用其他不同的日志记录</li></ul><p>Raft 算法在运行时会把时间分为任意长度的 Term，如文中图 5 所示：</p><p><a href="/img/raft/term.png"><img src="https://mr-dai.github.io/img/raft/term.png" alt></a></p><p>每个 Term 的开头都会包含一次 Leader 选举，在选举中胜出的节点会担当该 Term 的 Leader。</p><p>Term 由单调递增的 Term ID 所标识，每个节点都会在内存中保存当前 Term 的 ID。每次节点间发生通信时，它们都会发出自己所保存的 Term ID；当节点从其他节点处接收到比自己保存的 Term ID 更大的 Term ID 值时，它便会更新自己的 Term ID 并进入 Follower 状态。在 Raft 中，节点间通信由 RPC 实现，主要有 RequestVote 和 AppendEntries 两个 RPC API，其中前者由处于选举阶段的 Candidate 发出，而后者由 Leader 发出。</p><p>整个集群在运行时会持有如下状态信息：</p><blockquote><p>所有节点都会持有的持久化状态信息（在响应 RPC 前会先将更新写入到持久存储）：</p><ul><li><code>currentTerm</code>：当前 Term ID（初值为 <code>0</code>）</li><li><code>votedFor</code>: 该 Term 中已接收到来自该节点的选票的 Candidate ID</li><li><code>log[]</code>: 日志记录。第一个日志记录的 index 值为 <code>1</code></li></ul><p>所有节点都会持有的易失性状态信息：</p><ul><li><code>commitIndex</code>: 最后一个已提交日志记录的 index（初值为 <code>0</code>）</li><li><code>lastApplied</code>: 最后一个已应用至上层状态机的日志记录的 index（初值为 <code>0</code>）</li></ul><p>Leader 才会持有的易失性状态信息（会在每次选举完成后初始化）：</p><ul><li><code>nextIndex[]</code>: 每个节点即将为其发送的下一个日志记录的 index（初值均为 Leader 最新日志记录 index 值 + 1）</li><li><code>matchIndex[]</code>: 每个节点上已备份的最后一条日志记录的 index（初值均为 <code>0</code>）</li></ul></blockquote><p>在 Raft 集群中，节点间的交互主要由两种 RPC 调用构成。</p><p>首先是用于日志备份的 AppendEntries：</p><blockquote><p>AppendEntries RPC：由 Leader 进行调用，用于将日志记录备份至 Follower，同时还会被用来作为心跳信息</p><p>参数：</p><ul><li><code>term</code>: Leader 的 Term ID</li><li><code>leaderId</code>: Leader 的 ID</li><li><code>prevLogIndex</code>: 在正在备份的日志记录之前的日志记录的 index 值</li><li><code>prevLogTerm</code>: 在正在备份的日志记录之前的日志记录的 Term ID</li><li><code>entries[]</code>: 正在备份的日志记录</li><li><code>leaderCommmit</code>: Leader 已经提交的最后一条日志记录的 index 值</li></ul><p>返回值：</p><ul><li><code>term</code>: 接收方的当前 Term ID</li><li><code>success</code>: 当 Follower 能够在自己的日志中找到 index 值和 Term ID 与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 相同的记录时为 <code>true</code></li></ul><p>接收方在接收到该 RPC 后会进行以下操作：</p><ol><li>若 <code>term &lt; currentTerm</code>，返回 <code>false</code></li><li>若日志中不包含 index 值和 Term ID 与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 相同的记录，返回 <code>false</code></li><li>如果日志中存在与正在备份的日志记录相冲突的记录（有相同的 index 值但 Term ID 不同），删除该记录以及之后的所有记录</li><li>在保存的日志后追加新的日志记录</li><li>若 <code>leaderCommit &gt; commitIndex</code>，令 <code>commitIndex</code> 等于 <code>leaderCommit</code> 和最后一个新日志记录的 index 值之间的最小值</li></ol></blockquote><p>而后是用于 Leader 选举的 RequestVote：</p><blockquote><p>RequestVote RPC：由 Candidate 调起以拉取选票</p><p>参数：</p><ul><li><code>term</code>：Candidate 的 Term ID</li><li><code>candidateId</code>: Candidate 的 ID</li><li><code>lastLogIndex</code>: Candidate 所持有的最后一条日志记录的 index</li><li><code>lastLogTerm</code>: Candidate 所持有的最后一条日志记录的 Term ID</li></ul><p>返回值：</p><ul><li><code>term</code>：接收方的 Term ID</li><li><code>voteGranted</code>：接收方是否同意给出选票</li></ul><p>接收方在接收到该 RPC 后会进行以下操作：</p><ol><li>若 <code>term &lt; currentTerm</code>，返回 <code>false</code></li><li>若 <code>votedFor == null</code> 且给定的日志记录信息可得出对方的日志和自己的相同甚至更新，返回 <code>true</code></li></ol></blockquote><p>最后，Raft 集群的节点还需要遵循以下规则：</p><blockquote><p>对于所有节点：</p><ul><li>若 <code>commitIndex &gt; lastApplied</code>，则对 <code>lastApplied</code> 加 1，并将 <code>log[lastApplied]</code> 应用至上层状态机</li><li>若 RPC 请求或相应内容中携带的 <code>term &gt; currentTerm</code>，则令 <code>currentTerm = term</code>，且 Leader 降级为 Follower</li></ul><p>对于 Follower：</p><ul><li>负责响应 Candidate 和 Leader 的 RPC</li><li>如果在 Election Timeout 之前没能收到来自当前 Leader 的 AppendEntries RPC 或将选票投给其他 Candidate，则进入 Candidate 角色</li></ul><p>对于 Candidate：</p><ul><li>在进入 Candidate 角色时，发起 Leader 选举：<ol><li><code>currentTerm</code> 加 1</li><li>将选票投给自己</li><li>重置 Election Timeout 计时器</li><li>发送 RequestVote RPC 至其他所有节点</li></ol></li><li>如果接收到来自其他大多数节点的选票，则进入 Leader 角色</li><li>若接收到来自其他 Leader 的 AppendEntries RPC，则进入 Follower 角色</li><li>若再次 Election Timeout，那么重新发起选举</li></ul><p>对于 Leader：</p><ul><li>在空闲时周期地向 Follower 发起空白的 AppendEntries RPC（作为心跳信息），以避免 Follower 发起选举</li><li>若从客户端处接收到新的命令，则将该命令追加到所存储的日志中，并在顺利将该命令应用至上层状态机后返回响应</li><li>如果最新一条日志记录的 index 值大于等于某个 Follower 的 <code>nextIndex</code> 值，则通过 AppendEntries RPC 发送在该 <code>nextIndex</code> 值之后的所有日志记录：<ol><li>如果备份成功，那么就更新该 Follower 对应的 <code>nextIndex</code> 和 <code>matchIndex</code> 值</li><li>否则，对 <code>nextIndex</code> 减 1 并重试</li></ol></li><li>如果存在一个值 <code>N</code>，使得 <code>N &gt; commitIndex</code>，且大多数的 <code>matchIndex[i] &gt;= N</code>，且 <code>log[N].term == currentTerm</code>，令 <code>commitIndex = N</code></li></ul></blockquote><p>接下来我们将分章节介绍 Raft 的主要实现以及各种约束的主要考虑。</p><h2 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h2><p>在初次启动时，节点首先会进入 Follower 角色。只要它能够一直接收到来自其他 Leader 节点发来的 RPC 请求，它就会一直处于 Follower 状态。如果接收不到来自 Leader 的通信，Follower 会等待一个称为 Election Timeout（选举超时）的超时时间，然后便会开始发起新一轮选举。</p><p>Follower 发起选举时会对自己存储的 Term ID 进行自增，并进入 Candidate 状态。随后，它会将自己的一票投给自己，并向其他节点并行地发出 RequestVote RPC 请求。其他节点在接收到该类 RPC 请求时，会以先到先得的原则投出自己在该 Term 中的一票。</p><p>当 Candidate 在某个 Term 接收到来自集群中大多数节点发来的投票时，它便会成为 Leader，然后它便会向其他节点进行通信，确保其他节点知悉它是 Leader 而不会发起又一轮投票。每个节点在指定 Term 内只会投出一票，而只有接收到大多数节点发来的投票才能成为 Leader 的性质确保了在任意 Term 内都至多会有一个 Leader。由此我们实现了前面提及的 Eleaction Safety 性质。</p><p>Candidate 在投票过程中也有可能收到来自其他 Leader 的 AppendEntries RPC 调用，这意味着有其他节点成为了该 Term 的 Leader。如果该 RPC 中携带的 Term ID 大于等于 Candidate 当前保存的 Term ID，那么 Candidate 便会认可其为 Leader，并进入 Follower 状态，否则它会拒绝该 RPC 并继续保持其 Candidate 身份。</p><p>除了上述两种情况以外，选举也有可能发生平局的情况：若干节点在短时间内同时发起选举，导致集群中没有任何一个节点能够收到来自集群大多数节点的投票。此时，节点同样会在等待 Election Timeout 后发起新一轮的选举，但如果不加入额外的应对机制，这样的情况有可能持续发生。为此，Raft 为 Election Timeout 的取值引入了随机机制：节点在进入新的 Term 时，会在一个固定的区间内（如 150~300ms）随机选取自己在该 Term 所使用的 Election Timeout。通过随机化来错开各个节点进入 Candidate 状态的时机便能有效避免这种情况的重复发生。</p><h2 id="日志备份"><a href="#日志备份" class="headerlink" title="日志备份"></a>日志备份</h2><p>在选举出一个 Leader 后，Leader 便能够开始响应来自客户端的请求了。客户端请求由需要状态机执行的命令所组成：Leader 会将接收到的命令以日志记录的形式追加到自己的记录里，并通过 AppendEntries RPC 备份到其他节点上；当日志记录被安全备份后，Leader 就会将该命令应用于位于自己上层的状态机，并向客户端返回响应；无论 Leader 已响应客户端与否，Leader 都会不断重试 AppendEntries RPC 调用，直到所有节点都持有该日志记录的备份。</p><p>日志由若干日志记录组成：每条记录中都包含一个需要在状态机上执行的命令，以及其对应的 index 值；除外，日志记录还会记录自己所属的 Term ID。</p><p><a href="/img/raft/log-entries.png"><img src="https://mr-dai.github.io/img/raft/log-entries.png" alt></a></p><p>当某个日志记录顺利备份到集群大多数节点上后，Leader 便会认为该日志记录 “已提交”（Committed），即该日志记录已可被安全的应用到上层状态机上。Raft 保证一个日志记录一旦被提交，那么它最终就会被所有仍可用的状态机所应用。除外，一条日志记录的提交也意味着位于其之前的所有日志记录也进入“已提交” 状态。Leader 会保存其已知的最新的已提交日志的 index 值，并在每次进行 AppendEntries RPC 调用时附带该信息；Follower 在接收到该信息后即可将对应的日志记录应用在位于其上层的状态机上。</p><p>在运行时，Raft 能为系统提供如下两点性质，这两点性质共同构成了论文图 3 中提到的 Log Matching 性质：</p><ul><li>对于两份日志中给定的 index 处，如果该处两个日志记录的 Term ID 相同，那么它们存储的状态机命令相同</li><li>如果两份日志中给定 index 处的日志记录有相同的 Term ID 值，那么位于它们之前的日志记录完全相同</li></ul><p>第一条性质很容易得出，考虑到 Leader 在一个 Term 中只会在一个 index 处创建一条日志记录，而且日志的位置不会发生改变。为了提供上述第二个性质，Leader 在进行 AppendEntries RPC 调用时会同时携带在其自身的日志存储中位于该新日志记录之前的日志记录的 index 值及 Term ID；如果 Follower 在自己的日志存储中没有找到这条日志记录，那么 Follower 就会拒绝这条新记录。由此，每一次 AppendEntries RPC 调用的成功返回都意味着 Leader 可以确定该 Follower 存储的日志直到该 index 处均与自己所存储的日志相同。</p><p>AppendEntries RPC 的日志一致性检查是必要的，因为 Leader 的崩溃会导致新 Leader 存储的日志可能和 Follower 不一致。</p><p><a href="/img/raft/inconsistent-logs.png"><img src="https://mr-dai.github.io/img/raft/inconsistent-logs.png" alt></a></p><p>考虑上图（即文中的图 7），对于给定的 Leader 日志，Follower 有可能缺失部分日志（a、b 情形）、有可能包含某些未提交的日志（c、d 情形）、或是两种情况同时发生（e、f 情形）。</p><p>对于不一致的 Follower 日志，Raft 会强制要求 Follower 与 Leader 的日志保持一致。为此，Leader 会尝试确定它与各个 Follower 所能相互统一的最后一条日志记录的 index 值，然后就会将 Follower 在该 index 之后的所有日志删除，再将自身存储的日志记录备份到 Follower 上。具体而言：</p><ol><li>Leader 会为每个 Follower 维持一个 <code>nextIndex</code> 变量，代表 Leader 即将通过 AppendEntries RPC 调用发往该 Follower 的日志的 index 值</li><li>在刚刚被选举为一个 Leader 时，Leader 会将每个 Follower 的 <code>nextIndex</code> 置为其所保存的最新日志记录的 index 之后</li><li>当有 Follower 的日志与 Leader 不一致时，Leader 的 AppendEntries RPC 调用会失败，Leader 便对该 Follower 的 <code>nextIndex</code> 值减 1 并重试，直到 AppendEntries 成功</li><li>Follower 接收到合法的 AppendEntries 后，便会移除其在该位置上及以后存储的日志记录，并追加上新的日志记录</li><li>如此，在 AppendEntries 调用成功后，Follower 便会在该 Term 接下来的时间里与 Leader 保持一致</li></ol><p>由此，我们实现了前面提及的 Leader Append-Only 和 Log Matching 性质。</p><h3 id="Leader-选举约束"><a href="#Leader-选举约束" class="headerlink" title="Leader 选举约束"></a>Leader 选举约束</h3><p>就上述所提及的 Leader 选举及日志备份规则，实际上是不足以确保所有状态机都能按照相同的顺序执行相同的命令的。例如，在集群运行的过程中，某个 Follower 可能会失效，而 Leader 继续在集群中提交日志记录；当这个 Follower 恢复后，有可能会被选举为 Leader，而它实际上缺少了一些已经提交的日志记录。</p><p>其他的基于 Leader 架构的共识算法都会保证 Leader 最终会持有所有已提交的日志记录。一些算法（如 Viewstamped Replication）允许节点在不持有所有已提交日志记录的情况下被选举为 Leader，并通过其他机制将缺失的日志记录发送至新 Leader。而这种机制实际上会为算法引入额外的复杂度。为了简化算法，Raft 限制了日志记录只会从 Leader 流向 Follower，同时 Leader 绝不会覆写它所保存的日志。</p><p>在这样的前提下，要提供相同的保证，Raft 就需要限制哪些 Candidate 可以成为 Leader。前面提到，Candidate 为了成为 Leader 需要获得集群内大多数节点的选票，而一个日志记录被提交同样要求它已经被备份到集群内的大多数节点上，那么如果一个 Candidate 能够成为 Leader，投票给它的节点中必然存在节点保存有所有已提交的日志记录。Candidate 在发送 RequestVote RPC 调用进行拉票时，它还会附带上自己的日志中最后一条记录的 index 值和 Term ID 值：其他节点在接收到后会与自己的日志进行比较，如果发现对方的日志落后于自己的日志（首先由 Term ID 决定大小，在 Term ID 相同时由 index 决定大小），就会拒绝这次 RPC 调用。如此一来，Raft 就能确保被选举为 Leader 的节点必然包含所有已经提交的日志。</p><h3 id="来自旧-Term-的日志记录"><a href="#来自旧-Term-的日志记录" class="headerlink" title="来自旧 Term 的日志记录"></a>来自旧 Term 的日志记录</h3><p>如上文所述，Leader 在备份当前 Term 的日志记录时，在成功备份至集群大多数节点上后 Leader 即可认为该日志记录已提交。但如果 Leader 在日志记录备份至大多数节点之前就崩溃了，后续的 Leader 会尝试继续备份该日志。然而，此时的 Leader 即使在将该日志备份至大多数节点上后都无法立刻得出该日志已提交的结论。</p><p><a href="/img/raft/old-entries.png"><img src="https://mr-dai.github.io/img/raft/old-entries.png" alt></a></p><p>考虑上图这种情形。在时间点 (a) 时，S1 是 Leader，并把 <code>(TermID=2, index=2)</code> 的日志记录备份到了 S2 上。到了时间点 (b) 时，S1 崩溃，S5 收到 S3、S4、S5 的选票，被选为 Leader，并从客户端处接收到日志记录 <code>(TermID=3, index=2)</code>。在时间点 (c) 时，S5 崩溃，S1 重启，被选举为 Leader，并继续将先前没有备份的日志记录 <code>(TermID=2, index=2)</code> 备份到其他节点上。即便此时 S1 顺利把该日志记录备份到集群大多数节点上，它仍然不能认为该日志记录已被安全提交。考虑此时 S1 崩溃，S5 将可以收到来自 S2、S3、S4、S5 的选票，成为 Leader（其最后一个日志记录的 Term ID 是 3，大于 2），进入情形 (d)：此时 S5 会继续把日志记录 <code>(TermID=3, index=2)</code> 备份到其他节点上，覆盖掉原本已经备份至大多数节点的日志记录 <code>(TermID=2, index=2)</code>。然而，如果在时间点 (c) S1 成为 Leader 后，同样将当前 Term 的最新日志记录 <code>(TermID=4, index=3)</code> 备份出去并提交，就会进入情形 (e)，此时 S5 便无法再被选举为 Leader。因此，解决该问题的关键在于在备份旧 Term 的日志时也要把当前 Term 最新的日志一并分发出去。</p><p>由此，Raft 只会在备份当前 Term 的日志记录时才会通过计数的方式来判断该日志记录是否已被提交；一旦该日志记录完成提交，根据前面提及的 Log Matching 性质，Leader 就能得出之前的日志记录也已被提交。由此，我们便实现了前面提及的 Leader Completeness 性质。文中 5.4.3 节有完整的证明过程，感兴趣的读者可自行查阅。</p><p>证得前面 4 条性质后，最后一条 State Machine Safety 性质也可证得：当节点将日志记录应用于其上层状态机时，该日志记录及其之前的所有日志记录必然已经提交。某些节点执行命令的进度可能落后，我们考虑所有节点目前已执行日志记录的 index 值的最小值：Log Completeness 性质保证了未来的所有 Leader 都会持有该日志记录，因此在之后的 Term 中其他节点应用位于该 index 处的日志记录时，该日志记录保存的必然是相同的命令。由此，上层状态机只要按照 Raft 日志记录的 index 值顺序执行命令即可安全完成状态备份。</p><h3 id="时序要求"><a href="#时序要求" class="headerlink" title="时序要求"></a>时序要求</h3><p>为了提供合理的可用性，集群仍需满足一定的时序要求，具体如下：</p><p>broadcastTime≪electionTimeout≪MTBF</p><script type="math/tex; mode=display">broadcastTime≪electionTimeout≪MTBF</script><p>其中 broadcastTime$broadcastTime$ 即一个节点并发地发送 RPC 请求至集群中其他节点并接收请求的平均耗时；electionTimeout$electionTimeout$ 即节点的选举超时时间；MTBF$MTBF$ 即单个节点每次失效的平均间隔时间（Mean Time Between Failures）。</p><p>上述的不等式要求，broadcastTime$broadcastTime$ 要小于 electionTimeout$electionTimeout$ 一个数量级，以确保正常 Leader 心跳间隔不会导致 Follower 超时并发起选举；同时考虑到 electionTimeout$electionTimeout$ 会随机选出，该不等式还能确保 Leader 选举时平局局面不会频繁出现。除外，electionTimeout$electionTimeout$ 也应比 MTBF$MTBF$ 小几个数量级，考虑到系统会在 Leader 失效时停止服务，而这样的情况不应当频繁出现。</p><p>在这个不等式中，broadcastTime$broadcastTime$ 及 MTBF$MTBF$ 由集群架构所决定，electionTimeout$electionTimeout$ 则可由运维人员自行配置。</p><h2 id="Candidate-与-Follower-失效"><a href="#Candidate-与-Follower-失效" class="headerlink" title="Candidate 与 Follower 失效"></a>Candidate 与 Follower 失效</h2><p>目前来讲我们讨论都是 Leader 失效的问题。对于 Candidate 和 Follower 而言，它们分别是 RequestVote 和 AppendEntries RPC 调用的接收方：当 Candidate 或 Follower 崩溃后，RPC 调用会失败；Raft RPC 失败时会不断重试 RPC，直至 RPC 成功；除外，RPC 调用也有可能已经生效，但接收方在响应前就已失效，为此 Raft 保证 RPC 的幂等性，在节点重启后收到重复的 RPC 调用也不会有所影响。</p><h2 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h2><p>直到目前为止，我们的讨论都假设集群的成员配置是一成不变的，然而这在系统的正常运维中是不常见的：系统总是可能需要做出变更，例如移除一些节点或增加一些节点。</p><p>当然，集群可以被全部关闭后，调整配置文件，再全部重启，这样也能完成集群配置变更，但这样会导致系统出现一段时间的不可用。而 Raft 则引入了额外的机制来允许集群在运行中变更自己的成员配置。</p><p>在进行配置变更时，直接从旧配置切换至新配置是不可行的，源于不同的节点不可能原子地完成配置切换，而这之间可能会有一些时间间隙使得集群存在两个不同的 “大多数”。</p><p><a href="/img/raft/configuration-change.png"><img src="https://mr-dai.github.io/img/raft/configuration-change.png" alt></a></p><p>如上图所示，集群逐渐地从旧配置切换至新配置，那么在箭头标记的位置就出现了两个不同的 “大多数”：S1、S2 构成 Cold$Cold$ 的大多数，S3、S4、S5 构成 Cnew$Cnew$ 的大多数。在这一时间间隔内，处于两个配置的节点可能会选出各自的 Leader，引入 Split-Brain 问题。问题的关键在于，在这段时间间隔中，Cold$Cold$ 和 Cnew$Cnew$ 都能够独立地做出决定。</p><p>为了解决这个问题，Raft 采用二阶段的方式来完成配置切换：在 Cold$Cold$ 与 Cnew$Cnew$ 之间，引入一个被称为 Joint Consensus 的特殊配置 Cold,new$Cold,new$ 作为迁移状态。该配置有如下性质：</p><ul><li>日志记录会被备份到 Cold$Cold$ 及 Cnew$Cnew$ 的节点上</li><li>两份配置中的任意机器都能成为 Leader</li><li>选举或提交日志记录要求得到来自 Cold$Cold$ 和 Cnew$Cnew$ 的两个不同的 “大多数” 的同意</li></ul><p><a href="/img/raft/configuration-change-sequence.png"><img src="https://mr-dai.github.io/img/raft/configuration-change-sequence.png" alt></a></p><p>上图显示了配置切换的时序，其中可以看到不存在 Cold$Cold$ 和 Cnew$Cnew$ 都能独立作出决定的时间段。</p><p>切换时，Leader 会创建特殊的配置切换日志，并利用先前提到的日志备份机制通知其他节点进行配置切换。对于这种特殊的配置切换日志，节点在接收到时就会立刻切换配置，不会等待日志提交，因此 Leader 会首先进入 Cold,new$Cold,new$ 配置，同时运用这份配置来判断配置切换的日志是否成功提交。如此，如果 Leader 在完成提交这份日志之前崩溃，新的 Leader 只会处于 Cold$Cold$ 或 Cold,new$Cold,new$ 配置，如此一来在该日志记录完成提交前，Cnew$Cnew$ 便无法独立做出决定。</p><p>在 Cold,new$Cold,new$ 的配置变更日志完成提交后，Cold$Cold$ 便也不能独立做出决定了，且 Leader Completeness 性质保证了此时选举出的 Leader 必然处于 Cold,new$Cold,new$ 配置。此时，Leader 就能开始重复上述过程，切换到 Cnew$Cnew$ 配置。在 Cnew$Cnew$ 配置日志完成提交后，这个过程中被移出集群的节点就能顺利关闭了。</p><p>除此以外，我们仍有三个问题需要去解决。</p><p>首先，配置变更可能会引入新的节点，这些节点不包含之前的日志记录，完成日志备份可能会需要较长的时间，而这段时间可能导致集群无法提交日志，引入一段时间的服务不可用。为此，Raft 在节点变更配置之前还引入了一个额外的阶段：此时节点会以不投票成员的形式加入集群，开始备份日志，Leader 在计算 “大多数” 时也不会考虑它们；等到它们完成备份后，它们就能回到正常状态，完成配置切换。</p><p>此外，集群的 Leader 有可能不属于 Cnew$Cnew$。在这种情况下，Leader 在完成 Cnew$Cnew$ 的配置变更日志提交后才能变更自己的配置并关闭。也就是说，在 Leader 提交 Cnew$Cnew$ 的日志时，那段时间里它会需要管理一个不包含自己的集群：它会把日志记录备份出去，但不会把自己算入 “大多数”。直到 Cnew$Cnew$ 日志完成提交，Cnew$Cnew$ 才能够独立做出决定，才能够在原 Leader 降级后在 Cnew$Cnew$ 集群中选出新的 Leader；在那之前，来自 Cold$Cold$ 的节点有可能被选为 Leader。</p><p>最后，那些从集群中被移除出去的节点可能会在配置切换完成后干扰新集群的运行。这些节点不会再接收到 Leader 的心跳，于是它们就会超时并发起选举。这时它们会发起 RequestVote RPC 调用，其中包含新的 Term ID，而这可能导致新的 Leader 自动降级为 Follower，导致服务不可用。最终新集群会选出一个新的 Leader，但被移除的节点依旧不会接收到心跳信息，它们会再次超时，再次发起选举，如此循环往复。</p><p>为解决此问题，节点在其 “确信” Leader 仍存活时会拒绝 RequestVote RPC 调用：如果距离节点上一次接收到 Leader 心跳信息过去的时间小于 Election Timeout 的最小值，那么节点便会 “确信” Leader 仍然存活。考虑前面提到的时序要求，这确实能够在大多数情况下避免该问题。</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>随着 Raft 集群的不断运行，节点上的日志体积会不断增大，这会逐渐占用节点的磁盘资源，此外过长的日志也会延长节点重放日志的耗时，引入服务可用性问题。为此，集群需要对过往的日志进行压缩。</p><p>快照是进行日志压缩最简便的方案。在进行快照时，状态机当前的完整状态会被写入到持久存储中，而后就能够安全地把直到该时间点以前的日志记录移除了。完成快照后，Raft 也会在快照中记录其所覆盖到的最新日志记录的 index 和 Term ID，以便后面的日志记录能够被继续追加。为了兼容前面提到的集群成员配置变更，快照同样需要记录下当前的集群成员配置。</p><p><a href="/img/raft/log-compaction.png"><img src="https://mr-dai.github.io/img/raft/log-compaction.png" alt></a></p><p>对于 Raft 来说，每个节点会独立地生成快照。相比起只由 Leader 生成快照，这样的设计避免了 Leader 频繁向其他 Follower 传输快照而占用网络带宽，况且 Follower 也持有着足以独立生成快照的数据。</p><p>尽管如此，当某个 Follower 落后太多或是集群加入了新节点时，Leader 仍然会需要将自己持有的快照传输给 Follower。为此，Raft 提供了专门的 InstallSnapshot RPC 接口。</p><blockquote><p>InstallSnapshot RPC: 由 Leader 进行调用，用于将组成快照的文件块发给指定 Follower。Leader 总会按照顺序发送文件块。</p><p>参数：</p><ul><li><code>term</code>: Leader 当前的 Term ID</li><li><code>leaderId</code>: Leader 的 ID</li><li><code>lastIncludedIndex</code>: 该快照所覆盖的最后一个日志记录的 index 值</li><li><code>lastIncludedTerm</code>: 该快照所覆盖的最后一个日志记录的 Term ID</li><li><code>offset</code>: 当前发送的文件块在整个快照文件中的偏移值</li><li><code>data[]</code>: 文件块的内容</li><li><code>done</code>: 该文件块是否为最后一个文件块 返回值：</li><li><code>term</code>: Follower 的当前 Term ID。Leader 可根据该值判断是否要降级为 Follower。</li></ul><p>Follower 在接收到该 RPC 调用后会进行以下操作：</p><ol><li>若 <code>term &lt; currentTerm</code>，return</li><li>若 <code>offset == 0</code>，创建快照文件</li><li>在快照文件的指定 <code>offset</code> 处写入 <code>data[]</code></li><li>若 <code>done == false</code>，返回响应，并继续等待其他文件块</li><li>移除已有的或正在生成的在该快照之前的快照</li><li>如果有一个日志记录的 Term ID 及 index 值与该快照所包含的最后一个日志记录相同，那么便保留该日志记录之后的日志记录，并返回响应</li><li>移除被该快照覆盖的所有日志记录</li><li>使用该快照的内容重置上层状态机，并载入快照所携带的集群成员配置</li></ol></blockquote><h2 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h2><p>最后，我们再来聊聊客户端如何与 Raft 集群进行交互。</p><p>首先，客户端需要能够得知目前 Raft 集群的 Leader 是谁。在一开始，客户端会与集群中任意的一个节点进行通信：如果该节点不是 Leader，那么它会把上一次接收到的 AppendEntries RPC 调用中携带的 Leader ID 返回给客户端；如果客户端无法连接至该节点，那么客户端就会再次随机选取一个节点进行重试。</p><p>Raft 的目标之一是为上层状态机提供日志记录的 exactly-once 语义，但如果 Leader 在完成日志提交后、向客户端返回响应之前崩溃，客户端就会重试发送该日志记录。为此，客户端需要为自己的每一次通信赋予独有的序列号，而上层状态机则需要为每个客户端记录其上一次通信所携带的序列号以及对应的响应内容，如此一来当收到重复的调用时状态机便可在不执行该命令的情况下返回响应。</p><p>对于客户端的只读请求，Raft 集群可以在不对日志进行任何写入的情况下返回响应。然而，这有可能让客户端读取到过时的数据，源于当前与客户端通信的 “Leader” 可能已经不是集群的实际 Leader，而它自己并不知情。</p><p>为了解决此问题，Raft 必须提供两个保证。首先，Leader 持有关于哪个日志记录已经成功提交的最新信息。基于前面提到的 Leader Completeness 性质，节点在成为 Leader 后会立刻添加一个空白的 no-op 日志记录；此外，Leader 还需要知道自己是否已经需要降级，为此 Leader 在处理只读请求前需要先与集群大多数节点完成心跳通信，以确保自己仍是集群的实际 Leader。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mr-dai.github.io/raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载 Raft 总结 - Robert Peng’s Blog (mr-dai.github.io)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Authorisation not recognised</title>
    <link href="http://yoursite.com/2020/08/20/Authorisation/"/>
    <id>http://yoursite.com/2020/08/20/Authorisation/</id>
    <published>2020-08-20T13:44:15.000Z</published>
    <updated>2021-06-06T13:00:16.898Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://kerneltalks.com/troubleshooting/mobaxterm-x11-proxy-authorisation-not-recognised/" target="_blank" rel="noopener">原文连接</a></p><h3 id="Authorisation-not-recognised"><a href="#Authorisation-not-recognised" class="headerlink" title="Authorisation not recognised"></a>Authorisation not recognised</h3><p><strong>Can’t open display: localhost:10.0</strong></p><h4 id="Error"><a href="#Error" class="headerlink" title="Error :"></a>Error :</h4><p>Sometimes your users complain they can’t use GUI via X server from Linux box (in this case mobaXterm). They are receiving their display authorization is not recognized. An error like below –</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks@ xclock</span><br><span class="line">MobaXterm X11 proxy: Authorisation not recognised</span><br><span class="line">Error: Can<span class="string">'t open display: localhost:10.0</span></span><br></pre></td></tr></table></figure><p>Sometimes these errors show up when you switch user from the root account or any other account.</p><h4 id="Quick-Solution"><a href="#Quick-Solution" class="headerlink" title="Quick Solution:"></a>Quick Solution:</h4><p><strong>Login directly with</strong> user<strong> on which you want to use xclock</strong></p><p><code>appuser</code> needs to log in directly on the server and you won’t see this issue. Most of the time it arises once you su to <code>appuser</code> from root or different users.</p><p>Read further if you have to switch user and then use x-term.</p><p><code>appuser</code> need to add its entry to authorization. This entry will be the last entry in <code>.Xauthority</code> file in a home directory of the previous user with which you have logged in the server in the first place. Let’s say its <code>root</code> in our case. i.e. we logged in as <code>root</code> and then su to <code>appuser</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kerneltalks <span class="comment"># xauth -f .Xauthority list |tail -1</span></span><br><span class="line">kerneltalks/unix:10 MIT-MAGIC-COOKIE-1 df22dfc7df88b60f0653198cc85f543c</span><br><span class="line"> </span><br><span class="line">appuser@kerneltalks $ xauth add kerneltalks/unix:10 MIT-MAGIC-COOKIE-1 df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>So here we got values from root home directory file and then we added it in using xauth in currently su user i.e. <code>appuser</code></p><p>and you are good to go!</p><h4 id="Bit-of-an-explanation"><a href="#Bit-of-an-explanation" class="headerlink" title="Bit of an explanation :"></a>Bit of an explanation :</h4><p>This error occurs since your ID doesn’t have the authorization to connect to the X server.  Let’s walk through how to resolve this error. List out authorization entries for displays using <code>xauth list</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth list</span><br><span class="line">kerneltalks/unix:12  MIT-MAGIC-COOKIE-1  60c402df81f68e721qwe531d1c99c1eb</span><br><span class="line">kerneltalks/unix:11  MIT-MAGIC-COOKIE-1  ad81da801d778fqwe6aea383635be27d</span><br><span class="line">kerneltalks/unix:10  MIT-MAGIC-COOKIE-1  0bd591485031d0ae670475g46db1b8b9</span><br></pre></td></tr></table></figure><p>The output shows entries column wise –</p><ol><li>Display name</li><li>Protocol name (MIT-MAGIC-COOKIE-1 referred to single period)</li><li>hexkey</li></ol><p>If you have many sessions and you are on test/dev environment and you are the only one using your system you can remove all the above entries using xauth remove to make sure you have a clean slate and getting only your session cookie. Or, you can save this output for reference. Log in again, try  <code>xclock</code> and new the entry will be generated. Compare the latest output with the older one and get your new entry filtered out. Or as mentioned above in a quick solution it will be last entry in <code>.Xauthority</code> file in a home directory of <code>appuser</code>. You can not read  <code>.Xauthority</code> file like text file so you have to use <code>xauth -f</code> command to view its content.</p><p>Logout from all sessions. Login again with the app user and run <code>xclock</code> once. This will generate a new session cookie token which you can see in <code>xauth list</code> .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth list</span><br><span class="line">kerneltalks/unix:10  MIT-MAGIC-COOKIE-1  df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>Now, grab this entry and add authorization using below command –</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth add APCSFIOGWDV02/unix:10  MIT-MAGIC-COOKIE-1  df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>and that’s it. You <code>xclock</code> should work now!</p><hr><h4 id="Error-1"><a href="#Error-1" class="headerlink" title="Error :"></a>Error :</h4><p>You are seeing below error in mobaXterm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X11-forwarding  : ✘  (disabled or not supported by server)</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution :"></a>Solution :</h4><p>The best way to make sure you have all X11 stuff installed is to run the install package <code>xclock</code>. Additionally, you need to install <code>xauth</code> package as well.</p><p>Secondly, make sure you have <code>X11Forwarding yes</code> set in your <code>/etc/ssh/sshd_config</code>. If not then set and restart sshd daemon.</p><p>That’s all! Try re-logging to the server and it should work. You should see the below message after login using MobXterm.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X11-forwarding  : ✔  (remote display is forwarded through SSH)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://kerneltalks.com/troubleshooting/mobaxterm-x11-proxy-authorisation-not-recognised/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文连接&lt;/
      
    
    </summary>
    
    
      <category term="BUG" scheme="http://yoursite.com/categories/BUG/"/>
    
    
  </entry>
  
  <entry>
    <title>Googel EvenBus</title>
    <link href="http://yoursite.com/2020/08/20/%E6%BA%90%E7%A0%81_EvenBus/"/>
    <id>http://yoursite.com/2020/08/20/源码_EvenBus/</id>
    <published>2020-08-20T13:44:15.000Z</published>
    <updated>2021-06-24T12:34:58.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Google-EvenBus-源码"><a href="#Google-EvenBus-源码" class="headerlink" title="Google EvenBus 源码"></a>Google EvenBus 源码</h3><p><strong>EventBus</strong> 发布/订阅者者模式</p><p><img src="1.png" alt="png"></p><p>简单的使用放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus bus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    bus.register(<span class="keyword">this</span>);</span><br><span class="line">    bus.post(<span class="number">1024</span>);</span><br><span class="line">    bus.post(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveInteger</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Integer : "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveString</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"String : "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="png"></p><h3 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h3><p>我们在上面可以看到 <strong> @Subscribe</strong>  注解表示向EventBus总线订阅了该方法. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该注解是基于方法上的. 通过对方法添加注解,当有时间来临的时候.便会执行该方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus.register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将当前对象注册到EventBus中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) &#123;</span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();</span><br><span class="line">  Class&lt;?&gt; clazz = listener.getClass();</span><br><span class="line">  <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">    methodsInListener.put(eventType, Subscriber.create(bus, listener, method));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> methodsInListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过遍历当前对象 (listener中) 的所有包含Subscribe的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Google-EvenBus-源码&quot;&gt;&lt;a href=&quot;#Google-EvenBus-源码&quot; class=&quot;headerlink&quot; title=&quot;Google EvenBus 源码&quot;&gt;&lt;/a&gt;Google EvenBus 源码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Ev
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Domain name system</title>
    <link href="http://yoursite.com/2020/08/13/nslookup/"/>
    <id>http://yoursite.com/2020/08/13/nslookup/</id>
    <published>2020-08-13T13:42:15.000Z</published>
    <updated>2021-05-18T02:14:46.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Domain-name-system"><a href="#Domain-name-system" class="headerlink" title="Domain name system"></a>Domain name system</h2><h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h3><ol><li><p>List 3 different protocols that appear in the protocol column in the unfiltered<br> packet-listing window in step 7 above.</p><p><img src="image-20200813143931097.png" alt="image-20200813143931097"></p></li><li><p>How long did it take from when the HTTP GET message was sent until the HTTP<br> OK reply was received? (By default, the value of the Time column in the packet listing window is the amount of time, in seconds, since Wireshark tracing began.</p><p><img src="image-20200813144423850.png" alt="image-20200813144423850"></p></li></ol><p>To display the Time field in time-of-day format, select the Wireshark View pull<br>down menu, then select Time Display Format, then select Time-of-day.)</p><ol><li><p>What is the Internet address of the gaia.cs.umass.edu (also known as www.net.<br> cs.umass.edu)? What is the Internet address of your computer</p><p><img src="image-20200813144743605.png" alt="image-20200813144743605"></p></li><li><p>Print the two HTTP messages (GET and OK) referred to in question 2 above. To<br> do so, select Print from the Wireshark File command menu, and select the<br> “Selected Packet Only” and “Print as displayed” radial buttons, and then click<br> OK.</p><p><img src="image-20200813145358276.png" alt="image-20200813145358276"></p></li></ol><h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h3><p><strong>PREREQUISITES</strong> </p><pre><code>1. Computer Networking: A Top-Down Approach, 7th ed., J.F. Kurose and K.W. Ross (Chapter 1 and Chapter 2) TASK </code></pre><p><strong>TASK</strong></p><pre><code>1. Install Wireshark (lab. 1 part 1) – you already have all information.2. Use nslookup to analyze DNS messages 3. Use ipconfig to analyze DNS messages 4. Use Wireshark to analyze DNS messages</code></pre><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><ol><li><p>Run nslookup to obtain the IP-address of a Web-server in China. What is the IP-address of that server</p><p><img src="image-20200813140126152.png" alt="image-20200813140126152"></p></li><li><p>Run nslookup to determine the authoritative dNs servers for a university in Europe</p><p><img src="image-20200813140220702.png" alt="image-20200813140220702"></p></li><li><p>Run nslookup so that one of the dns servers obtained in Question 2 is queried for the mail servers for Yandex mail(or any other What is its iP address?</p><p><img src="image-20200813141637442.png" alt="image-20200813141637442"></p></li><li><p>Make screenshots of your command line and put them in the report put them in the report along with the answers to questions</p></li></ol><h4 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h4><p><img src="image-20200813140706733.png" alt="image-20200813140706733"></p><p><img src="image-20200813141105155.png" alt="image-20200813141105155"></p><p><img src="image-20200813141148746.png" alt="image-20200813141148746"></p><h4 id="Tracing-DNS-with-Wireshark"><a href="#Tracing-DNS-with-Wireshark" class="headerlink" title="Tracing DNS with Wireshark"></a><strong>Tracing DNS with Wireshark</strong></h4><ul><li>Use ipconfig to empty the dns cache in your host</li><li>Open your browser and empty your browser cache. (With Internet Explorer, go to Tools menu and select Internet Options; then in the general tab select Delete Files.</li><li>Open Wireshark and enter ip addr =- your ip address into the filter, where you obtain your IP address with ipconfig. This filter removes all packets that neither originate nor are destined to your host</li><li>Start packet capture in Wireshark</li><li>With your browser, visit the some Web page</li><li>Stop packet capture</li></ul><ol><li><p>Locate the DNS query and response messages. are then sent over UDP or TCP?</p><p> <img src="image-20200813150611186.png" alt="image-20200813150611186"></p></li></ol><p>​    It can be seen from the query message information and the response messages information they are Sending message via <strong>UDP</strong>.</p><ol><li><p>What is the destination port for the DNS query message? What is the source port of DNS response message?</p><p> <img src="image-20200813150750618.png" alt="image-20200813150750618"></p><p> <img src="image-20200813151051501.png" alt="image-20200813151051501"></p><p> Ports are both <strong>53</strong></p></li><li><p>To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same.</p><p>  <img src="image-20200813151609517.png" alt="image-20200813151609517"></p><p> <img src="image-20200813151711412.png" alt="image-20200813151711412"></p><p> both are <strong>202.101.172.35</strong></p></li><li><p>Examine the DNS query message. What Type’of DNS query is it? Does the query message contain any“ answers”?</p></li></ol><p><img src="image-20200813152007576.png" alt="image-20200813152007576"></p><pre><code>Type:A and query message does not contain any &quot;answers&quot;.</code></pre><ol><li><p>Examine the DNS response message. How many answers are provided? what do each of these answers contain?</p><p> <img src="image-20200813152229592.png" alt="image-20200813152229592"></p><p> See the picture.</p></li><li><p>Does this web page contain images? Before retrieving each image, does your host issue new DNS queries?</p><p> <img src="image-20200813152229592.png" alt="image-20200813152229592"></p><p> None</p></li></ol><h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><h4 id="nslookup-domain"><a href="#nslookup-domain" class="headerlink" title="nslookup domain"></a>nslookup domain</h4><ul><li><p>Start packet capture.</p></li><li><p>Do 𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 𝑤𝑤𝑤.ℎ𝑑𝑢.𝑒𝑑𝑢.𝑐𝑛</p><p><img src="image-20200813153853249.png" alt="image-20200813153853249"></p></li><li><p>Stop packet capture. You should get a trace that looks something like the following (on the last pictures).</p></li></ul><ol><li><p>What is the destination port for the DNS query message? What is the source port of DNS response message?</p><p><img src="image-20200813154043327.png" alt="image-20200813154043327"></p><p>The destination port for the DNS query message is <strong>53</strong>.</p><p>The source port of DNS response message is also <strong>53</strong>.</p></li><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server</p><p><img src="image-20200813154248959.png" alt="image-20200813154248959"></p><p><img src="image-20200813153853249.png" alt="image-20200813153853249"></p><p>Same as the IP address of the local DNS server</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? </p><p><img src="image-20200813154557227.png" alt="image-20200813154557227"></p></li><li><p>Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?</p><p><img src="image-20200813154731464.png" alt="image-20200813154731464"></p><p>have 3 answers. </p></li></ol><h4 id="nslookup-type"><a href="#nslookup-type" class="headerlink" title="nslookup -type"></a>nslookup -type</h4><p>Now repeat the previous experiment, but instead issue the command:</p><p>​                    𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 – 𝑡𝑦𝑝𝑒=𝑁𝑆 𝑎𝑑𝑑𝑟𝑒𝑠𝑠<em> 𝑤ℎ𝑎𝑡 </em> 𝑦𝑜𝑢_𝑤𝑎𝑛𝑡</p><p><strong>nslookup -type = NS baidu.com</strong></p><p><img src="image-20200813155226270.png" alt="image-20200813155226270"></p><p>Answer the following questions:</p><ol><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</p><p><img src="image-20200813155813591.png" alt="image-20200813155813591"></p><p>Same as the IP address of the local DNS server.</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</p><p><img src="image-20200813155822201.png" alt="image-20200813155822201"></p><p>Type: NS </p><p>query message does not contain any “answers”.</p></li><li><p>Examine the DNS response message. What nameservers does the response message provide?</p><p><img src="image-20200813155925788.png" alt="image-20200813155925788"></p><p>result obtained in Wireshark is the same as the result obtained by running in nslookup.</p></li></ol><h4 id="nslookup-𝑦𝑜𝑢𝑟-𝐷𝑁𝑆"><a href="#nslookup-𝑦𝑜𝑢𝑟-𝐷𝑁𝑆" class="headerlink" title="nslookup 𝑦𝑜𝑢𝑟 _ 𝐷𝑁𝑆"></a>nslookup 𝑦𝑜𝑢𝑟 _ 𝐷𝑁𝑆</h4><p>Now repeat the previous experiment, but instead issue the command:</p><p>​                    𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 𝑎𝑑𝑑𝑟𝑒𝑠𝑠 <em> 𝑤ℎ𝑎𝑡 </em> 𝑦𝑜𝑢 <em> 𝑤𝑎𝑛𝑡 𝑦𝑜𝑢𝑟 </em> 𝐷𝑁𝑆</p><p><strong>nslookup www.baidu.com 114.114.114.114</strong></p><p><img src="image-20200813160230801.png" alt="image-20200813160230801"></p><p>Answer the following questions:</p><ol><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server? If not, what does the IP address correspond to?</p><p><img src="image-20200813160716347.png" alt="image-20200813160716347"></p><p> They are not the same.This ip corresponds to the ip specified last by entering “nslookup baidu.com 114.114.114.114” in the terminal.</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</p><p><img src="image-20200813160716347.png" alt="image-20200813160716347"></p><p>Type: A </p><p>query message does not contain any “answers”.</p></li><li><p>Examine the DNS response message. How many “answers” are provided? What does each of these answers contain?</p><p><img src="image-20200813160906241.png" alt="image-20200813160906241"></p><p>you can see from the picture above, it contains 3 answers</p><p>The result is the same as the result obtained by nslookup in the Terminal.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Domain-name-system&quot;&gt;&lt;a href=&quot;#Domain-name-system&quot; class=&quot;headerlink&quot; title=&quot;Domain name system&quot;&gt;&lt;/a&gt;Domain name system&lt;/h2&gt;&lt;h3 id=&quot;P
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Document_Embedding</title>
    <link href="http://yoursite.com/2020/08/07/ML_document_embedding/"/>
    <id>http://yoursite.com/2020/08/07/ML_document_embedding/</id>
    <published>2020-08-07T08:57:15.000Z</published>
    <updated>2021-05-18T02:14:25.225Z</updated>
    
    <content type="html"><![CDATA[<p>[原文连接]<a href="https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d" target="_blank" rel="noopener">https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d</a></p><p>近年来，单词嵌入（将单词映射到数值向量空间中）已被证明是自然语言处理（NLP）任务的一种非常重要的方法，它使各种依赖于向量表示作为输入的机器学习模型都可以享受更丰富的文本表示输入。这些表示形式保留了更多关于单词的语义和句法信息，从而导致几乎所有可以想象的NLP任务的性能得到改善。</p><p>新颖的想法本身及其巨大的影响，都促使研究人员考虑如何将这种丰富的矢量表示形式提供给更大的文本单位（从句子到书籍）的问题。这项工作导致产生了许多新方法来生成这些映射，并为该问题提供了各种创新解决方案以及一些显着的突破。</p><blockquote><p><strong>注意</strong>”：这里使用“ <strong>文档</strong>”一词来指代<strong>任何单词序列</strong>，从句子和段落到社交媒体帖子，一直到文章，书籍和结构更复杂的文本文档。</p></blockquote><p>在本文中，我不仅会介绍单词嵌入技术的直接扩展方法（例如<em>doc2vec</em> 扩展<em>word2vec</em> 的方法），还将介绍其他值得注意的技术，这些技术有时会在其他输出中生成ℝⁿ中的文档到向量的映射。 。</p><h2 id="文件嵌入的应用"><a href="#文件嵌入的应用" class="headerlink" title="文件嵌入的应用"></a>文件嵌入的应用</h2><p>将文档映射到信息矢量表示的能力具有广泛的应用。以下只是部分列表。</p><p>[<a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Le &amp; Mikolov, 2014</a>]展示了他们的<em>段落向量</em>法在几种文本分类和情感分析任务上的功能，而[<a href="https://arxiv.org/pdf/1507.07998.pdf" target="_blank" rel="noopener">Dai et al, 2015</a>] 在文档相似性任务的背景下对其进行了检验， [<a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau &amp; Baldwin, 2016</a>]进行了基准测试它针对论坛问题重复任务和 <a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener">the Semantic Textual Similarity (STS) SemEval shared task</a>.</p><p>[<a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Kiros et al, 2015</a>] 已经证明了他们的<em>Skip-thought</em>向量在语义相关性，释义检测，图像句子排名，问题类型分类以及四个情感和主观性数据集上的使用。[Broere，2017]使用它们来预测POS标签和依赖关系。</p><p>[<a href="https://arxiv.org/pdf/1810.09302.pdf" target="_blank" rel="noopener">Chen et al, 2018</a>] 显示了<em>BioSentVec</em> ，他们在生物医学文本上训练过的句子嵌入集，在句子对相似性任务(<a href="https://github.com/ncbi-nlp/BioSentVec" target="_blank" rel="noopener">official Python implementation</a>).上表现良好。</p><p>最后，<a href="https://www.microsoft.com/en-us/research/project/dssm/" target="_blank" rel="noopener">Deep Semantic Similarity Model was used by various authors</a> 进行信息检索和Web搜索排名，广告选择/相关性，上下文实体搜索和兴趣度任务，问题解答，知识推断，图像字幕和机器翻译任务。</p><p>但是请注意，尽管文档嵌入的问题已经很久了，但许多当前有影响力的解决方案还是很年轻的，并且在紧随当代基于编码器-解码器的单词成功之后，这一领域在最近（大约在2014年）开始兴起嵌入技术，所以现在还很早。话虽如此，我希望这部分内容可以将以下各节放在更广阔的背景下，并以有意义的方式进行组织。</p><h2 id="突出的方法和趋势"><a href="#突出的方法和趋势" class="headerlink" title="突出的方法和趋势"></a>突出的方法和趋势</h2><hr><h3 id="文本嵌入的方法"><a href="#文本嵌入的方法" class="headerlink" title="文本嵌入的方法"></a>文本嵌入的方法</h3><p>映射领域的一种可能方法是采用以下四种主要方法：</p><ol><li><strong>总结词向量</strong><br>这是<em>对</em>经典的方法。<em>Bag-of-words</em> 正是针对一个热门单词向量而做到的，而您可以应用到它的各种加权方案都是以这种方式总结单词向量的方式。但是，这种方法在与最先进的词表示形式一起使用时（通常通过求平均值而不是求和）也有效，尤其是在考虑到这种用法优化词嵌入时，并且可以与任何这里介绍的更性感的方法。</li><li><strong>主题建模</strong><br>虽然这通常不是主题建模技术（如LDA和PLSI）的主要应用，但它们<em>固有地生成了一个文档嵌入空间</em>，用于对语料库中的单词分布进行建模和解释，而维可以看作是隐藏在<em>文档</em>中的潜在语义结构。数据，因此在我们的上下文中很有用。我没有在本文中真正介绍这种方法（LDA的简要介绍除外），因为我认为LDA很好地代表了这种方法，并且众所周知。</li><li><strong>编码器-解码器模型</strong><br>这是场景中最新的无监督功能，具有<em>doc2vec</em> 和 <em>skip-thought</em> 之类的功能。尽管这种方法自2000年代初就出现了（以 <em>神经概率语言模型</em> 的名义），但随着其成功地应用于词嵌入生成，它最近获得了新生，目前的研究集中在如何将其用途扩展到文档嵌入。这种方法从大型未标记语料库的可用性不断提高中获得了比其他方法更多的收益。</li><li><strong>有监督的表示学习</strong><br>这种方法的应用源于神经网络模型的兴起（或兴起），以及它们使用各种非线性多层算子学习输入数据的丰富表示的能力，<a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" target="_blank" rel="noopener">该函数可以近似各种映射</a>.。通过简单地将单词袋输入到神经网络中以解决与文本相关的监督问题，您将得到一个模型，其中隐藏层包含输入文本的丰富表示形式，这正是我们所追求的。</li></ol><p>有几种不受监督的方法不适用于上述任何一种方法（特别是<em>想到的是快速思考</em>和<em>Word Mover的距离</em>），但是我认为大多数技术确实属于这四大类之一。</p><blockquote><p><strong>注意：</strong>虽然很容易指出经典的单词袋技术遭受独特的顺序信息缺失的困扰，但这实际上是规则，而不是例外。通过本文回顾的大多数新方法获得的主要信息是将分布假设扩展到更大的文本单元。基于神经网络的序列模型是例外。</p></blockquote><h3 id="挑战和趋势"><a href="#挑战和趋势" class="headerlink" title="挑战和趋势"></a>挑战和趋势</h3><p>整体上研究文档嵌入技术的研究和应用时，会出现几种广泛的趋势，并且可能会发现一些挑战。</p><ol><li><strong>编码器-解码器优化：研究</strong>的重要部分集中在优化无监督的精确体系结构（例如ANN / CNN / RNN）和某些组件/超参数（例如n-gram，投影函数，权重等）上编码器-解码器方法，用于学习文档嵌入。尽管此微调的目标之一是提高各种任务的成功指标，但目标还是能够在较大的语料库上或更短的时间内训练模型。</li><li><strong>学习目标设计：</strong>无监督（或自我监督）表示学习的关键在于设计一个学习目标，该目标利用数据中自由可用的标签，从而生成对下游任务有用的表示。对我来说，这是最令人兴奋的趋势，并且我认为对NLP任务影响最大的趋势可能等同于一个词嵌入技术。目前，我仅将<em>快速思考</em>和<em>Word Mover的距离</em>视为编码器/解码器方法的替代方法。这种趋势的另一个吸引人的方面是，此处的创新也可能适用于词嵌入问题。</li><li><strong>基准测试：</strong>一般来说，机器学习研究是整个领域趋势的一部分，文档嵌入（可能由于它是一个年轻的子领域）很好地证明了研究在越来越广泛的领域对技术基准进行研究的重点（请参阅<a href="https://gluebenchmark.com/leaderboard" target="_blank" rel="noopener">GLUE排行榜</a>)。但是，几乎所有关于该主题的论文都宣称与当前SOTA技术具有可比或更好的结果，但这尚未导致明显的领先者出现。</li><li><strong>开放源代码：</strong>再次，这是更广泛趋势的一部分，大量使用易于使用的代码实现技术（通常还包括实验）来实现可重现性，并推动了与学术界之外的更广泛的数据科学界的互动，并推动了对真实单词问题的使用。</li><li><strong>跨任务的适用性：</strong>在有监督的嵌入式学习中，情况可能更多，尽管并非所有无监督的技术都具有相同的综合水平。无论如何，依靠文本数据中不同类型的信息，各种各样非常多样化的NLP任务使这一问题成为突出问题。从多个任务中共同学习嵌入是一种受监督的方法可以解决这一挑战的有趣方式。</li><li><strong>标记语料库：</strong>大型标记语料库的有限可用性也是今后有监督方法的问题。这可能代表了未来几年无监督方法在有监督的表示学习中的真正优势。</li></ol><p><strong>注意：</strong>如果您发现这部分内容与上下文不符，建议您在仔细阅读本文中介绍的大部分技巧后再进行访问。</p><p>本节简要介绍了两种适用于文档嵌入的成熟技术：<em>词袋</em>  和*潜在Dirichlet 分配。</p><h2 id="传统经典方法"><a href="#传统经典方法" class="headerlink" title="传统经典方法"></a>传统经典方法</h2><h3 id="Bag-of-words"><a href="#Bag-of-words" class="headerlink" title="Bag-of-words"></a>Bag-of-words</h3><p> <strong>Bag-of-words</strong><br>在[Harris，1954]中提出的这种方法将文本表示为单词的包（<a href="https://en.wikipedia.org/wiki/Multiset" target="_blank" rel="noopener">Multiset</a>) （丢失语法和排序信息）。这是通过确定一组<em>n个</em>单词组成的，这些单词将构成映射支持的词汇表，并为词汇表中的每个单词分配唯一索引。然后，每个文档都由长度为<em>n</em> 的向量表示，其中第<em>i</em> 个条目包含单词<em>i</em> 在文档中出现的次数。</p><p><img src="1.png" alt="png"></p><p>图1：例句中的单词袋表示</p><p>例如，句子“<strong>dog eat dog world, baby</strong>!” （在清理标点之后）可能由550个长度的向量<em>v表示</em>（假设选择了550个单词的词汇），除以下条目外，其他地方均为零：</p><p>•$ V_{76}= 1$，因为词汇的第76个词是<em>world</em> 。       </p><p>• $ V_{200}= 2$，因为词汇的第200个单词是<em>dog</em> 。       </p><p>• $ V_{322}= 1$，因为第332个单词是 <em>eat</em>。       </p><p>• 单词中没有选择“ <em>baby</em> ”一词，因此在不输入向量的情况下其值为1。       </p><p>尽管它非常简单，除了单词出现频率之外，所有信息都丢失了，并且表示大小迅速增长以支持丰富的词汇的趋势，这种技术几乎在几十年中几乎全部用于NLP任务，并获得了巨大成功。即使近年来在文本的矢量表示方面取得了显着进展，但仍在使用此方法的常见细微变化（如下所述），如今，这种变化并不总是唯一的，因为它只是很快被超越的第一个基线。</p><p><strong>Bag-of-n-grams</strong><br>为了获得某些单词袋方法丢失的某些单词顺序信息，可以使用短单词序列（长度为2、3等）的频率（附加或替代）构造单词向量。自然地，对于<em>n = 1</em> ，词袋是此方法的一个私有案例。</p><p>对于“<strong>dog eat dog world, baby</strong>!” 一词对是”<strong>dog eat</strong>“，”<strong>eat dog </strong>“，”<strong>dog world </strong>“和”<strong>world baby</strong>“，词汇表由输入语料库中的所有连续单词对组成。</p><p> <img src="2.png" alt="2"></p><p>图2：“电影很棒”这句话的2-gram表示法</p><p>这种方法的一个主要缺点是词汇量大小对唯一单词数量的非线性依赖性，这对于大型语料库可能非常大。过滤技术通常用于减小词汇量。</p><p><strong>TF-IDF weighting</strong><br>在词袋环境中值得一提的最后一项相关技术是<a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank" rel="noopener"><em>术语频率-逆文档频率</em></a>, 通常称为<strong>tf-idf</strong> 。此方法使用每个单词的<em>文档反向频率</em>（<strong>IDF</strong>）对上述单词（或<strong>n-gram</strong>）频率向量进行加权。单词的IDF就是语料库中文档数量除以该单词出现在其中的文档数量的对数。</p><script type="math/tex; mode=display">DIF_i = log( \frac{ \# of documents  in corpus}{\# of documents in which word i appears in})</script><p>简而言之，TF术语随着单词出现的增加而增长，而IDF术语则随着单词的稀有性而增加。这是为了针对某些单词通常更多（或更少）频繁出现这一事实来调整频率得分。参见[<a href="http://pmcnamee.net/744/papers/SaltonBuckley.pdf" target="_blank" rel="noopener">Salton &amp; Buckley, 1988</a>]，可以全面了解术语加权方法。</p><h3 id="Latent-Dirichlet-allocation-LDA"><a href="#Latent-Dirichlet-allocation-LDA" class="headerlink" title="Latent Dirichlet allocation (LDA)"></a>Latent Dirichlet allocation (LDA)</h3><p>LDA是一种生成统计模型，它允许由未观察组解释一组观察结果，这些观察组解释了为什么某些数据部分相似。例如，如果观察是收集到文档中的单词，则假定每个文档都是少量主题的混合，并且每个单词的出现都可归因于文档的一个主题。</p><p>要将其与单词袋联系起来，可以将前一种方法视为文档在单词上的分布的简单化概率模型。然后，词袋向量代表我们对每个文档中非规范化词分布的最佳近似值；但是这里的文档是概率的基本单位，每个都是其唯一分布的单个样本。</p><p>因此，问题的关键在于通过添加潜在的（隐藏的）<em>K</em> 主题中间层，从这种简单的概率性文档模型（按单词分布）转移到更复杂的模型。</p><p> <img src="3.png" alt="3"></p><p>图3：概率模型从单词袋转移到LDA</p><p>现在，主题的特征是单词的分布，而文档则是主题的分布。文档的这种概率模型对应于文档的生成模型。假设预定数量的<em>K个</em>主题，要生成一<em>组长</em>度为<em>{Nᵢ}</em> 的<em>M个</em>文档，其中<em>Dir（）</em>表示<a href="https://en.wikipedia.org/wiki/Dirichlet_distribution" target="_blank" rel="noopener">Dirichlet分布</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 对于每个主题 v ，采样一个单词分布φᵥ〜Dir  （β） 。</span><br><span class="line">2. 对于每个文档 i ，采样一个主题分布（或混合）θᵢ〜Dir  （ α  ） 。</span><br><span class="line">3. 为每个单词 j  生成长度为 Nᵢ的 文档 i ：</span><br><span class="line">   1. 为单词 j 进行服从于 Multinomial(θᵢ)分布的主题采样  .   </span><br><span class="line">   2. 对单词 j 服从于Multinomial(zᵢⱼ)分布 进行采样 。</span><br></pre></td></tr></table></figure></p><p>给定此模型和大量文档，问题就成为了推论之一，并且在推论过程中发现了上述各种分布的近似值。其中有θᵢ，每个文档<em>i</em> 的主题分布，维数<em>K的</em>向量。</p><p>因此，在推断模型的过程中，推断出维度为<em>K</em> 的向量空间，该向量空间以某种方式捕获了我们语料库中的主题或主题以及它们在文档中的共享方式。当然，可以将其视为这些文档的嵌入空间，并且-取决于<em>K</em> 的选择-其维数可以比基于词汇的维数小得多。</p><p>确实，虽然LDA的主要用例是无监督的主题/社区发现，但其他情况包括将所得的潜在主题空间用作文档语料库的嵌入空间。另外，请注意，其他主题建模技术（例如<a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" target="_blank" rel="noopener">非负矩阵分解（NMF）</a> 和<a href="https://en.wikipedia.org/wiki/Probabilistic_latent_semantic_analysis" target="_blank" rel="noopener">概率潜在语义索引（PLSI））</a> 也可以类似的方式用于学习文档嵌入空间。</p><blockquote><p><strong>注意：</strong>从业者对概率主题模型的主要问题是稳定性。由于训练主题模型需要对概率分布进行采样，因此随着随机数生成器种子的变化，同一语料库的模型可能会有所不同。主题模型对相对较小的语料库更改的敏感性使此问题更加复杂。</p></blockquote><h2 id="无监督的文本嵌入"><a href="#无监督的文本嵌入" class="headerlink" title="无监督的文本嵌入"></a>无监督的文本嵌入</h2><p>本节中介绍的许多方法均受著名的词嵌入技术的启发，其中主要的方法是<em>word2vec</em> ，它们有时甚至是这些方法的直接概括。这些词嵌入技术有时也称为<em>神经概率语言模型</em>; 这些不是完全相同的术语，因为概率语言模型是<em>单词序列上的概率分布</em>，但是由于此方法是在[ <a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">Bengio，2003</a>],中作为学习语言模型的一种方法而引入的，因此它们紧密相关。</p><p>即使假设您熟悉<em>word2vec</em> ，我仍然希望注意到此模型所做的重要假设，并且可能由这里审查的每个模型<em>（分布假设）推崇</em>。这是<a href="https://en.wikipedia.org/wiki/Distributional_semantics#Distributional_hypothesis" target="_blank" rel="noopener">维基百科</a>的简短描述：</p><blockquote><p>语言学中的<strong>分布假设</strong>源于语言使用的<a href="https://en.wikipedia.org/w/index.php?title=Semantic_theory&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">语义理论</a>，即在相同上下文中使用和出现的单词往往具有相似的含义。<a href="https://en.wikipedia.org/wiki/J._R._Firth" target="_blank" rel="noopener">Firth</a>推广了“单词由其所拥有的公司来表征”的基本思想。分布假设是<a href="https://en.wikipedia.org/wiki/Statistical_semantics" target="_blank" rel="noopener">统计语义</a>.的基础。</p></blockquote><p>确实，很容易看到<em>word2vec</em> 和其他用于学习单词表示的自我监督方法都严重依赖此假设。毕竟，模型的症结在于，在学习从单词本身来预测单词上下文时（反之亦然）学习到的单词表示形式代表了捕获深层语义和句法概念和现象的向量空间。意思是，从单词的上下文中学习可以教会我们有关单词的含义和句法作用的知识。</p><p>在本节中，将介绍自我监督的文档表示学习，您将看到所有这些方法都维护单词的这一假设，并以某种方式将其扩展到较大的文本单元。</p><h3 id="n-gram-embeddings"><a href="#n-gram-embeddings" class="headerlink" title="n-gram embeddings"></a>n-gram embeddings</h3><p>[ <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Mikolov et al，2013b</a> ]扩展了<em>word2vec</em> 的skip-gram模型，通过使用数据驱动方法识别大量短短语（作者专注于两个单词和三个单词的短语）来处理短短语。在<em>word2vec</em> 模型训练期间，将这些短语作为单独的标记。自然地，这不适合学习更长的短语-因为随着短语长度的增加，词汇量会激增-并且<em>势必不会泛化到看不见的短语</em> 及其遵循的方法。</p><p>莫西·哈祖姆（Moshe Hazoom）<a href="https://towardsdatascience.com/word2vec-for-phrases-learning-embeddings-for-more-than-one-word-727b6cf723cf" target="_blank" rel="noopener">对这种方法进行了精彩的实践回顾，</a>他的将其用于专注于金融领域的搜索引擎。</p><h3 id="Averaging-word-embeddings"><a href="#Averaging-word-embeddings" class="headerlink" title="Averaging word embeddings"></a>Averaging word embeddings</h3><p>有一种非常直观的方法可以从有意义的单词嵌入中构造文档嵌入：给定文档，对与文档单词对应的所有矢量执行一些矢量算术，以将它们汇总到同一嵌入空间中的单个矢量中；两种常见的汇总运算符是平均值和和。</p><p>在此基础上，您可能已经可以想象到，扩展<em>word2vec</em> 及其亲属的编码器-解码器体系结构以学习<em>如何</em>将单词向量组合到文档嵌入中可能会很有趣。遵循这一方法的方法属于这一类。</p><p>第二种可能性是使用固定的（不可学习的）运算符进行矢量汇总（例如求平均），并使用旨在产生丰富文档嵌入的学习目标来学习上一层中的单词嵌入；一个常见的示例是使用句子来预测上下文句子。因此，这里的主要优点是优化了词嵌入，以平均化成文档表示形式。</p><p> <img src="4.png" alt="4"></p><p>图4：来自[ <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Kenter等，2016</a> ]的暹罗CBOW网络架构</p><p>[ <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Kenter等人，2016</a> ]做到了这一点，即使用平均单词向量的简单神经网络，通过给定句子表示形式预测周围的句子，从而学习单词嵌入。他们将结果与平均的<em>word2vec</em> 向量和<em>跳思想</em>向量进行了比较（请参见下面的相应小节）。[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等，2016</a> ]比较了许多方法，包括训练CBOW和skip-gram词嵌入，同时优化句子表示（此处使用词向量的逐元素加法）。[ <a href="http://wwwusers.di.uniroma1.it/~navigli/pubs/KBS_Sinoaraetal_2019.pdf" target="_blank" rel="noopener">Sinoara等人，2019</a> ]还提出了将单词嵌入向量和其他知识源（例如单词感知向量）直接嵌入其质心以表示文档的方法。</p><p>最后，[ <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">Arora等人，2016年</a> ]进一步表明，当通过两个小变化进行增强时，此方法是一种简单但难以击败的基线：（1）使用平滑的逆频率加权方案，以及（2）消除常见的词向量的语篇成分；该组件是使用PCA找到的，它被用作最常用语的更正词，大概与语法有关。作者提供了一个<a href="https://github.com/peter3125/sentence2vec" target="_blank" rel="noopener">Python实现</a>。</p><blockquote><p><strong>注意：</strong>当查看基于注意力的机器翻译模型时，也许可以找到正确平均的单词“嵌入”功能的另一种证明。单向解码器RNN获得先前翻译的单词作为输入，不仅是要翻译的当前单词的“嵌入”（即，来自编码器RNN的双向激活），还包括周围单词的翻译。这些以加权的方式平均为上下文向量。据教导，这种加权平均能够从编码器网络的激活中维护复杂的成分和与顺序相关的信息（回想一下，这些不是像我们的情况那样不是孤立的嵌入;每个嵌入都包含前一个/后续单词的上下文）。</p></blockquote><h3 id="Sent2Vec"><a href="#Sent2Vec" class="headerlink" title="Sent2Vec"></a>Sent2Vec</h3><p>在[ <a href="https://aclweb.org/anthology/N18-1049" target="_blank" rel="noopener">Pagliardini et al，2017</a> ]和[ <a href="https://www.aclweb.org/anthology/N19-1098" target="_blank" rel="noopener">Gupta et al，2019</a> ]中提出（包括<a href="https://github.com/epfml/sent2vec" target="_blank" rel="noopener">基于C ++的官方Python实现</a>），该技术很大程度上是上述两种方法的组合：<em>word2vec</em> 的经典CBOW模型都得到了扩展包括单词n-gram <em>并</em>适用于优化单词（和n-grams）嵌入，以便对其求平均以产生文档向量。</p><p> <img src="5.png" alt="5"></p><p>图5：sent2vec可以看作是fastText的无监督版本</p><p>另外，删除了输入子采样的过程，而是将整个句子视为上下文。这意味着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a）放弃使用频繁的单词二次采样（以防止生成n元语法特征）</span><br><span class="line">（b）放弃word2vec 使用的动态上下文窗口：考虑整个句子作为上下文窗口，而不是在1和当前句子的长度之间均匀采样每个子采样单词的上下文窗口大小。</span><br></pre></td></tr></table></figure><p>想到另一种方式<em>sent2vec</em> 是作为一种无监督的版本<em>fastText</em> ，其中整个句子是上下文和可能的类标签都是词汇。巧合的是，[ <a href="https://link.springer.com/article/10.1186/s12859-018-2496-4" target="_blank" rel="noopener">Agibetov等人，2018</a> ]感知使用比较多层的性能<em>sent2vec</em> 向量作为特征到的<em>fastText</em> ，针对生物医学句子分类的任务。</p><h3 id="Paragraph-vectors-doc2vec"><a href="#Paragraph-vectors-doc2vec" class="headerlink" title="Paragraph vectors (doc2vec)"></a>Paragraph vectors (doc2vec)</h3><p>有时称为<em>doc2vec</em> ，此方法在[ <a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Le＆Mikolov，2014</a> ]中提出，可能是首次尝试推广<em>word2vec</em> 以使其与单词序列配合使用。作者介绍了<em>段落向量</em>模型的两个变体：<em>分布式内存</em>和<em>分布式词袋。</em></p><h3 id="Paragraph-Vectors-Distributed-Memory-PV-DM"><a href="#Paragraph-Vectors-Distributed-Memory-PV-DM" class="headerlink" title="Paragraph Vectors: Distributed Memory (PV-DM)"></a>Paragraph Vectors: Distributed Memory (PV-DM)</h3><p>PV-DM模型通过添加旨在捕捉段落主题或输入内容的内存向量来增强标准的编码器-解码器模型。这里的训练任务与<em>连续单词</em>的训练非常类似; 一个单词要根据其上下文进行预测。在这种情况下，上下文单词是前面的单词，而不是段落周围的单词。</p><p> <img src="6.png" alt="6"></p><p>图6：段落向量的分布式内存模型（PV-DM）</p><p>为了实现这一点，每个段落都映射到一个唯一的向量，该向量由词汇表中矩阵中的一列表示（用<em>D</em> 表示）。上下文是固定长度的，并从段落上的滑动窗口中采样。段落向量在同一段落生成的所有上下文之间共享，但不跨段落共享。自然，词嵌入是全局的，并且可以使用经过预训练的词嵌入（请参见下面的<em>实现和增强</em>）。</p><p>与<em>word2vec中一样</em>，向量必须以某种方式汇总为单个向量。但是与<em>word2vec</em> 不同，作者在实验中使用串联。请注意，这将保留订单信息。与<em>word2vec</em> 相似，在此汇总的矢量表示上使用了一个简单的softmax分类器（在这种情况下，实际上是分层的softmax）来预测任务输出。使用随机梯度下降法并通过反向传播获得梯度，以标准方式进行训练。</p><p>请注意，只有训练语料库中的段落才具有来自<em>D</em> 的列向量。在预测时，需要执行一个推理步骤来计算新段落的段落向量：文档向量是随机初始化的。然后，重复地从新文档中选择一个随机词，并使用梯度下降来调整输入到隐藏层的权重，以使所选词的softmax概率最大化，而隐藏到softmax的输出权重为固定。这导致将新文档表示为训练语料库文档向量（即<em>D的</em>列）的混合物，自然而然地位于文档嵌入空间中。</p><p><strong>段落向量：分布式词袋（PV-DBOW）</strong><br>的第二种变体，尽管其名称如此，也许与<em>word2vec</em> 的<em>skip-gram</em> 体系结构相似。分类任务是仅使用段落向量来预测单个上下文词。在随机梯度下降的每次迭代中，对文本窗口进行采样，然后从该窗口中采样单个随机词，从而形成以下分类任务。</p><p> <img src="7.png" alt="7"></p><p>图7：段落向量的分布式词袋模型（PV-DBOW）</p><p>除不与段落向量一起共同学习单词向量的事实外，训练在其他方面相似。这使得PV-DBOW变体的内存和运行时性能都更好。</p><blockquote><p><strong>注意：</strong>在<a href="https://radimrehurek.com/gensim/models/doc2vec.html" target="_blank" rel="noopener">其Gensim实现中</a>，PV-DBOW默认情况下使用随机初始化的词嵌入；如果dbow_words设置为1，则在运行dbow之前运行一次skip-gram步骤以更新单词嵌入。[ <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau＆Baldwin，2016</a> ]认为，尽管dbow在理论上可以与随机词嵌入一起使用，但这在他们检查的任务中会严重降低性能。</p></blockquote><p>直观的解释可以追溯到模型的目标函数，该函数的目的是使文档嵌入与其组成的单词嵌入之间的点积最大化：如果单词嵌入是随机分布的，则优化文档嵌入使其更接近于变得更加困难。其更关键的内容词。</p><p><strong>应用</strong><br>[Le＆Mikolov，2014]演示了<em>段落向量</em>在多个文本分类和情感分析任务上的使用，而[Dai等，2015]在文档相似性任务和[Lau＆Baldwin， [2016年]以论坛问题重复任务和<a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener"><em>语义文本相似性（STS）SemEval</em></a>共享任务为<a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener"><em>基准</em></a>。后面的两篇论文都对该方法进行了扩展评估（前者侧重于PV-DBOW变体），将其与其他几种方法进行了比较，并提供了实用建议（后者<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">包括代码</a>）。</p><p>该方法具有<a href="https://radimrehurek.com/gensim/models/doc2vec.html" target="_blank" rel="noopener">gensim包的一部分的Python实现</a>和<a href="https://github.com/inejc/paragraph-vectors" target="_blank" rel="noopener">PyTorch实现</a>。再次，[ <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau＆Baldwin，2016年</a> ]还<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">提供了用于检查的代码</a>。</p><p>最后，提出了对该方法的各种增强。例如，[ <a href="https://arxiv.org/abs/1512.08183" target="_blank" rel="noopener">Li等人，2016年</a> ]将该方法扩展为还包含n元语法特征，而[Thongtan＆Phienthrakul，2019年]建议在计算嵌入投影时也使用余弦相似度代替点积（也提供<a href="https://github.com/tanthongtan/dv-cosine" target="_blank" rel="noopener">Java实现</a>）。</p><h3 id="Doc2VecC"><a href="#Doc2VecC" class="headerlink" title="Doc2VecC"></a>Doc2VecC</h3><p>[ <a href="https://arxiv.org/pdf/1707.02377.pdf" target="_blank" rel="noopener">Chen，2017</a> ]提出了一种有趣的方法，该方法受段向量方法（PV-DM）的分布式存储模型以及平均词嵌入来表示文档的方法的启发。</p><p> <img src="8.png" alt="8"></p><p>图8：Doc2VecC模型的架构</p><p>类似于<em>段落向量</em>，<em>Doc2VecC</em> （通过损坏的文档向量的缩写）由输入层，投影层和输出层组成，以预测目标单词（在上例中为<strong>“ceremony”</strong>）。相邻单词的嵌入(e.g. <strong>“opening”, “for”, “the”</strong>)提供局部上下文，而整个文档的矢量表示（以灰色显示）用作全局上下文。与直接针对每个文档学习唯一矢量的<em>段落矢量</em>相反，<em>Doc2VecC</em> 将每个文档表示为从文档中随机采样的单词嵌入的平均值（例如，位置<em>p</em> 处的<strong>“performance”</strong>，位置<em>q</em> 处的<strong>“praised”</strong> 和<strong>“brazil”</strong>在位置<em>r</em> ）。</p><p>另外，作者选择通过随机删除大部分单词来破坏原始文档，从而仅对其余单词的嵌入进行平均，从而代表文档。这种破坏机制可以在训练期间加快速度，因为它大大减少了反向传播中要更新的参数数量。作者还展示了它是如何引入一种特殊形式的正则化的，他们认为这种形式可导致观察到的性能提高，以情感分析任务，文档分类任务和语义相关性任务为基准，而不是大量的最新技术。文档嵌入技术。</p><p>可以在<a href="https://github.com/mchen24/iclr2017" target="_blank" rel="noopener">公共Github存储库中</a>找到基于C语言的开源实现，用于重现本文中的实验。</p><p>[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016</a> ]还对<em>Skip-thought</em>模型（请参见以下小节）应用了破坏或增加噪声的一般思想，以增加文档的嵌入学习过程以产生更强大的嵌入空间。创建其顺序降噪自动编码器（SDAE）模型。</p><h3 id="Skip-thought-vectors"><a href="#Skip-thought-vectors" class="headerlink" title="Skip-thought vectors"></a>Skip-thought vectors</h3><p>这是在[ <a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Kiros等，2015</a> ]中提出的，这是对<em>word2vec</em> 进行泛化的另一种早期尝试，并且已与<a href="https://github.com/ryankiros/skip-thoughts" target="_blank" rel="noopener">官方的纯Python实现一起发布</a>（并且最近还夸耀了<a href="https://github.com/sanyam5/skip-thoughts" target="_blank" rel="noopener">PyTorch</a>和<a href="https://github.com/tensorflow/models/tree/master/research/skip_thoughts" target="_blank" rel="noopener">TensorFlow的实现</a>）。</p><p>但是，这以另一种直观的方式扩展了<em>word2vec</em> （尤其是<em>skip-gram</em> 体系结构）：基本单元现在是句子，并且已编码的句子用于预测其周围的句子。使用在上述任务上训练的编码器-解码器模型学习矢量表示。作者使用具有GRU激活功能的RNN编码器和具有条件GRU的RNN解码器。训练了两个不同的解码器以用于上一个和下一个句子。</p><p> <img src="9.png" alt="9"></p><p>图9：跳过思路模型。给定一个连续句子元组，对句子$s<em>i$进行编码，并尝试重建上一个句子$s</em>{i- 1}$和下一个句子$s_{i + 1}$</p><p>的<strong>词汇扩展跳</strong>字<em>思维</em>编码器使用单词嵌入层，将输入句子中的每个单词转换为对应的单词嵌入，从而有效地将输入句子转换为单词嵌入序列。该嵌入层也与两个解码器共享。</p><p> <img src="10.png" alt="10"></p><p>图10：在Skip-thought vectors中，句子sᵢ由编码器编码；两个解码器以编码器输出hᵢ的隐藏表示为条件，以预测$s<em>{i - 1}$和$s</em>{i + 1}$[摘自<a href="https://sourcediving.com/building-recipe-skill-representations-using-skip-thought-vectors-8a6e4c38ae6c" target="_blank" rel="noopener">Ammar Zaher的帖子</a> ]</p><p>但是，作者仅使用了20,000个单词的小词汇量，因此在执行各种任务期间可能会遇到许多看不见的单词。为了克服这个问题，通过解决矩阵<em>W</em> 参数化的非正规<em>L2</em> 线性回归损失，可以从在更大的词汇量上训练的词嵌入空间（例如<em>word2vec</em> ）到<em>Skip-thought</em>模型的词嵌入空间中学习映射。此映射。</p><p><strong>应用程序</strong><br>作者演示了使用<em>Skip-thought的</em>向量进行语义相关性，释义检测，图像句子排名，问题类型分类以及四个情感和主观性数据集。[ <a href="http://arno.uvt.nl/show.cgi%3Ffid%3D146003" target="_blank" rel="noopener">Broere，2017</a> ]进一步研究了<em>跳思维</em>句子表示的句法属性，方法是对它们进行逻辑回归训练以预测POS标签和依赖关系。</p><p>[ <a href="https://arxiv.org/abs/1706.03146" target="_blank" rel="noopener">Tang等，2017a</a> ]提出了一种邻域方法，用于<em>Skip-thought</em>，丢弃排序信息并使用单个解码器预测前一句话和下一句话。[ <a href="https://www.groundai.com/project/trimming-and-improving-skip-thought-vectors/1" target="_blank" rel="noopener">Tang et al，2017b</a> ]扩展了这项检查，以提出对模型的三个增强，他们声称使用更快更轻的模型可以提供可比的性能：</p><p>（1）仅学习解码下一个句子</p><p>（2）添加<em>avg  编码器和解码器之间的</em>最大*连接层（作为一种允许进行非线性非参数特征工程的方法）</p><p>（3）执行良好的词嵌入初始化。最后，[ <a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">Gan等，2016</a> ]在广泛的应用中，使用基于分层CNN-LSTM的编码器而非仅基于RNN的编码器<a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">，</a>采用了相同的方法。</p><p>在[ <a href="https://openreview.net/pdf%3Fid%3DH1a37GWCZ" target="_blank" rel="noopener">Lee＆Park，2018</a> ]中提出的另一种变体是通过基于文档结构为每个目标句子选择整个文档中有影响力的句子来学习句子嵌入的，从而使用元数据或文本样式识别句子的依存关系。此外，[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016年</a> ]提出了<em>顺序降噪自动编码器（SDAE）</em>模型，这是一种<em>跳</em>变<em>思想</em>的变体，其中输入数据根据某些噪声函数而被破坏，并且训练该模型以从破坏的数据中恢复原始数据。 。</p><p>有关进一步的非学术阅读<em>跳跃思维</em> 模式，<a href="http://sanyam5.github.io/my-thoughts-on-skip-thoughts/" target="_blank" rel="noopener">Sanyam Agarwa给出了他的博客的方法有很大的详细介绍</a></p><h3 id="FastSent"><a href="#FastSent" class="headerlink" title="FastSent"></a>FastSent</h3><p>[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016年</a> ]提出了一种关于<em>跳跃思维</em>模型的明显简化的变体。<em>FastSent</em> 是一个简单的加法（对数双线性）语句模型，旨在利用相同的信号，但计算成本却低得多。给定某些上下文句子的BOW表示，该模型仅预测相邻句子（也表示为BOW）。更正式地说，<em>FastSent</em> 为模型词汇表中的每个单词<em>w</em> 学习源uᵂ和目标vᵂ嵌入。对于训练例如$S<em>{i- 1}$，$S</em>{i}$，连续句子$S<em>{i+1}$，$S</em>{i- 1}$被表示为它的源的嵌入的总和$s_i = \sum u^w $超过$w∈S_i$ 。$φ（s_i，v^w）$超过</p><p>$w∈ S<em>{i- 1}∪S</em>{i + 1}$，其中φ是SOFTMAX功能。本文附带了<a href="https://github.com/fh295/SentenceRepresentation" target="_blank" rel="noopener">一个官方的Python实现</a>。</p><h3 id="Quick-thought-vectors"><a href="#Quick-thought-vectors" class="headerlink" title="Quick-thought vectors"></a>Quick-thought vectors</h3><p>[ <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">Logeswaran＆Lee，2018</a> ]将文件嵌入任务（即预测句子出现上下文的问题）重新设计为监督分类问题（参见图12b），而不是先前方法的预测任务（参见图12a）。</p><p> <img src="11.png" alt="11"></p><p>图11：快速思考问题的表述（b）与跳过思考方法（a）的对比</p><p>要点是使用当前句子的含义来预测相邻句子的含义，其中含义由从编码函数计算出的句子的嵌入表示；注意，这里学习了两个编码器：<em>f</em> 代表输入语句，<em>g</em> 代表候选项。给定一个输入语句，它由编码器（在这种情况下为RNN）进行编码，但是模型没有生成目标语句，而是从一组候选语句中选择了正确的目标语句。候选集是根据有效的上下文句子（基本事实）和许多其他非上下文句子构建的。最后，构造的训练目标最大程度地为训练数据中的每个句子标识了正确的上下文句子。将以前的句子预测公式看作是从所有可能的句子中选择一个句子，这种新方法可以看作是对预测问题的判别近似。</p><p>作者评估了他们在各种文本分类，释义识别和语义相关性任务上的方法，并提供<a href="https://github.com/lajanugen/S2V" target="_blank" rel="noopener">了官方的Python实现</a>。</p><h3 id="Word-Mover’s-Embedding-WME"><a href="#Word-Mover’s-Embedding-WME" class="headerlink" title="Word Mover’s Embedding (WME)"></a>Word Mover’s Embedding (WME)</h3><p>来自IBM研究的一种非常新的方法是在[ <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Wu et al，2018b</a> ]中提出的<em>Word Mover的嵌入</em>（WME）。<a href="https://github.com/IBM/WordMoversEmbeddings" target="_blank" rel="noopener">提供了一个基于C的官方官方Python封装实现</a>。</p><p>[ <a href="http://proceedings.mlr.press/v37/kusnerb15.pdf" target="_blank" rel="noopener">Kushner et al，2015</a> ]提出了世界<em>移动距离</em>（WMD）；这测量了两个文本文档之间的差异，这是一个文档的嵌入单词<strong>在嵌入空间中</strong>需要“移动” 才能到达另一文档的嵌入单词的最小距离（参见图13a）。另外，[ <a href="https://arxiv.org/pdf/1802.04956.pdf" target="_blank" rel="noopener">Wu等，2018a</a> ]提出了D2KE（到核和嵌入的距离），这是一种从给定距离函数推导正定核的通用方法。</p><p> <img src="12.png" alt="12"></p><p>图12：WMD与WME的对比。（a）WMD测量两个文档<em>x</em> 和y 之间的距离，而（b）WME近似于从WMD导出的带有一组随机文档kernel的核。</p><p>WME基于三个组件来学习长度可变的文本的连续矢量表示形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 以无人监督的方式学习高质量词嵌入的能力（例如，使用*word2vec* ）。</span><br><span class="line">2. 使用WMD基于所述嵌入为文档构造距离度量的能力。</span><br><span class="line">3. 使用D2KE从给定的距离函数导出正定核的能力。</span><br></pre></td></tr></table></figure><p>使用这三个组件，将应用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用D2KE，通过给定分布中*单词移动器的距离*（WMD）到随机文档given的无限维特征图，构造正定*单词移动器的内核（WMK）。由于使用了WMD，因此特征图考虑了预训练单词嵌入所给出的语义空间中文档之间各个单词的对齐方式（请参见图12b）。</span><br><span class="line">2. 基于该内核，通过该内核的随机特征近似推导嵌入的文档，其内积近似于精确的内核计算。</span><br></pre></td></tr></table></figure><p>该框架是可扩展的，因为它的两个构件<em>word2vec</em> 和WMD可以用其他技术代替，例如<em>GloVe</em> （用于词嵌入）或S-WMD（用于将词嵌入空间转换为文档距离度量）。</p><p>作者在9个真实世界中的文本分类任务和22个文本相似性任务上对WME进行了评估，并证明了WME与其他最新技术始终如一地匹配，甚至优于其他最新技术。</p><h3 id="Sentence-BERT-SBERT"><a href="#Sentence-BERT-SBERT" class="headerlink" title="Sentence-BERT (SBERT)"></a>Sentence-BERT (SBERT)</h3><p>NLP的2018年以Transformer的兴起为标志，最新的神经语言模型受到[ <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Vaswani et al 2017</a> ]中提出的Transformer模型的启发-序列模型同时消除了卷积和重复发生，而是将注意力转移到序列表示中。这个蓬勃发展的系列包括BERT（及其扩展名），GPT（1和2）以及XL风味的Transformer。</p><p>这些模型生成输入令牌（通常为子单词单元）的上下文嵌入，每个令牌都注入了其邻域的信息，但并非旨在为输入序列生成丰富的嵌入空间。BERT甚至有一个特殊的[CLS]令牌，其输出嵌入用于分类任务，但对于其他任务而言，输入序列的嵌入仍然很差。[ <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Reimers＆Gurevych，2019年</a> ]</p><p><em>Sentence-BERT</em> ，在[ <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Reimers＆Gurevych，2019</a> ]中提出，并附带<a href="https://github.com/UKPLab/sentence-transformers" target="_blank" rel="noopener">一个Python实现</a>，旨在通过使用暹罗和三元组网络结构来派生可以使用余弦相似度进行比较的语义有意义的句子嵌入，以适应BERT体系结构（请参见Fifure 14）。</p><p><img src="13.png" alt="13"></p><p>图14：针对分类目标（左）和推理（右）的训练中的SBERT架构</p><h2 id="有监督的向量嵌入"><a href="#有监督的向量嵌入" class="headerlink" title="有监督的向量嵌入"></a>有监督的向量嵌入</h2><p><code>上一节中介绍的无监督方法使我们可以从大型未标记的语料库中学习有用的表示形式。这种方法并非自然语言处理所独有，而是通过设计学习目标来学习学习表示形式，这些学习目标利用了数据中可自由使用的标签。因此，这些方法的强度和鲁棒性不仅在很大程度上取决于学习框架，而且还取决于人工设计的学习目标要求或带来对有意义的特征或知识的学习的良好程度，这些特征或知识在各种下游任务中将是有用的。例如，我们希望通过单词和文档嵌入空间可以很好地捕获语义和句法信息。</code></p><p><code>学习数据有意义的表示法（在我们的情况下是单词序列）的对比方法是利用显式标签（几乎总是由人类注释者以某种方式生成）。在这里，与各种任务的相关性取决于显式任务和用于最终应用程序的标签的接近程度，并且再次取决于此任务带来了对通用特性和知识的学习程度。</code></p><p><code>我们将看到有监督的方法，从直接利用特定标记任务来学习表示形式的方法，到重组任务或从中提取新标记任务以引发更好表示的方法。</code></p><p><strong>通过标签数据学习文本嵌入</strong></p><p>已经进行了各种尝试来使用标记的或结构化的数据来学习句子表示。具体来说，[ <a href="https://www.aclweb.org/anthology/D14-1179" target="_blank" rel="noopener">Cho等，2014a</a> ]和[ <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">Sutskever等，2014</a> ]可能是首次尝试使用编码器/解码器方法来显式学习带有标记数据的句子/短语嵌入；第一个使用<em>Europarl</em> （统计机器翻译的平行短语语料库），第二个使用WMT-14数据集中的英语到法语的翻译任务。[ <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Wieting et al，2015</a> ]和[Wieting＆Gimpel，2017] 提出了另一种此类显着尝试，其中共同学习了单词嵌入及其在文档嵌入中的映射，以最大程度地减少了复述对之间的余弦相似度（来自<a href="http://paraphrase.org/%23/#/" target="_blank" rel="noopener">PPDB数据集</a>） 。[ <a href="https://arxiv.org/pdf/1504.00548.pdf" target="_blank" rel="noopener">Hill等，2015</a> ]训练了神经语言模型，以将字典定义映射到由这些定义定义的单词的预训练单词嵌入。最后，[ <a href="https://www.aclweb.org/anthology/D17-1070.pdf" target="_blank" rel="noopener">Conneau等，2017</a> ]在斯坦福大学自然语言推理任务上训练了各种体系结构的NN编码器（请参见图16）。</p><p> <img src="14.png" alt="14"></p><p>图15：通用的NLI训练方案</p><h3 id="文档相似性的上下文嵌入"><a href="#文档相似性的上下文嵌入" class="headerlink" title="文档相似性的上下文嵌入"></a>文档相似性的上下文嵌入</h3><p>上述方法的一种特定情况是由文档相似性驱动的。[ <a href="https://www.aclweb.org/anthology/P16-1036" target="_blank" rel="noopener">Das等，2016</a> ]展示了文档嵌入，这些嵌入是通过针对社区Q / A的暹罗网络使两个文档之间的相似度最大化的。（见图17）</p><p> <img src="15.png" alt="png"></p><p>图16：SCQA网络由重复的卷积，最大池和ReLU层以及一个完全连接的层组成。权重W1到W5在子网之间共享。</p><p>同样，[ <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Nicosia＆Moschitti，2017</a> ]使用暹罗网络在学习二进制文本相似性的同时产生单词表示，同时考虑相同类别中的示例相似。（参见图18）</p><p> <img src="16.png" alt="16"></p><p>图17：[ <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Nicosia＆Moschitti，2017</a> ] 中的暹罗网络架构。每个句子的单词嵌入由3个双向GRU的堆栈使用。两个网络分支共享参数权重。</p><p>跨语言降<strong>秩岭回归（Cr5）</strong>[Josifoski et al，2019]引入了一种方法，用于将以任何语言编写的文档嵌入到一个独立于语言的向量空间中。这是通过训练基于岭回归的分类器来完成的，该分类器使用特定于语言的词袋功能来预测给定文档所涉及的概念。当将学习的权重矩阵约束为低等级时，作者表明可以将其作为因素来获得从特定于语言的词袋到独立于语言的嵌入的期望映射。<a href="https://github.com/epfl-dlab/Cr5" target="_blank" rel="noopener">提供了一个官方的Python实现</a>。</p><h3 id="特定于任务的监督文档嵌入"><a href="#特定于任务的监督文档嵌入" class="headerlink" title="特定于任务的监督文档嵌入"></a>特定于任务的监督文档嵌入</h3><p>一种用于生成文档嵌入的常见监督方法是使用各种神经网络体系结构，学习将单词向量映射到文档向量的合成运算符；它们被传递给受监督的任务，并依赖于类标签，以便在合成权重之间反向传播（请参见图19）。</p><p>因此，网络的几乎所有隐藏层都可以被视为产生输入文档的向量嵌入，其中直到该层的网络前缀都是从单词向量到嵌入空间的学习映射。在[ <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Wieting等人，2015</a> ]中可以找到对基于单词向量和监督学习任务的学习句子向量的不同方法的严格检查。</p><p> <img src="17.png" alt="17"></p><p>图18：神经网络隐式学习将单词嵌入序列映射到文档嵌入</p><p>请注意，虽然所使用的单词嵌入可以预先生成并且与任务无关（至少在一定程度上），但从它们中学到的文档嵌入映射是特定于任务的。尽管这些方法对相关任务很有用，但至少在理论上，与无监督方法相比，此方法势必不那么健壮和通用。[ <a href="https://arxiv.org/pdf/1506.06726.pdf" target="_blank" rel="noopener">Kiros等，2015</a> ]</p><p>值得注意的用途包括使用RNN进行情感分类[Socher等，2013]，使用CNN进行各种文本分类[Kalchbrenner等，2014] [Kim，2014]以及使用递归卷积神经网络进行机器翻译和文本分类[Cho等]等，2014a，2014b] [Zhao等，2015]。</p><ul><li><p><strong>GPT</strong><br>[ <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener">Radford等人，2018</a> ] <a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener">提出了一种</a><a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener"><em>生成式预训练</em></a><a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener">（GPT）方法</a>（<a href="https://github.com/openai/finetune-transformer-lm" target="_blank" rel="noopener">伴随Python实现</a>），使用[ <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Vaswani等人2017</a> ]中介绍的转换模型，将无监督和有监督的表示学习结合起来，学习无监督语言对未标记的语料库进行建模，然后使用监督数据分别微调其在每个任务中的使用。<a href="https://openai.com/blog/better-language-models/" target="_blank" rel="noopener">他们随后</a>在[ <a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener">Radford et al，2019</a> ]中<a href="https://openai.com/blog/better-language-models/" target="_blank" rel="noopener">介绍了GPT-2</a>，重点是加强他们工作中的无监督学习部分，并再次<a href="https://github.com/openai/gpt-2" target="_blank" rel="noopener">发布了正式的Python实现</a>。</p></li><li><p><strong>深度语义相似性模型（DSSM）</strong><br><a href="https://www.microsoft.com/en-us/research/project/dssm/" target="_blank" rel="noopener">作为Microsoft研究项目</a>，DSSM是一种深度神经网络建模技术，用于表示连续语义空间中的文本字符串并为两个文本字符串之间的语义相似性建模（请参见图20）。</p><p><img src="19.png" alt="19"></p></li></ul><p>图19：DSSM神经网络的架构</p><p>除其他应用程序外，DSSM还用于开发潜在语义模型，该模型将不同类型的实体（例如查询和文档）投影到公共的低维语义空间中，以用于各种机器学习任务，例如排名和分类。例如，[ <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf" target="_blank" rel="noopener">Huang et al，2013</a> ]使用它将查询和文档投影到一个公共的低维空间，在该空间中，给定查询的文档的相关性被计算为它们之间的距离。</p><p>实现包括<a href="https://kishorepv.github.io/DSSM/" target="_blank" rel="noopener">TensorFlow</a>，<a href="https://github.com/airalcorn2/Deep-Semantic-Similarity-Model" target="_blank" rel="noopener">Keras</a>和<a href="https://github.com/nishnik/Deep-Semantic-Similarity-Model-PyTorch" target="_blank" rel="noopener">2个PyTorch </a><a href="https://github.com/moinnadeem/CDSSM" target="_blank" rel="noopener">变化</a>。</p><h3 id="联合学习句子表示"><a href="#联合学习句子表示" class="headerlink" title="联合学习句子表示"></a>联合学习句子表示</h3><p>[ <a href="https://arxiv.org/pdf/1810.00681v1.pdf" target="_blank" rel="noopener">Ahmad et al，2018</a> ]建议从多个文本分类任务中共同学习句子表示，并将它们与预训练的单词级和句子级编码器结合使用，可以得到健壮的句子表示，可用于迁移学习</p><p> <img src="18.png" alt="18"></p><p>图20：使用辅助任务共同学习句子嵌入</p><p>[ <a href="https://www.semanticscholar.org/paper/Learning-Sentence-Embeddings-with-Auxiliary-Tasks-Yu-Jiang/2d38f7aab07d4435b2110602db4138ef20da4cc0" target="_blank" rel="noopener">Yu＆Jiang，2016</a> ]类似地表明，使用两个辅助任务来帮助诱导句子嵌入在情感分类中跨域的工作很有效，与情感分类器本身一起共同学习该句子的嵌入（图21）。</p><p>在[ <a href="https://arxiv.org/pdf/1803.11175.pdf" target="_blank" rel="noopener">Cer等人，2018a</a> ]和[ <a href="https://www.aclweb.org/anthology/D18-2029/" target="_blank" rel="noopener">Cer等人，2018b</a> ]中提出的</p><p><strong>通用句子编码器</strong>，并伴随<a href="https://tfhub.dev/google/universal-sentence-encoder/2" target="_blank" rel="noopener">着TensorFlow实现</a>，该方法实际上包括两种可能的句子表示学习模型：<em>Transformer</em> 模型和<em>Deep Averaging Network（DAN） ）</em>模型（请参见图22）。两者都旨在允许多任务学习，并且支持的任务包括（1）作为无监督学习的<em>基调思维</em>任务；（2）对话输入响应任务，用于包含已解析的对话数据；（3）用于监督数据训练的分类任务（请参阅前面的小节）。作者专注于具有转移学习任务的实验，并对照简单的CNN和DAN基准对他们的模型进行了基准测试。该方法后来<a href="https://ai.googleblog.com/2019/07/multilingual-universal-sentence-encoder.html" target="_blank" rel="noopener">扩展为解决多语言设置</a>。</p><p>的<em>变压器</em>模型直接基于在[提出的变压器模型<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">瓦斯瓦尼等人2017</a> ]，所述第一序列转导模型完全基于注意，取代在编码器-解码器的体系结构最常用的多双头自关注的复发性层（参见图22a）。</p><p>该模型使用转换器体系结构的编码子图构造句子嵌入。编码器使用注意力来计算句子中单词的上下文感知表示，同时考虑其他单词的顺序和身份。将上下文感知的单词表示形式平均在一起，以获得句子级的嵌入。</p><p>  <img src="20.png" alt="png"></p><p>图22：通用句子编码器的两种模型：（a）变压器和（b）DAN</p><p>相反，在[ <a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">Iyyer et al，2015</a> ]中提出的DAN模型中，单词和<a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">二元语法的</a>输入嵌入首先被平均在一起，然后通过前馈深度神经网络（DNN）生成句子嵌入（见图22b）。 。</p><p><strong>GenSen</strong><br>与通用句子编码器非常相似，[ <a href="https://arxiv.org/pdf/1804.00079.pdf" target="_blank" rel="noopener">Subramanian et al，2018</a> ]中介绍的GenSen方法与<a href="https://github.com/Maluuba/gensen" target="_blank" rel="noopener">官方Python实现一起</a>，结合了多个有监督和无监督的学习任务，以训练基于RNN w / GRU的编码器-解码器模型，嵌入被提取。支持的四个任务是：（1）<em>跳跳</em>向量，（2）神经机器翻译，（3）选区解析和（4）自然语言推论（三向分类问题；给定前提和假设句子，目的是将他们的关系归类为牵连，矛盾或中立。<a href="https://github.com/Maluuba/gensen" target="_blank" rel="noopener">正式的Python实现已发布</a>。</p><h2 id="如何选择各种嵌入方法"><a href="#如何选择各种嵌入方法" class="headerlink" title="如何选择各种嵌入方法"></a>如何选择各种嵌入方法</h2><p>我在这里没有简单的答案，但是这里有一些可能的要点：</p><ol><li><strong>平均单词向量是一个很强的基准</strong>，因此一个好主意是通过着重于生成非常好的单词向量并首先简单地对其求<strong>平均</strong>来开始寻求好的文档嵌入。毫无疑问，文档嵌入的强大功能大部分来自构建它们的词向量，我可以肯定地说，在前进之前，有大量信息要优化。您可以尝试不同的预训练词嵌入，探索哪些源域和哪些方法（例如word2vec，GloVe，BERT，ELMo）可以更好地捕获所需的信息类型。然后，通过尝试使用不同的汇总运算符或其他技巧（如[ <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">Arora等，2016</a> ]中的那些技巧）稍微扩展一下可能已足够。</li><li><strong>性能可能是一个关键考虑因素</strong>，尤其是在方法之间没有明确领导者的情况下。在这种情况下，<a href="https://translate.googleusercontent.com/translate_f#ecd3" target="_blank" rel="noopener">平均单词向量</a>和一些精益方法（如<a href="https://translate.googleusercontent.com/translate_f#e3d4" target="_blank" rel="noopener"><em>send2vec</em></a>和<a href="https://translate.googleusercontent.com/translate_f#e6e8" target="_blank" rel="noopener"><em>FastSent</em></a>）都是不错的选择。相反，在使用<em>doc2vec</em> 时，给定每个句子所需的实时向量表示推断，可能会因应用程序限制而证明代价高昂。<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">SentEval</a>是[ <a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Conneau＆Kiela，2018</a> ]中提出的<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">用于句子表示的评估工具包，</a>在这种情况下值得一提。</li><li><strong>考虑学习目标对您任务的有效性</strong>。上面介绍的不同的自我监督技术以不同的方式扩展<em>了分布假设</em>，而<em>Skip-thought</em>和<em>快速思想则</em>基于句子/段落在文档中的距离对它们之间的紧密关系进行建模。这可能对书籍，文章和社交媒体帖子而言微不足道，但可能不适用于其他文本序列，尤其是结构化文本序列，因此可能会将您的文档投影到不适用于它们的嵌入空间中。同样，WME依赖的单词对齐方法可能并不适用于所有情况。</li><li><strong>开源实现非常丰富</strong>，因此针对您的任务对不同方法进行基准测试可能是可行的。</li><li><strong>没有明确的特定任务负责人。</strong>论文经常针对分类，释义和语义相关性任务对不同的方法进行基准测试。然而，上述结论是在考虑有关该主题的全部文献时，特别是在考虑了2018年的两个最新基准的结果时得出的，[ <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">Logeswaran＆Lee，2018</a> ]首先提出了他们的<em>快速思考方法。</em>第二种方法是[ <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Wu et al，2018b</a> ]，这是他们关于<em>Word Mover嵌入</em>的论文的一部分。</li></ol><p>最后，我发现它值得一提的是<em>关键词中包含的代码</em>有<a href="https://paperswithcode.com/task/document-embedding" target="_blank" rel="noopener">一个专门的文件嵌入任务</a>，而且Facebook的研究具有开源<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">SentEval，评估工具包句子表示</a>在[呈现<a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Conneau＆Kiela，2018</a> ]</p><p>本文章翻译自原文[原文连接]<a href="https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d.其对目前大概的文本嵌入方式进行了总结" target="_blank" rel="noopener">https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d.其对目前大概的文本嵌入方式进行了总结</a>. </p><p>我后面将会把最新的文本嵌入方法进行更新.并且计划将上述文本表示进行实践.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Agibetov, A., Blagec, K., Xu, H., &amp; Samwald, M. (2018). <a href="https://link.springer.com/article/10.1186/s12859-018-2496-4" target="_blank" rel="noopener">Fast and scalable neural embedding models for biomedical sentence classification</a>. <em>BMC bioinformatics</em>, <em>19</em>(1), 541.</p><p>Ahmad, W. U., Bai, X., Peng, N., &amp; Chang, K. W. (2018). <a href="https://arxiv.org/pdf/1810.00681v1.pdf" target="_blank" rel="noopener">Learning Robust, Transferable Sentence Representations for Text Classification</a>. <em>arXiv preprint arXiv:1810.00681</em>.</p><p>Arora, S., Liang, Y., &amp; Ma, T. (2016). <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">A simple but tough-to-beat baseline for sentence embeddings</a>. [<a href="https://github.com/peter3125/sentence2vec" target="_blank" rel="noopener">unofficial implementation</a>]</p><p>Bengio, Y., Ducharme, R., Vincent, P., &amp; Jauvin, C. (2003). <a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">A neural probabilistic language model</a>. <em>Journal of machine learning research</em>, <em>3</em>(Feb), 1137–1155.</p><p>B. Broere, (2017). <a href="http://arno.uvt.nl/show.cgi?fid=146003" target="_blank" rel="noopener">Syntactic properties of skip-thought vectors</a>. <em>Master’s thesis, Tilburg University</em>.</p><p>Cer, D., Yang, Y., Kong, S. Y., Hua, N., Limtiaco, N., John, R. S., … &amp; Sung, Y. H. (2018). <a href="https://arxiv.org/pdf/1803.11175.pdf" target="_blank" rel="noopener">Universal sentence encoder</a>. <em>arXiv preprint arXiv:1803.11175</em>.</p><p>Cer, D., Yang, Y., Kong, S. Y., Hua, N., Limtiaco, N., John, R. S., … &amp; Strope, B. (2018, November). <a href="https://www.aclweb.org/anthology/D18-2029/" target="_blank" rel="noopener">Universal sentence encoder for English</a>. In <em>Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations</em> (pp. 169–174).</p><p>Chen, M. (2017). <a href="https://arxiv.org/pdf/1707.02377.pdf" target="_blank" rel="noopener">Efficient vector representation for documents through corruption</a>. <em>arXiv preprint arXiv:1707.02377</em>.</p><p>Chen, Q., Peng, Y., &amp; Lu, Z. (2018). <a href="https://arxiv.org/pdf/1810.09302.pdf" target="_blank" rel="noopener">BioSentVec: creating sentence embeddings for biomedical texts</a>. arXiv preprint arXiv:1810.09302.</p><p>Cho, K., Van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., &amp; Bengio, Y. (2014). <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning phrase representations using RNN encoder-decoder for statistical machine translation</a>. <em>arXiv preprint arXiv:1406.1078</em>.</p><p>Cho, K., Van Merriënboer, B., Bahdanau, D., &amp; Bengio, Y. (2014). <a href="https://arxiv.org/abs/1409.1259" target="_blank" rel="noopener">On the properties of neural machine translation: Encoder-decoder approaches</a>. <em>arXiv preprint arXiv:1409.1259</em>.</p><p>Conneau, A., Kiela, D., Schwenk, H., Barrault, L., &amp; Bordes, A. (2017). <a href="https://www.aclweb.org/anthology/D17-1070.pdf" target="_blank" rel="noopener">Supervised learning of universal sentence representations from natural language inference data</a>. <em>arXiv preprint arXiv:1705.02364</em>.</p><p>Conneau, A., &amp; Kiela, D. (2018). <a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Senteval: An evaluation toolkit for universal sentence representations</a>. <em>arXiv preprint arXiv:1803.05449</em>.</p><p>Dai, A. M., Olah, C., &amp; Le, Q. V. (2015). <a href="https://arxiv.org/pdf/1507.07998.pdf" target="_blank" rel="noopener">Document embedding with paragraph vectors</a>. <em>arXiv preprint arXiv:1507.07998</em>.</p><p>Das, A., Yenala, H., Chinnakotla, M., &amp; Shrivastava, M. (2016, August). <a href="https://www.aclweb.org/anthology/P16-1036" target="_blank" rel="noopener">Together we stand: Siamese networks for similar question retrieval</a>. In <em>Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</em> (pp. 378–387).</p><p>Gan, Z., Pu, Y., Henao, R., Li, C., He, X., &amp; Carin, L. (2016). Unsupervised learning of sentence representations using convolutional neural networks. <em>arXiv preprint arXiv:1611.07897</em>.</p><p>Gan, Z., Pu, Y., Henao, R., Li, C., He, X., &amp; Carin, L. (2016). <a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">Learning generic sentence representations using convolutional neural networks</a>. <em>arXiv preprint arXiv:1611.07897</em>.</p><p>Gupta, P., Pagliardini, M., &amp; Jaggi, M. (2019). <a href="https://www.aclweb.org/anthology/N19-1098" target="_blank" rel="noopener">Better Word Embeddings by Disentangling Contextual n-Gram Information</a>. <em>arXiv preprint arXiv:1904.05033</em>.</p><p>Harris, Z. S. (1954). Distributional structure. Word, 10(2–3), 146–162.</p><p>Hill, F., Cho, K., Korhonen, A., &amp; Bengio, Y. (2015). <a href="https://arxiv.org/pdf/1504.00548.pdf" target="_blank" rel="noopener">Learning to understand phrases by embedding the dictionary</a>. <em>Transactions of the Association for Computational Linguistics</em>, <em>4</em>, 17–30.</p><p>Hill, F., Cho, K., &amp; Korhonen, A. (2016). <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Learning distributed representations of sentences from unlabelled data</a>. <em>arXiv preprint arXiv:1602.03483</em>.</p><p>Huang, P. S., He, X., Gao, J., Deng, L., Acero, A., &amp; Heck, L. (2013, October). <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf" target="_blank" rel="noopener">Learning deep structured semantic models for web search using clickthrough data</a>. In <em>Proceedings of the 22nd ACM international conference on Information &amp; Knowledge Management</em> (pp. 2333–2338). ACM.</p><p>Iyyer, M., Manjunatha, V., Boyd-Graber, J., &amp; Daumé III, H. (2015). <a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">Deep unordered composition rivals syntactic methods for text classification</a>. In <em>Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)</em> (Vol. 1, pp. 1681–1691).</p><p>Josifoski, M., Paskov, I. S., Paskov, H. S., Jaggi, M., &amp; West, R. (2019, January). <a href="https://dl.acm.org/citation.cfm?id=3291023" target="_blank" rel="noopener">Crosslingual Document Embedding as Reduced-Rank Ridge Regression</a>. In <em>Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining</em> (pp. 744–752). ACM.</p><p>Kalchbrenner, N., Grefenstette, E., &amp; Blunsom, P. (2014). A convolutional neural network for modelling sentences. <em>arXiv preprint arXiv:1404.2188</em>.</p><p>Kenter, T., Borisov, A., &amp; De Rijke, M. (2016). <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Siamese cbow: Optimizing word embeddings for sentence representations</a>. <em>arXiv preprint arXiv:1606.04640</em>.</p><p>Kim, Yoon. “Convolutional neural networks for sentence classification.” <em>arXiv preprint arXiv:1408.5882</em> (2014).</p><p>Kiros, R., Zhu, Y., Salakhutdinov, R. R., Zemel, R., Urtasun, R., Torralba, A., &amp; Fidler, S. (2015). <a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Skip-thought vectors</a>. In <em>Advances in neural information processing systems</em> (pp. 3294–3302).</p><p>Kusner, M., Sun, Y., Kolkin, N., &amp; Weinberger, K. (2015, June). <a href="http://proceedings.mlr.press/v37/kusnerb15.pdf" target="_blank" rel="noopener">From word embeddings to document distances</a>. In <em>International conference on machine learning</em> (pp. 957–966).</p><p>Lau, J. H., &amp; Baldwin, T. (2016). <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">An empirical evaluation of doc2vec with practical insights into document embedding generation</a>. <em>arXiv preprint arXiv:1607.05368</em>. [<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">code</a>]</p><p>Le, Q., &amp; Mikolov, T. (2014, January). <a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Distributed representations of sentences and documents</a>. In <em>International conference on machine learning</em> (pp. 1188–1196).</p><p>Lee, T., &amp; Park, Y. (2018). <a href="https://openreview.net/forum?id=H1a37GWCZ" target="_blank" rel="noopener">UNSUPERVISED SENTENCE EMBEDDING USING DOCUMENT STRUCTURE-BASED CONTEXT</a>.</p><p>Logeswaran, L., &amp; Lee, H. (2018). <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">An efficient framework for learning sentence representations</a>. arXiv preprint arXiv:1803.02893.</p><p>Li, B., Liu, T., Du, X., Zhang, D., &amp; Zhao, Z. (2015). <a href="https://arxiv.org/abs/1512.08183" target="_blank" rel="noopener">Learning document embeddings by predicting n-grams for sentiment classification of long movie reviews</a>. <em>arXiv preprint arXiv:1512.08183</em>.</p><p>Liu, Y., &amp; Lapata, M. (2018). Learning structured text representations. Transactions of the Association for Computational Linguistics, 6, 63–75.</p><p>Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). <a href="https://arxiv.org/pdf/1301.3781.pdf" target="_blank" rel="noopener">Efficient estimation of word representations in vector space</a>. arXiv preprint arXiv:1301.3781.</p><p>Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Distributed representations of words and phrases and their compositionality</a>. In <em>Advances in neural information processing systems</em> (pp. 3111–3119).</p><p>Nicosia, M., &amp; Moschitti, A. (2017, August). <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Learning contextual embeddings for structural semantic similarity using categorical information</a>. In <em>Proceedings of the 21st Conference on Computational Natural Language Learning (CoNLL 2017)</em>(pp. 260–270).</p><p>Pagliardini, M., Gupta, P., &amp; Jaggi, M. (2017). <a href="https://aclweb.org/anthology/N18-1049" target="_blank" rel="noopener">Unsupervised learning of sentence embeddings using compositional n-gram features</a>. <em>arXiv preprint arXiv:1703.02507</em>.</p><p>Pennington, J., Socher, R., &amp; Manning, C. (2014, October). <a href="https://www.aclweb.org/anthology/D14-1162" target="_blank" rel="noopener">Glove: Global vectors for word representation</a>. In <em>Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP)</em> (pp. 1532–1543).</p><p>Radford, A., Narasimhan, K., Salimans, T., &amp; Sutskever, I. (2018). <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener"><em>Improving language understanding with unsupervised learning</em></a>. Technical report, OpenAI.</p><p>Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., &amp; Sutskever, I. (2019). <a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener">Language models are unsupervised multitask learners</a>. <em>OpenAI Blog</em>, <em>1</em>(8).</p><p>Reimers, N., &amp; Gurevych, I. (2019). <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</a>. <em>arXiv preprint arXiv:1908.10084</em>.</p><p>Rudolph, M., Ruiz, F., Athey, S., &amp; Blei, D. (2017). Structured embedding models for grouped data. In <em>Advances in neural information processing systems</em> (pp. 251–261).</p><p>Salton, G., &amp; Buckley, C. (1988). <a href="http://pmcnamee.net/744/papers/SaltonBuckley.pdf" target="_blank" rel="noopener">Term-weighting approaches in automatic text retrieval</a>. <em>Information processing &amp; management</em>, <em>24</em>(5), 513–523.</p><p>Sinoara, R. A., Camacho-Collados, J., Rossi, R. G., Navigli, R., &amp; Rezende, S. O. (2019). <a href="https://www.sciencedirect.com/science/article/pii/S0950705118305124" target="_blank" rel="noopener">Knowledge-enhanced document embeddings for text classification</a>. <em>Knowledge-Based Systems</em>, <em>163</em>, 955–971.</p><p>Socher, R., Perelygin, A., Wu, J., Chuang, J., Manning, C. D., Ng, A., &amp; Potts, C. (2013, October). <a href="https://nlp.stanford.edu/~socherr/EMNLP2013_RNTN.pdf" target="_blank" rel="noopener">Recursive deep models for semantic compositionality over a sentiment treebank</a>. In <em>Proceedings of the 2013 conference on empirical methods in natural language processing</em> (pp. 1631–1642).</p><p>Subramanian, S., Trischler, A., Bengio, Y., &amp; Pal, C. J. (2018). <a href="https://arxiv.org/pdf/1804.00079.pdf" target="_blank" rel="noopener">Learning general purpose distributed sentence representations via large scale multi-task learning</a>. <em>arXiv preprint arXiv:1804.00079</em>.</p><p>Sutskever, I., Vinyals, O., &amp; Le, Q. V. (2014). <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">Sequence to sequence learning with neural networks</a>. In <em>Advances in neural information processing systems</em> (pp. 3104–3112).</p><p>Tang, S., Jin, H., Fang, C., Wang, Z., &amp; de Sa, V. R. (2017). <a href="https://arxiv.org/abs/1706.03146" target="_blank" rel="noopener">Rethinking skip-thought: A neighborhood based approach</a>. <em>arXiv preprint arXiv:1706.03146</em>.</p><p>Tang, S., Jin, H., Fang, C., Wang, Z., &amp; de Sa, V. R. (2017). <a href="https://www.groundai.com/project/trimming-and-improving-skip-thought-vectors/1" target="_blank" rel="noopener">Trimming and improving skip-thought vectors</a>. <em>arXiv preprint arXiv:1706.03148</em>.</p><p>Thongtan, T., &amp; Phienthrakul, T. (2019, July). Sentiment Classification using Document Embeddings trained with Cosine Similarity. In <em>Proceedings of the 57th Conference of the Association for Computational Linguistics: Student Research Workshop</em> (pp. 407–414).</p><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … &amp; Polosukhin, I. (2017). <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention is all you need</a>. <em>In Advances in neural information processing systems</em> (pp. 5998–6008).</p><p>Wieting, J., Bansal, M., Gimpel, K., &amp; Livescu, K. (2015). <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Towards universal paraphrastic sentence embeddings</a>. arXiv preprint arXiv:1511.08198.</p><p>Wieting, J., &amp; Gimpel, K. (2017). Revisiting recurrent networks for paraphrastic sentence embeddings. <em>arXiv preprint arXiv:1705.00364</em>.</p><p>Wu, L., Yen, I. E. H., Xu, F., Ravikumar, P., &amp; Witbrock, M. (2018). <a href="https://arxiv.org/pdf/1802.04956.pdf" target="_blank" rel="noopener">D2ke: From distance to kernel and embedding</a>. <em>arXiv preprint arXiv:1802.04956</em>.</p><p>Wu, L., Yen, I. E., Xu, K., Xu, F., Balakrishnan, A., Chen, P. Y., … &amp; Witbrock, M. J. (2018). <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Word Mover’s Embedding: From Word2Vec to Document Embedding</a>. <em>arXiv preprint arXiv:1811.01713</em>.</p><p>Yu, J., &amp; Jiang, J. (2016, November). <a href="https://www.semanticscholar.org/paper/Learning-Sentence-Embeddings-with-Auxiliary-Tasks-Yu-Jiang/2d38f7aab07d4435b2110602db4138ef20da4cc0" target="_blank" rel="noopener">Learning sentence embeddings with auxiliary tasks for cross-domain sentiment classification</a>. In <em>Proceedings of the 2016 conference on empirical methods in natural language processing</em> (pp. 236–246).</p><p>Zhang, Y., Chen, Q., Yang, Z., Lin, H., &amp; Lu, Z. (2019). BioWordVec, improving biomedical word embeddings with subword information and MeSH. <em>Scientific data</em>, <em>6</em>(1), 52.</p><p>Zhao, H., Lu, Z., &amp; Poupart, P. (2015, June). Self-adaptive hierarchical sentence model. In <em>Twenty-Fourth International Joint Conference on Artificial Intelligence</em>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[原文连接]&lt;a href=&quot;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://towardsd
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/08/01/docker/"/>
    <id>http://yoursite.com/2020/08/01/docker/</id>
    <published>2020-08-01T01:57:15.000Z</published>
    <updated>2021-04-01T13:19:17.785Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://search.bilibili.com/video?keyword=elastic" target="_blank" rel="noopener">参考b站教程</a></p><h2 id="一、Docker-介绍"><a href="#一、Docker-介绍" class="headerlink" title="一、Docker 介绍"></a>一、Docker 介绍</h2><h3 id="1-安装需要的包"><a href="#1-安装需要的包" class="headerlink" title="1. 安装需要的包"></a>1. 安装需要的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">想安装Docker，需要先将依赖的环境全部下载下来</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure><h3 id="2-指定-Docker-镜像源"><a href="#2-指定-Docker-镜像源" class="headerlink" title="2. 指定 Docker 镜像源"></a>2. 指定 Docker 镜像源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">.更换国内软件源，推荐中国科技大学的源，稳定速度快（可选）</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="3-添加-GPG-密钥"><a href="#3-添加-GPG-密钥" class="headerlink" title="3.添加 GPG 密钥"></a>3.添加 GPG 密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例</span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">$</span><span class="bash">(lsb_release -cs) stable<span class="string">"</span></span></span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><h3 id="4-启动-Docker-并测试"><a href="#4-启动-Docker-并测试" class="headerlink" title="4. 启动 Docker 并测试"></a>4. 启动 Docker 并测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker</span><br><span class="line"><span class="meta">#</span><span class="bash">启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机自动启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="二、Docker-的中央仓库"><a href="#二、Docker-的中央仓库" class="headerlink" title="二、Docker 的中央仓库"></a>二、Docker 的中央仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。</span><br><span class="line">https://hub.docker.com/</span><br><span class="line">2.国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。</span><br><span class="line">https://c.163yun.com/hub#/home </span><br><span class="line">http://hub.daocloud.io/ （推荐使用）</span><br><span class="line">3.在公司内部会采用私服的方式拉取镜像（添加配置）</span><br><span class="line"><span class="meta">#</span><span class="bash">需要创建 /etc/docker/daemon.json，并添加如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors":["https://registry.docker-cn.com"],</span><br><span class="line">"insecure-registries":["ip:port"]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">重启两个服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="三、镜像的操作"><a href="#三、镜像的操作" class="headerlink" title="三、镜像的操作"></a>三、镜像的操作</h2><h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从中央仓库拉取镜像到本地</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">举个栗子:docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></span><br></pre></td></tr></table></figure><h3 id="2-查看本地全部镜像"><a href="#2-查看本地全部镜像" class="headerlink" title="2. 查看本地全部镜像"></a>2. 查看本地全部镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3. 删除本地镜像"></a>3. 删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取</span></span><br><span class="line">docker rmi 镜像的标识</span><br></pre></td></tr></table></figure><h3 id="4-镜像的导入导出"><a href="#4-镜像的导入导出" class="headerlink" title="4. 镜像的导入导出"></a>4. 镜像的导入导出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将本地的镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash">加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"><span class="meta">#</span><span class="bash">修改镜像文件</span></span><br><span class="line">docker tag 镜像id 新镜像名称：版本</span><br></pre></td></tr></table></figure><h2 id="四、容器的操作"><a href="#四、容器的操作" class="headerlink" title="四、容器的操作"></a>四、容器的操作</h2><h3 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1. 运行容器"></a>1. 运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行容器需要定制具体镜像，如果镜像不存在，会直接下载</span><br><span class="line"><span class="meta">#</span><span class="bash">简单操作</span></span><br><span class="line">docker run 镜像的标识|镜像的名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">常用的参数</span></span><br><span class="line">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">-d:代表后台运行容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--name 容器名称:指定容器的名称</span></span><br></pre></td></tr></table></figure><h3 id="2-查看正在运行的容器"><a href="#2-查看正在运行的容器" class="headerlink" title="2. 查看正在运行的容器"></a>2. 查看正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看全部正在运行的容器信息</span><br><span class="line">docker ps [-qa]</span><br><span class="line"><span class="meta">#</span><span class="bash">-a 查看全部的容器，包括没有运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-q 只查看容器的标识</span></span><br></pre></td></tr></table></figure><h3 id="3-查看容器日志"><a href="#3-查看容器日志" class="headerlink" title="3. 查看容器日志"></a>3. 查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看容器日志，以查看容器运行的信息</span><br><span class="line">docker logs -f 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">-f：可以滚动查看日志的最后几行</span></span><br></pre></td></tr></table></figure><h3 id="4-进入容器的内部"><a href="#4-进入容器的内部" class="headerlink" title="4. 进入容器的内部"></a>4. 进入容器的内部</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以进入容器的内部进行操作</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><h3 id="5-复制内容到容器"><a href="#5-复制内容到容器" class="headerlink" title="5. 复制内容到容器"></a>5. 复制内容到容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将宿主机的文件复制到容器内部的指定目录</span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br></pre></td></tr></table></figure><h3 id="6-重启-amp-启动-amp-停止-amp-删除容器"><a href="#6-重启-amp-启动-amp-停止-amp-删除容器" class="headerlink" title="6. 重启 &amp; 启动 &amp; 停止 &amp; 删除容器"></a>6. 重启 &amp; 启动 &amp; 停止 &amp; 删除容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">容器的启动，停止，删除等操作，后续会经常使用到</span><br><span class="line"><span class="meta">#</span><span class="bash">重新启动容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">启动停止运行的容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">停止指定的容器(删除容器前，需要先停止容器)</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">停止全部容器</span></span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"><span class="meta">#</span><span class="bash">删除指定容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">删除全部容器</span></span><br><span class="line">docker rm $(docker ps -qa)</span><br></pre></td></tr></table></figure><h2 id="五、Docker-应用"><a href="#五、Docker-应用" class="headerlink" title="五、Docker 应用"></a>五、Docker 应用</h2><h3 id="1-docker-安装-tomcat"><a href="#1-docker-安装-tomcat" class="headerlink" title="1.docker 安装 tomcat"></a>1.docker 安装 tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行Tomcat容器，为部署ssm工程做准备</span><br><span class="line"> </span><br><span class="line">docker run -d -p 8080:8080 --name tomcat  daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line"><span class="meta">#</span><span class="bash">或者已经下载了tomcat镜像</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat 镜像的标识</span><br></pre></td></tr></table></figure><h3 id="2-运行-MySQL-容器"><a href="#2-运行-MySQL-容器" class="headerlink" title="2. 运行 MySQL 容器"></a>2. 运行 MySQL 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4</span><br></pre></td></tr></table></figure><h3 id="3-部署-ssm-工程"><a href="#3-部署-ssm-工程" class="headerlink" title="3. 部署 ssm 工程"></a>3. 部署 ssm 工程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改SSM工程环境，设置为Linux中Docker容器的信息</span><br><span class="line">通过Maven的package重新打成war包</span><br><span class="line">将Windows下的war包复制到Linux中</span><br><span class="line">通过docker命令将宿主机的war包复制到容器内部</span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br><span class="line">测试访问SSM工程</span><br></pre></td></tr></table></figure><h3 id="六、数据卷"><a href="#六、数据卷" class="headerlink" title="六、数据卷"></a>六、数据卷</h3><p>为了部署 SSM 的工程，需要使用到 cp 的命令将宿主机内的 ssm.war 文件复制到容器内部。</p><p>数据卷：将宿主机的一个目录映射到容器的一个目录中。</p><p>可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。  </p><h3 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1. 创建数据卷"></a>1. 创建数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</span></span><br><span class="line">docker volume create 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="2-查看全部数据卷"><a href="#2-查看全部数据卷" class="headerlink" title="2. 查看全部数据卷"></a>2. 查看全部数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看全部数据卷信息</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h3 id="3-查看数据卷详情"><a href="#3-查看数据卷详情" class="headerlink" title="3. 查看数据卷详情"></a>3. 查看数据卷详情</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span></span><br><span class="line">docker volume inspect 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="4-删除数据卷"><a href="#4-删除数据卷" class="headerlink" title="4. 删除数据卷"></a>4. 删除数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除指定的数据卷</span></span><br><span class="line">docker volume rm 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="5-容器映射数据卷"><a href="#5-容器映射数据卷" class="headerlink" title="5. 容器映射数据卷"></a>5. 容器映射数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat -v 数据卷名称:容器内部的路径 镜像id</span><br><span class="line"> </span><br><span class="line"><span class="comment">#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat -v 路径(/root/自己创建的文件夹):容器内部的路径 镜像id</span><br></pre></td></tr></table></figure><h2 id="七、Dockerfile-自定义镜像"><a href="#七、Dockerfile-自定义镜像" class="headerlink" title="七、Dockerfile 自定义镜像"></a>七、Dockerfile 自定义镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建自定义镜像就需要创建一个Dockerfiler,如下为Dockerfile的语言</span><br><span class="line"> </span><br><span class="line">from：指定当前自定义镜像依赖的环境</span><br><span class="line">copy：将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir：声明镜像的默认工作目录</span><br><span class="line">run：执行的命令，可以编写多个</span><br><span class="line">cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">示例：</span></span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="2-通过-Dockerfile-制作镜像"><a href="#2-通过-Dockerfile-制作镜像" class="headerlink" title="2. 通过 Dockerfile 制作镜像"></a>2. 通过 Dockerfile 制作镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息，注意最后的 .</span></span><br><span class="line">docker build -t 镜像名称[:tag] ./</span><br></pre></td></tr></table></figure><h2 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker-Compose"></a>八、Docker-Compose</h2><h3 id="1-下载并安装-Docker-Compose"><a href="#1-下载并安装-Docker-Compose" class="headerlink" title="1. 下载并安装 Docker-Compose"></a>1. 下载并安装 Docker-Compose</h3><h3 id="1-1-下载-Docker-Compose"><a href="#1-1-下载-Docker-Compose" class="headerlink" title="1.1 下载 Docker-Compose"></a>1.1 下载 Docker-Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</span></span><br><span class="line">下载路径：https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</span><br></pre></td></tr></table></figure><h3 id="1-2-设置权限"><a href="#1-2-设置权限" class="headerlink" title="1.2 设置权限"></a>1.2 设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</span><br><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br></pre></td></tr></table></figure><h3 id="1-3-配置环境变量"><a href="#1-3-配置环境变量" class="headerlink" title="1.3 配置环境变量"></a>1.3 配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方便后期操作，配置一个环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将docker-compose文件移动到了/usr/<span class="built_in">local</span>/bin，修改了/etc/profile文件，给/usr/<span class="built_in">local</span>/bin配置到了PATH中</span></span><br><span class="line"> </span><br><span class="line">mv docker-compose /usr/local/bin</span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">添加内容：<span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>:/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在任意目录下输入docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-Docker-Compose-管理-MySQL-和-Tomcat-容器"><a href="#2-Docker-Compose-管理-MySQL-和-Tomcat-容器" class="headerlink" title="2.Docker-Compose 管理 MySQL 和 Tomcat 容器"></a>2.Docker-Compose 管理 MySQL 和 Tomcat 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">yml文件以key:value方式来指定配置信息</span><br><span class="line">多个配置信息以换行+缩进的方式来区分</span><br><span class="line">在docker-compose.yml文件中，不要使用制表符</span><br><span class="line"> </span><br><span class="line">version: '3.1'</span><br><span class="line">services:</span><br><span class="line">  mysql:           # 服务的名称</span><br><span class="line">    restart: always   # 代表只要docker启动，那么这个容器就跟着一起启动</span><br><span class="line">    image: daocloud.io/library/mysql:5.7.4  # 指定镜像路径</span><br><span class="line">    container_name: mysql  # 指定容器名称</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306   #  指定端口号的映射</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root   # 指定MySQL的ROOT用户登录密码</span><br><span class="line">      TZ: Asia/Shanghai        # 指定时区</span><br><span class="line">    volumes:</span><br><span class="line">     - /opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql   # 映射数据卷</span><br><span class="line">  tomcat:</span><br><span class="line">    restart: always</span><br><span class="line">    image: daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">    container_name: tomcat</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span><br></pre></td></tr></table></figure><h3 id="3-使用-docker-compose-命令管理容器"><a href="#3-使用-docker-compose-命令管理容器" class="headerlink" title="3. 使用 docker-compose 命令管理容器"></a>3. 使用 docker-compose 命令管理容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">1.基于docker-compose.yml启动管理的容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2.关闭并删除容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">3.开启|关闭|重启已经存在的由docker-compose维护的容器</span></span><br><span class="line">docker-compose start|stop|restart</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">4.查看由docker-compose管理的容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">5.查看日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h3 id="4-docker-compose-配合-Dockerfile-使用"><a href="#4-docker-compose-配合-Dockerfile-使用" class="headerlink" title="4.docker-compose 配合 Dockerfile 使用"></a>4.docker-compose 配合 Dockerfile 使用</h3><p>使用 docker-compose.yml 文件以及 Dockerfile 文件在生成自定义镜像的同时启动当前镜像，并且由 docker-compose 去管理容器  </p><h3 id="4-1docker-compose-文件"><a href="#4-1docker-compose-文件" class="headerlink" title="4.1docker-compose 文件"></a>4.1docker-compose 文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">编写docker-compose文件</span><br><span class="line"> </span><br><span class="line"><span class="comment"># yml文件</span></span><br><span class="line">version: <span class="string">'3.1'</span></span><br><span class="line">services:</span><br><span class="line">  ssm:</span><br><span class="line">    restart: always</span><br><span class="line">    build:            <span class="comment"># 构建自定义镜像</span></span><br><span class="line">      context: ../      <span class="comment"># 指定dockerfile文件的所在路径</span></span><br><span class="line">      dockerfile: Dockerfile   <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line">    image: ssm:1.0.1</span><br><span class="line">    container_name: ssm</span><br><span class="line">    ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br></pre></td></tr></table></figure><h3 id="4-2-Dockerfile-文件"><a href="#4-2-Dockerfile-文件" class="headerlink" title="4.2 Dockerfile 文件"></a>4.2 Dockerfile 文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编写Dockerfile文件</span><br><span class="line"> </span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span></span><br><span class="line"><span class="comment">#重新构建自定义镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"><span class="comment">#运行当前内容，并重新构建</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><h2 id="九、CI、CD-介绍及准备"><a href="#九、CI、CD-介绍及准备" class="headerlink" title="九、CI、CD 介绍及准备"></a>九、CI、CD 介绍及准备</h2><h3 id="1-CI、CD-引言"><a href="#1-CI、CD-引言" class="headerlink" title="1.CI、CD 引言"></a>1.CI、CD 引言</h3><p>项目部署  </p><ol><li>将项目通过 maven 进行编译打包  </li><li>将文件上传到指定的服务器中  </li><li>将 war 包放到 tomcat 的目录中  </li><li>通过 Dockerfile 将 Tomcat 和 war 包转成一个镜像，由 DockerCompose 去运行容器<br>项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过 CI、CD 帮助我们实现持续集成，持续交付和部署  </li></ol><h3 id="2-CI-介绍"><a href="#2-CI-介绍" class="headerlink" title="2.CI 介绍"></a>2.CI 介绍</h3><p>CI（continuous intergration）持续集成<br>持续集成：编写代码时，完成了一个功能后，立即提交代码到 Git 仓库中，将项目重新的构建并且测试。</p><ol><li>快速发现错误。  </li><li>防止代码偏离主分支。  </li></ol><h3 id="3-搭建-Gitlab-服务器"><a href="#3-搭建-Gitlab-服务器" class="headerlink" title="3. 搭建 Gitlab 服务器"></a>3. 搭建 Gitlab 服务器</h3><h3 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1. 准备环境"></a>3.1. 准备环境</h3><p>实现 CI，需要使用到 Gitlab 远程仓库，先通过 Docker 搭建 Gitlab<br>创建一个全新的虚拟机，并且至少指定 4G 的运行内存，4G 运行内存是 Gitlab 推荐的内存大小。<br>并且安装 Docker 以及 Docker-Compose  </p><h3 id="3-2-修改-ssh-的-22-端口"><a href="#3-2-修改-ssh-的-22-端口" class="headerlink" title="3.2 修改 ssh 的 22 端口"></a>3.2 修改 ssh 的 22 端口</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</span></span><br><span class="line"> </span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">  PORT 22 -&gt; 60022</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h3 id="3-3-编写-docker-compose-yml"><a href="#3-3-编写-docker-compose-yml" class="headerlink" title="3.3 编写 docker-compose.yml"></a>3.3 编写 docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker-compose.yml文件去安装gitlab（下载和运行的时间比较长的）</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">gitlab:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">'twang2218/gitlab-ce-zh:11.1.4'</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">"gitlab"</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">'gitlab'</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">   <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">   <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">external_url</span> <span class="string">'http://xxx.xxx.xxx.xxx'</span></span><br><span class="line">    <span class="string">gitlab_rails['time_zone']</span> <span class="string">=</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">    <span class="string">gitlab_rails['smtp_enable']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">22</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'22:22'</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/config:/etc/gitlab</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/data:/var/opt/gitlab</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h2 id="十、搭建-GitlabRunner"><a href="#十、搭建-GitlabRunner" class="headerlink" title="十、搭建 GitlabRunner"></a>十、搭建 GitlabRunner</h2><h3 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1. 准备文件"></a>1. 准备文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemon.json</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">“registry-mirrors”: [“https://registry.docker-cn.com”],</span><br><span class="line">“insecure-registries”: [ip:ports]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">文件夹 environment里面准备maven安装包，jdk1.8安装包，Dockerfile，daemon.json以及docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2. 开始搭建"></a>2. 开始搭建</h3><p>创建工作目录 /usr/local/docker_gitlab-runner<br>将 docker-compose.yml 文件以及 environment 目录全部复制到上述目录中<br>在宿主机启动 docker 程序后先执行 sudo chown root:root /var/run/docker.sock (如果重启过 docker, 重新执行)<br>在 / usr/local/docker_gitlab-runner 目录中执行 docker-compose up -d –build 启动容器<br>添加容器权限，保证容器可以使用宿主机的 dockerdocker exec -it gitlab-runner usermod -aG root gitlab-runner<br>注册 Runner 信息到 gitlab  </p><h3 id="3-进入后续步骤"><a href="#3-进入后续步骤" class="headerlink" title="3. 进入后续步骤"></a>3. 进入后续步骤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab-runner gitlab-runner register</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 GitLab 地址</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):</span><br><span class="line">http://192.168.199.109/</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 GitLab Token</span></span><br><span class="line">Please enter the gitlab-ci token for this runner:</span><br><span class="line">1Lxq_f1NRfCfeNbE5WRh</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 Runner 的说明</span></span><br><span class="line">Please enter the gitlab-ci description for this runner:</span><br><span class="line">可以为空</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span></span><br><span class="line">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class="line">deploy</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里选择 <span class="literal">true</span> ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to run untagged builds [true/false]:</span><br><span class="line">true</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里选择 <span class="literal">false</span>，可以直接回车，默认为 <span class="literal">false</span>（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to lock Runner to current project [true/false]:</span><br><span class="line">false</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择 runner 执行器，这里我们选择的是 shell</span></span><br><span class="line">Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h2 id="十一、整合项目入门测试"><a href="#十一、整合项目入门测试" class="headerlink" title="十一、整合项目入门测试"></a>十一、整合项目入门测试</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>创建 maven 工程，添加 web.xml 文件，编写 HTML 页面  </p><h3 id="2-编写-gitlab-ci-yml-文件"><a href="#2-编写-gitlab-ci-yml-文件" class="headerlink" title="2. 编写. gitlab-ci.yml 文件"></a>2. 编写. gitlab-ci.yml 文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">first</span> <span class="string">test</span> <span class="string">ci</span>   <span class="comment"># 输入的命令</span></span><br></pre></td></tr></table></figure><h3 id="3-将-maven-工程推送到-gitlab-中"><a href="#3-将-maven-工程推送到-gitlab-中" class="headerlink" title="3. 将 maven 工程推送到 gitlab 中"></a>3. 将 maven 工程推送到 gitlab 中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行git命令推送到Gitlab</span><br><span class="line"> </span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="4-查看效果"><a href="#4-查看效果" class="headerlink" title="4. 查看效果"></a>4. 查看效果</h3><p>可以在 gitlab 中查看到 gitlab-ci.yml 编写的内容  </p><h2 id="十二、完善项目配置"><a href="#十二、完善项目配置" class="headerlink" title="十二、完善项目配置"></a>十二、完善项目配置</h2><p>添加 Dockerfile 以及 docker-compose.yml， 并修改. gitlab-ci.yml 文件  </p><h3 id="1-创建-Dockerfile"><a href="#1-创建-Dockerfile" class="headerlink" title="1. 创建 Dockerfile"></a>1. 创建 Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile</span></span><br><span class="line">FROM daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">COPY testci.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="2-创建-docker-compose-yml"><a href="#2-创建-docker-compose-yml" class="headerlink" title="2. 创建 docker-compose.yml"></a>2. 创建 docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">testci:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">docker</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">testci</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h3 id="3-修改-gitlab-ci-yml"><a href="#3-修改-gitlab-ci-yml" class="headerlink" title="3. 修改. gitlab-ci.yml"></a>3. 修改. gitlab-ci.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci.yml</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">first</span> <span class="string">test</span> <span class="string">ci</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/local/maven/apache-maven-3.6.3/bin/mvn</span> <span class="string">package</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">target/testci-1.0-SNAPSHOT.war</span> <span class="string">docker/testci.war</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">down</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span> <span class="string">--build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">$(docker</span> <span class="string">images</span> <span class="string">-qf</span> <span class="string">dangling=true)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://search.bilibili.com/video?keyword=elastic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考b站教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Docker-介绍&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch</title>
    <link href="http://yoursite.com/2020/07/12/Java_ES/"/>
    <id>http://yoursite.com/2020/07/12/Java_ES/</id>
    <published>2020-07-12T13:44:15.000Z</published>
    <updated>2021-06-06T13:03:05.156Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Qz411e7yx?t=269&amp;p=5" target="_blank" rel="noopener">参考</a></p><h1 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h1><p>ES是使用java 语言并且基于lucence编写的搜索引擎框架，他提供了分布式的全文搜索功能，提供了一个统一的基于restful风格的web 接口。</p><p>lucence:一个搜索引擎底层</p><p>分布式：突出ES的横向扩展能力</p><p>全文检索：将一段词语进行分词，并将分出的词语统一的放在一个分词库中，再搜索时，根据关键字取分词库中检索，找到匹配的内容（倒排索引）。</p><p>restful风格的web 接口：只要发送一个http请求，并且根据请求方式的不同，携带参数的不同，执行相应的功能。</p><p>应用广泛：WIKI, github,Gold man</p><h2 id="ES的由来"><a href="#ES的由来" class="headerlink" title="ES的由来"></a>ES的由来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。</span><br><span class="line"></span><br><span class="line">直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。</span><br><span class="line"></span><br><span class="line">后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。</span><br><span class="line"></span><br><span class="line">第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。</span><br><span class="line"></span><br><span class="line">据说，Shay 的妻子还在等着她的食谱搜索引擎…</span><br></pre></td></tr></table></figure><h2 id="ES和solr"><a href="#ES和solr" class="headerlink" title="ES和solr"></a>ES和solr</h2><p>1.solr 查询死数据，速度比es快。但是数据如果是改变的，solr查询速度会降低很多，ES的查询速度没有明显的改变</p><p>2.solr搭建集群 依赖ZK，ES本身就支持集群搭建</p><p>3.最开始solr 的社区很火爆，针对国内文档 少，ES出现后，国内社区火爆程度 上升，，ES的文档非常健全</p><p>4.ES对云计算和大数据支持很好</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><img src="image-20200727144457339.png" alt="image"></p><p>1.将存放的数据以一定的方式进行分词，并将分词的内容存放到一个单独的分词库中。</p><p>2.当用户取查询数据时，会将用户的查询关键字进行分词，然后去分词库中匹配内容，最终得到数据的id标识</p><p>3.根据id标识去存放数据的位置拉去指定数据</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="elasticsearch-安装"><a href="#elasticsearch-安装" class="headerlink" title="elasticsearch 安装"></a>elasticsearch 安装</h2><p><a href="http://hub.daocloud.io/" target="_blank" rel="noopener">http://hub.daocloud.io/</a>    docker 镜像工厂地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/elasticsearch:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">   <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/kibana:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch_url=10.1.XX.XX:9200</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><p>或者本地下载</p><p>2.2</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官方给的安装的办法</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip</span><br></pre></td></tr></table></figure><p>本地自己安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip </span><br><span class="line">下载好后，</span><br><span class="line">执行 mvn clean package  打包（注意pom文件中的es的版本，如果和自己的es的版本不一致，手动改下）</span><br><span class="line">elasticsearch-analysis-ik-6.8.10\target\releases  中压缩包的内容copy到 elasticsearch-6.8.10\plugins\ik 下</span><br></pre></td></tr></table></figure><p>kibana 主要用到 Dev Tools   和 Management</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES的基本操作"><a href="#ES的基本操作" class="headerlink" title="ES的基本操作"></a>ES的基本操作</h1><h2 id="es的结构"><a href="#es的结构" class="headerlink" title="es的结构"></a>es的结构</h2><h3 id="索引indx，分片，备份"><a href="#索引indx，分片，备份" class="headerlink" title="索引indx，分片，备份"></a>索引indx，分片，备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES服务中会创建多个索引</span><br><span class="line">每个缩影默认被分成5个分片</span><br><span class="line">每个分片存在至少一个备份分片</span><br><span class="line">备份分片 不会帮助检索数据（当ES检索压力特别大的时候才，备份分片才会帮助检索数据）</span><br><span class="line">备份的分片必须放在不同的服务器中</span><br></pre></td></tr></table></figure><p><img src="image-20200727174836230.png" alt="png"></p><h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个索引下可以创建多个类型</span><br><span class="line">PS:版本不同,类型的创建也不同</span><br></pre></td></tr></table></figure><p><img src="image-20200727175427524.png" alt="png"></p><h3 id="文档document"><a href="#文档document" class="headerlink" title="文档document"></a>文档document</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个类型下可以有多个文档，这个文档就相当于mysql表中的多行数据</span><br></pre></td></tr></table></figure><p><img src="image-20200727175655572.png" alt="png"></p><p>3.1.4 属性field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个文档中可以包含多个属性，类似于mysql 表中的一行数据有多个列</span><br></pre></td></tr></table></figure><p><img src="ES笔记.assets/image-20200727180642583.png" alt="image-20200727180642583"></p><h2 id="操作ES的restful语法"><a href="#操作ES的restful语法" class="headerlink" title="操作ES的restful语法"></a>操作ES的restful语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET请求：</span><br><span class="line">http://ip:port/index :查询索引信息</span><br><span class="line">http://ip:port/index/type/doc_id :查询指定的文档信息</span><br><span class="line">POST请求：</span><br><span class="line">    http://ip:port/index/type/_search: 查询文档，可以在请求体中添加json字符串来代表查询条件</span><br><span class="line">    http://ip:port/index/type/doc_id/_update: 修改文档，在请求体中添加json字符串来代表修改的信息</span><br><span class="line">PUT请求：</span><br><span class="line">    http://ip:port/index : 创建一个索引，需要在请求体中指定索引的信息</span><br><span class="line">    http://ip:port/index/type/_mappings:代表创建索引时，指定索引文档存储属性的信息</span><br><span class="line">DELETE 请求：</span><br><span class="line">    http://ip:port/index： 删除跑路</span><br><span class="line">    http://ip:port/index/type/doc_id:  删除指定的文档</span><br></pre></td></tr></table></figure><h2 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h2><h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建一个索引</span><br><span class="line">#number_of_shards  分片</span><br><span class="line">#number_of_replicas 备份</span><br><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>, </span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看一个索引"><a href="#查看一个索引" class="headerlink" title="查看一个索引"></a>查看一个索引</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.management</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">#查看索引信息</span><br><span class="line">GET /person</span><br></pre></td></tr></table></figure><h3 id="删除-索引"><a href="#删除-索引" class="headerlink" title="删除 索引"></a>删除 索引</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.management</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">#删除索引</span><br><span class="line">DELETE /person</span><br></pre></td></tr></table></figure><h2 id="ES中Field可以指定的类型"><a href="#ES中Field可以指定的类型" class="headerlink" title="ES中Field可以指定的类型"></a>ES中Field可以指定的类型</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.8/mapping-types.html</a>  官方 文档</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">字符串类型:</span><br><span class="line">  text: 一般用于全文检索，将当前field 进行分词</span><br><span class="line">  keyword:当前field  不会进行分词</span><br><span class="line">数值类型：</span><br><span class="line">  long:</span><br><span class="line">  Intger:</span><br><span class="line">  short:</span><br><span class="line">  byte:</span><br><span class="line">  double:</span><br><span class="line">  float:</span><br><span class="line">  half_float: 精度比float 小一半</span><br><span class="line">  scaled_float:根据一个long 和scaled 来表达一个浮点型 long-345, -scaled 100 -&gt;3.45</span><br><span class="line">时间类型：</span><br><span class="line">  date类型,根据时间类型指定具体的格式</span><br><span class="line">    PUT my_index</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_doc"</span>: &#123;</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"date"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:   <span class="string">"date"</span>,</span><br><span class="line">              <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">布尔类型：</span><br><span class="line">  boolean 类型，表达true 和false</span><br><span class="line">二进制类型：</span><br><span class="line">  binary类型暂时支持Base64编码的字符串</span><br><span class="line">范围类型：</span><br><span class="line">  integer_range：</span><br><span class="line">  float_range：</span><br><span class="line">  long_range：赋值时，无需指定具体的内容，只需存储一个范围即可，gte,lte,gt,lt,</span><br><span class="line">  double_range：</span><br><span class="line">  date_range：</span><br><span class="line">  ip_range：</span><br><span class="line"></span><br><span class="line">    PUT range_index</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_doc"</span>: &#123;</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"expected_attendees"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"integer_range"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"time_frame"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"date_range"</span>, </span><br><span class="line">              <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT range_index/_doc/1?refresh</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"expected_attendees"</span> : &#123; </span><br><span class="line">        <span class="attr">"gte"</span> : <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"lte"</span> : <span class="number">20</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"time_frame"</span> : &#123; </span><br><span class="line">        <span class="attr">"gte"</span> : <span class="string">"2015-10-31 12:00:00"</span>, </span><br><span class="line">        <span class="attr">"lte"</span> : <span class="string">"2015-11-01"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">经纬度类型：</span><br><span class="line">  geo_point:用来存储经纬度</span><br><span class="line">IP类型：</span><br><span class="line">  ip:可以存储IPV4 和IPV6</span><br><span class="line">其他的数据类型，参考官网</span><br></pre></td></tr></table></figure><h2 id="创建索引并指定数据结构"><a href="#创建索引并指定数据结构" class="headerlink" title="创建索引并指定数据结构"></a>创建索引并指定数据结构</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#创建索引，指定数据类型</span><br><span class="line">PUT /book</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    #分片数</span><br><span class="line">    "number_of_shards": 5,</span><br><span class="line">    #备份数</span><br><span class="line">    "number_of_replicas": 1</span><br><span class="line">  &#125;,</span><br><span class="line">    #指定数据类型</span><br><span class="line"> "mappings": &#123;</span><br><span class="line">    #类型 Type</span><br><span class="line">   "novel":&#123;</span><br><span class="line">    #文档存储的field</span><br><span class="line">     "properties":&#123;</span><br><span class="line">       #field属性名</span><br><span class="line">       "name":&#123;</span><br><span class="line">         #类型</span><br><span class="line">         "type":"text",</span><br><span class="line">         #指定分词器</span><br><span class="line">         "analyzer":"ik_max_word",</span><br><span class="line">         #指定当前的field可以被作为查询的条件</span><br><span class="line">         "index":true,</span><br><span class="line">         #是否需要额外存储</span><br><span class="line">         "store":false</span><br><span class="line">       &#125;,</span><br><span class="line">       "author":&#123;</span><br><span class="line">         "type":"keyword"</span><br><span class="line">       &#125;,</span><br><span class="line">       "count":&#123;</span><br><span class="line">         "type":"long"</span><br><span class="line">       &#125;,</span><br><span class="line">       "on-sale":&#123;</span><br><span class="line">         "type":"date",</span><br><span class="line">           #指定时间类型的格式化方式</span><br><span class="line">         "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span><br><span class="line">       &#125;,</span><br><span class="line">        "descr":&#123;</span><br><span class="line">          "type":"text",</span><br><span class="line">          "analyzer":"ik_max_word"</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文档在ES服务中的唯一标识， _indx ,_type,_id  三个内容为组合，锁定一个文档，操作时添加还时修改操作，</span><br></pre></td></tr></table></figure><h3 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">自动生成id</span><br><span class="line">#添加文档，自动生成id</span><br><span class="line">POST /book/novel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"盘龙"</span>,</span><br><span class="line">  <span class="attr">"author"</span>:<span class="string">"我吃西红柿"</span>,</span><br><span class="line">  <span class="attr">"count"</span>:<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">"on-sale"</span>:<span class="string">"2001-01-01"</span>,</span><br><span class="line">  <span class="attr">"descr"</span>:<span class="string">"大小的血睛鬃毛狮，力大无穷的紫睛金毛猿，毁天灭地的九头蛇皇，携带着毁灭雷电的恐怖雷龙……这里无奇不有，这是一个广博的魔幻世界。强者可以站在黑色巨龙的头顶遨游天际，恐怖的魔法可以焚烧江河，可以毁灭城池，可以夷平山岳……"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#添加文档,手动指定id</span><br><span class="line">PUT /book/novel/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"红楼梦"</span>,</span><br><span class="line">  <span class="attr">"author"</span>:<span class="string">"曹雪芹"</span>,</span><br><span class="line">  <span class="attr">"count"</span>:<span class="number">10000000</span>,</span><br><span class="line">  <span class="attr">"on-sale"</span>:<span class="string">"2501-01-01"</span>,</span><br><span class="line">  <span class="attr">"descr"</span>:<span class="string">"中国古代章回体长篇小说，中国古典四大名著之一，一般认为是清代作家曹雪芹所著。小说以贾、史、王、薛四大家族的兴衰为背景，以富贵公子贾宝玉为视角，以贾宝玉与林黛玉、薛宝钗的爱情婚姻悲剧为主线，描绘了一批举止见识出于须眉之上的闺阁佳人的人生百态，展现了真正的人性美和悲剧美"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>1.覆盖式修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#添加文档,手动指定id</span><br><span class="line">PUT /book/novel/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;红楼梦&quot;,</span><br><span class="line">  &quot;author&quot;:&quot;曹雪芹&quot;,</span><br><span class="line">  &quot;count&quot;:1000444,</span><br><span class="line">  &quot;on-sale&quot;:&quot;2501-01-01&quot;,</span><br><span class="line">  &quot;descr&quot;:&quot;中国古代章回体长篇小说，中国古典四大名著之一，一般认为是清代作家曹雪芹所著。小说以贾、史、王、薛四大家族的兴衰为背景，以富贵公子贾宝玉为视角，以贾宝玉与林黛玉、薛宝钗的爱情婚姻悲剧为主线，描绘了一批举止见识出于须眉之上的闺阁佳人的人生百态，展现了真正的人性美和悲剧美&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用doc修改方式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#修改文档，使用doc 方式</span><br><span class="line">POST /book/novel/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">      #指定需要修改的field和对应的值</span><br><span class="line">    "count":566666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#根据id删除文档</span><br><span class="line">DELETE /book/novel/3mEnk3MBaSKoGN4T2olw</span><br></pre></td></tr></table></figure><h1 id="Java-操作ElasticSearch"><a href="#Java-操作ElasticSearch" class="headerlink" title="Java 操作ElasticSearch"></a>Java 操作ElasticSearch</h1><h2 id="Java-连接ES"><a href="#Java-连接ES" class="headerlink" title="Java 连接ES"></a>Java 连接ES</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">创建maven工程</span><br><span class="line">导入依赖</span><br><span class="line"><span class="comment">&lt;!--        1.elasticsearch--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        2.elasticsearch 高级API--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        3.junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        4.lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建client链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestHighLevelClient <span class="title">getClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//  创建 HttpHost</span></span><br><span class="line">        HttpHost httpHost = <span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>,<span class="number">9200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RestClientBuilder</span></span><br><span class="line">        RestClientBuilder builder = RestClient.builder(httpHost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RestHighLevelClient</span></span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备关于索引的setting</span></span><br><span class="line">        Settings.Builder settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                .put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.准备关于索引的mapping</span></span><br><span class="line">        XContentBuilder mappings = JsonXContent.contentBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                    .startObject(<span class="string">"properties"</span>)</span><br><span class="line">                        .startObject(<span class="string">"name"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"age"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"birthday"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                    .endObject()</span><br><span class="line">                .endObject();</span><br><span class="line">        <span class="comment">// 3.将settings和mappings 封装到到一个Request对象中</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(index)</span><br><span class="line">                .settings(settings)</span><br><span class="line">                .mapping(type,mappings);</span><br><span class="line">        <span class="comment">// 4.使用client 去连接ES</span></span><br><span class="line">        CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"response:"</span>+response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查索引是否存在，删除索引"><a href="#检查索引是否存在，删除索引" class="headerlink" title="检查索引是否存在，删除索引"></a>检查索引是否存在，删除索引</h2><h3 id="检查索引存在"><a href="#检查索引存在" class="headerlink" title="检查索引存在"></a>检查索引存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">existTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1.准备request 对象</span></span><br><span class="line">        GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过client 去 操作</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 3输出结果</span></span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.support.master.AcknowledgedResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取request</span></span><br><span class="line"></span><br><span class="line">        DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.使用client 操作request</span></span><br><span class="line">        AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//  3.输出结果</span></span><br><span class="line">        System.out.println(delete.isAcknowledged());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java操作文档"><a href="#Java操作文档" class="headerlink" title="Java操作文档"></a>Java操作文档</h2><h3 id="添加文档操作"><a href="#添加文档操作" class="headerlink" title="添加文档操作"></a>添加文档操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDocTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  1.准备一个json数据</span></span><br><span class="line">        Person person  = <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">33</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        String json = mapper.writeValueAsString(person);</span><br><span class="line">        <span class="comment">//  2.创建一个request对象(手动指定的方式创建)</span></span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(index,type,person.getId().toString());</span><br><span class="line">        request.source(json, XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.使用client 操作request对象生成doc</span></span><br><span class="line">        IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出返回结果</span></span><br><span class="line">        System.out.println(response.getResult().toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = &quot;person&quot;;</span><br><span class="line">    String type=&quot;man&quot;;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void updateDocTest() throws Exception&#123;</span><br><span class="line">        // 1.创建要跟新的Map</span><br><span class="line">        Map&lt;String,Object&gt;  doc = new HashMap&lt;&gt;();</span><br><span class="line">        doc.put(&quot;name&quot;,&quot;张三三&quot;);</span><br><span class="line"></span><br><span class="line">        // 2.创建request, 将doc 封装进去</span><br><span class="line">        UpdateRequest request = new UpdateRequest(index,type,&quot;1&quot;);</span><br><span class="line">        request.doc(doc);</span><br><span class="line"></span><br><span class="line">        // 3. client 去操作 request</span><br><span class="line">        UpdateResponse response = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">        // 4.输出 更新结果</span><br><span class="line">        System.out.println(response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDocTest</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//  1.封装删除对象</span></span><br><span class="line">        DeleteRequest request = <span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2 client 操作 request对象</span></span><br><span class="line">        DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//  3.输出结果</span></span><br><span class="line">        System.out.println(response.getResult().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java批量操作文档"><a href="#java批量操作文档" class="headerlink" title="java批量操作文档"></a>java批量操作文档</h2><p>批量操作 新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">      <span class="comment">// 1.准备多个json 对象</span></span><br><span class="line">      Person p1 = <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">23</span>,<span class="keyword">new</span> Date());</span><br><span class="line">      Person p2 = <span class="keyword">new</span> Person(<span class="number">2</span>,<span class="string">"里斯"</span>,<span class="number">24</span>,<span class="keyword">new</span> Date());</span><br><span class="line">      Person p3 = <span class="keyword">new</span> Person(<span class="number">3</span>,<span class="string">"王武"</span>,<span class="number">24</span>,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">      String json1  = mapper.writeValueAsString(p1);</span><br><span class="line">      String json2  = mapper.writeValueAsString(p2);</span><br><span class="line">      String json3  = mapper.writeValueAsString(p3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.创建request</span></span><br><span class="line"></span><br><span class="line">      BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">      bulkRequest.add(<span class="keyword">new</span> IndexRequest(index,type,p1.getId().toString()).source(json1,XContentType.JSON))</span><br><span class="line">              .add(<span class="keyword">new</span> IndexRequest(index,type,p2.getId().toString()).source(json2,XContentType.JSON))</span><br><span class="line">              .add(<span class="keyword">new</span> IndexRequest(index,type,p3.getId().toString()).source(json3,XContentType.JSON));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.client 执行</span></span><br><span class="line">      BulkResponse responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.输出结果</span></span><br><span class="line">      System.out.println(responses.getItems().toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>批量删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request 对象</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"1"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"2"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"3"</span>));</span><br><span class="line">    <span class="comment">// 2.执行</span></span><br><span class="line">    BulkResponse re = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出结果</span></span><br><span class="line">    System.out.println(re.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES-练习"><a href="#ES-练习" class="headerlink" title="ES 练习"></a>ES 练习</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引：sms-logs-index</span><br><span class="line">类型：sms-logs-type</span><br></pre></td></tr></table></figure><p><img src="image-20200728173057412.png" alt="png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备关于索引的setting</span></span><br><span class="line">        Settings.Builder settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                .put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.准备关于索引的mapping</span></span><br><span class="line">        XContentBuilder mappings = JsonXContent.contentBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                    .startObject(<span class="string">"properties"</span>)</span><br><span class="line">                        .startObject(<span class="string">"corpName"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"createDate"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"fee"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"long"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"ipAddr"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"ip"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"longCode"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"mobile"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"operatorId"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"province"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"replyTotal"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"sendDate"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"smsContent"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">                            .field(<span class="string">"analyzer"</span>, <span class="string">"ik_max_word"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"state"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                    .endObject()</span><br><span class="line">                .endObject();</span><br><span class="line">        <span class="comment">// 3.将settings和mappings 封装到到一个Request对象中</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(index)</span><br><span class="line">                .settings(settings)</span><br><span class="line">                .mapping(type,mappings);</span><br><span class="line">        <span class="comment">// 4.使用client 去连接ES</span></span><br><span class="line">        CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"response:"</span>+response.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">bulkCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备多个json 对象</span></span><br><span class="line">        String longcode = <span class="string">"1008687"</span>;</span><br><span class="line">        String mobile =<span class="string">"138340658"</span>;</span><br><span class="line">        List&lt;String&gt; companies = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        companies.add(<span class="string">"腾讯课堂"</span>);</span><br><span class="line">        companies.add(<span class="string">"阿里旺旺"</span>);</span><br><span class="line">        companies.add(<span class="string">"海尔电器"</span>);</span><br><span class="line">        companies.add(<span class="string">"海尔智家公司"</span>);</span><br><span class="line">        companies.add(<span class="string">"格力汽车"</span>);</span><br><span class="line">        companies.add(<span class="string">"苏宁易购"</span>);</span><br><span class="line">        List&lt;String&gt; provinces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        provinces.add(<span class="string">"北京"</span>);</span><br><span class="line">        provinces.add(<span class="string">"重庆"</span>);</span><br><span class="line">        provinces.add(<span class="string">"上海"</span>);</span><br><span class="line">        provinces.add(<span class="string">"晋城"</span>);</span><br><span class="line"></span><br><span class="line">        BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">16</span> ; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            SmsLogs s1 = <span class="keyword">new</span> SmsLogs();</span><br><span class="line">            s1.setId(i);</span><br><span class="line">            s1.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">            s1.setSendDate(<span class="keyword">new</span> Date());</span><br><span class="line">            s1.setLongCode(longcode+i);</span><br><span class="line">            s1.setMobile(mobile+<span class="number">2</span>*i);</span><br><span class="line">            s1.setCorpName(companies.get(i%<span class="number">5</span>));</span><br><span class="line">            s1.setSmsContent(SmsLogs.doc.substring((i-<span class="number">1</span>)*<span class="number">100</span>,i*<span class="number">100</span>));</span><br><span class="line">            s1.setState(i%<span class="number">2</span>);</span><br><span class="line">            s1.setOperatorId(i%<span class="number">3</span>);</span><br><span class="line">            s1.setProvince(provinces.get(i%<span class="number">4</span>));</span><br><span class="line">            s1.setIpAddr(<span class="string">"127.0.0."</span>+i);</span><br><span class="line">            s1.setReplyTotal(i*<span class="number">3</span>);</span><br><span class="line">            s1.setFee(i*<span class="number">6</span>+<span class="string">""</span>);</span><br><span class="line">            String json1  = mapper.writeValueAsString(s1);</span><br><span class="line">            bulkRequest.add(<span class="keyword">new</span> IndexRequest(index,type,s1.getId().toString()).source(json1, XContentType.JSON));</span><br><span class="line">            System.out.println(<span class="string">"数据"</span>+i+s1.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.client 执行</span></span><br><span class="line">        BulkResponse responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.输出结果</span></span><br><span class="line">        System.out.println(responses.getItems().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch的各种查询"><a href="#ElasticSearch的各种查询" class="headerlink" title="ElasticSearch的各种查询"></a>ElasticSearch的各种查询</h1><h2 id="term-和terms-查询"><a href="#term-和terms-查询" class="headerlink" title="term 和terms 查询"></a>term 和terms 查询</h2><h3 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term 查询是代表完全匹配，搜索之前不会对你搜索的关键字进行分词，直接拿 关键字 去文档分词库中匹配内容</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#term查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  #limit ?</span><br><span class="line">  "from": 0,  </span><br><span class="line">  #limit x,?</span><br><span class="line">  "size":5,</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "province": &#123;</span><br><span class="line">        "value": "北京"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termSearchTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.from(<span class="number">0</span>);</span><br><span class="line">        builder.size(<span class="number">5</span>);</span><br><span class="line">        builder.query(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>));</span><br><span class="line"></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(sourceAsMap);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terms 和 term 查询的机制一样，搜索之前不会对你搜索的关键字进行分词，直接拿 关键字 去文档分词库中匹配内容</span><br><span class="line">terms:是针对一个字段包含多个值</span><br><span class="line">term : where province =北京</span><br><span class="line">terms: where province = 北京  or  province =?  (类似于mysql 中的 in)</span><br><span class="line">也可针对 text,  只是在分词库中查询的时候不会进行分词</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#terms 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"terms"</span>: &#123;</span><br><span class="line">      <span class="attr">"province"</span>: [</span><br><span class="line">        <span class="string">"北京"</span>,</span><br><span class="line">        <span class="string">"晋城"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termsSearchTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.query(QueryBuilders.termsQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>,<span class="string">"晋城"</span>));</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match 查询属于高级查询，会根据你查询字段的类型不一样，采用不同的查询方式</span><br><span class="line">查询的是日期或者数值，他会将你基于字符串的查询内容转换为日期或数值对待</span><br><span class="line">如果查询的内容是一个不能被分词的内容（keyword）,match 不会将你指定的关键字进行分词</span><br><span class="line">如果查询的内容是一个可以被分词的内容（text）,match 查询会将你指定的内容根据一定的方式进行分词，去分词库中匹配指定的内容</span><br><span class="line">match 查询，实际底层就是多个term 查询，将多个term查询的结果给你封装到一起</span><br></pre></td></tr></table></figure><h3 id="math-all"><a href="#math-all" class="headerlink" title="math_all"></a>math_all</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询全部内容，不指定查询条件</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#match_all 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchAllSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">         <span class="comment">//  ES 默认只查询10条数据</span></span><br><span class="line">        builder.size(<span class="number">20</span>);</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.getHits().getHits().length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h3><p>指定一个field 作为查询条件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#match 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: <span class="string">"伟大战士"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"伟大战士"</span>));</span><br><span class="line">        <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">        builder.size(<span class="number">20</span>);</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.getHits().getHits().length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔match-查询"><a href="#布尔match-查询" class="headerlink" title="布尔match 查询"></a>布尔match 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于一个field 匹配的内容，按照 and 或者or的方式连接</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#布尔match查询 </span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: &#123;</span><br><span class="line">         # 既包含 战士 也包含 团队</span><br><span class="line">        "query": "战士 团队",</span><br><span class="line">        "operator": "and"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#布尔match查询 </span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: &#123;</span><br><span class="line">         # 既包含 战士 或者 团队</span><br><span class="line">        "query": "战士 团队",</span><br><span class="line">        "operator": "or"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">booleanMatchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.创建查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"战士 团队"</span>).operator(Operator.AND));</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.size(<span class="number">20</span>);</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(response.getHits().getHits().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match 针对一个field 做检索，multi_math 针对多个field 进行检索，多个field对应一个文本。</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#multi_math 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"北京"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [<span class="string">"province"</span>,<span class="string">"smsContent"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiMatchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.创建查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.multiMatchQuery(<span class="string">"北京"</span>,<span class="string">"province"</span>,<span class="string">"smsContent"</span>));</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.size(<span class="number">20</span>);</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(response.getHits().getHits().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他查询"><a href="#其他查询" class="headerlink" title="其他查询"></a>其他查询</h2><h3 id="id-查询"><a href="#id-查询" class="headerlink" title="id 查询"></a>id 查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#id 查询</span><br><span class="line">GET /sms-logs-index/sms-logs-type/1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGetSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建GetRequest对象</span></span><br><span class="line">        GetRequest request = <span class="keyword">new</span> GetRequest(index,type,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  执行查询</span></span><br><span class="line">        GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(response.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ids查询"><a href="#ids查询" class="headerlink" title="ids查询"></a>ids查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据多个id 查询,类似 mysql 中的 where in (id1,id2...)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ids 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"ids"</span>: &#123;</span><br><span class="line">      <span class="attr">"values"</span>: [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByIds</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.idsQuery().addIds(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prefix-查询"><a href="#prefix-查询" class="headerlink" title="prefix 查询"></a>prefix 查询</h3><p>前缀查询，可以通过一个关键字去指定一个field 的前缀，从而查询到指定文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#prefix 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#match 查询 在这里是什么都查不到的 和上边的prefix 做比较</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: <span class="string">"海"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByPrefix</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.prefixQuery(<span class="string">"corpName"</span>,<span class="string">"阿"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fuzzy-查询"><a href="#fuzzy-查询" class="headerlink" title="fuzzy 查询"></a>fuzzy 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模糊查询，我们可以输入一个字符的大概，ES 可以根据输入的大概去匹配内容。查询结果不稳定</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#fuzzy 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"腾讯客堂"</span>,</span><br><span class="line">          #指定前边几个字符是不允许出现错误的</span><br><span class="line">        "prefix_length": 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public  void findByFuzzy() throws IOException &#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = new SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = new SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.fuzzyQuery("corpName","腾讯客堂").prefixLength(2));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    for (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wildcard-查询"><a href="#wildcard-查询" class="headerlink" title="wildcard 查询"></a>wildcard 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通配查询，同mysql中的like 是一样的，可以在查询时，在字符串中指定通配符*和占位符？</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#wildcard 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海尔*"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#wildcard 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海尔??"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByWildCard</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.wildcardQuery(<span class="string">"corpName"</span>,<span class="string">"海尔*"</span>));</span><br><span class="line">        <span class="comment">//------------------------------------------------------</span></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="rang-查询"><a href="#rang-查询" class="headerlink" title="rang 查询"></a>rang 查询</h3><p>范围查询，只针对数值类型，对一个field 进行大于或者小于的范围指定</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#rang 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"gte"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"lte"</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByRang</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).gt(<span class="number">10</span>).lte(<span class="number">30</span>));</span><br><span class="line">        <span class="comment">//------------------------------------------------------</span></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="regexp-查询"><a href="#regexp-查询" class="headerlink" title="regexp 查询"></a>regexp 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正则查询，通过你编写的正则表达式去匹配内容</span><br><span class="line">Ps:prefix wildcard  fuzzy 和regexp 查询效率比较低 ,在要求效率比较高时，避免使用</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#regexp 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">      <span class="attr">"mobile"</span>: <span class="string">"138[0-9]&#123;8&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByRegexp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.regexpQuery(<span class="string">"mobile"</span>,<span class="string">"138[0-9]&#123;8&#125;"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深分页-scrol-l"><a href="#深分页-scrol-l" class="headerlink" title="深分页 scrol l"></a>深分页 scrol l</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ES 对from +size时又限制的，from +size 之和 不能大于1W,超过后 效率会十分低下</span><br><span class="line">原理：</span><br><span class="line">  from+size  ES查询数据的方式，</span><br><span class="line">  第一步将用户指定的关键词进行分词，</span><br><span class="line">  第二部将词汇去分词库中进行检索，得到多个文档id,</span><br><span class="line">  第三步去各个分片中拉去数据， 耗时相对较长</span><br><span class="line">  第四步根据score 将数据进行排序， 耗时相对较长</span><br><span class="line">  第五步根据from 和size 的值 将部分数据舍弃，</span><br><span class="line">  第六步，返回结果。</span><br><span class="line">  </span><br><span class="line">  scroll +size ES 查询数据的方式</span><br><span class="line">  第一步将用户指定的关键词进行分词，</span><br><span class="line">  第二部将词汇去分词库中进行检索，得到多个文档id,</span><br><span class="line">  第三步，将文档的id放在一个上下文中</span><br><span class="line">  第四步，根据指定的size去ES中检索指定个数数据，拿完数据的文档id,会从上下文中移除</span><br><span class="line">  第五步，如果需要下一页的数据，直接去ES的上下文中找后续内容。</span><br><span class="line">  第六步，循环第四步和第五步</span><br><span class="line">  scroll 不适合做实时查询。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#scroll 查询,返回第一页数据，并将文档id信息存放在ES上下文中，并指定生存时间</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#根据scroll 查询下一页数据</span><br><span class="line">POST _search/scroll</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scroll_id"</span>:<span class="string">"DnF1ZXJ5VGhlbkZldGNoAwAAAAAAABbqFk04VlZ1cjlUU2t1eHpsQWNRY1YwWWcAAAAAAAAW7BZNOFZWdXI5VFNrdXh6bEFjUWNWMFlnAAAAAAAAFusWTThWVnVyOVRTa3V4emxBY1FjVjBZZw=="</span>,</span><br><span class="line">  <span class="attr">"scroll"</span>:<span class="string">"1m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#删除scroll上下文中的数据</span><br><span class="line">DELETE _search/scroll/DnF1ZXJ5VGhlbkZldGNoAwAAAAAAABchFk04VlZ1cjlUU2t1eHpsQWNRY1YwWWcAAAAAAAAXIBZNOFZWdXI5VFNrdXh6bEFjUWNWMFlnAAAAAAAAFx8WTThWVnVyOVRTa3V4emxBY1FjVjBZZw==</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建request</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        searchRequest.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.指定scroll信息,过期时间</span></span><br><span class="line">        searchRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.size(<span class="number">4</span>);</span><br><span class="line">        builder.sort(<span class="string">"fee"</span>, SortOrder.DESC);</span><br><span class="line">        searchRequest.source(builder);</span><br><span class="line">        <span class="comment">// 4.获取返回结果scrollId,获取source</span></span><br><span class="line">        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        String scrollId = response.getScrollId();</span><br><span class="line">        System.out.println(<span class="string">"-------------首页数据---------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 5.创建scroll request</span></span><br><span class="line"></span><br><span class="line">            SearchScrollRequest scrollRequest = <span class="keyword">new</span> SearchScrollRequest(scrollId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.指定scroll 有效时间</span></span><br><span class="line">            scrollRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.执行查询，返回查询结果</span></span><br><span class="line">            SearchResponse scroll = client.scroll(scrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.判断是否查询到数据，查询到输出</span></span><br><span class="line">            SearchHit[] searchHits =  scroll.getHits().getHits();</span><br><span class="line">            <span class="keyword">if</span>(searchHits!=<span class="keyword">null</span> &amp;&amp; searchHits.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"-------------下一页数据---------------------"</span>);</span><br><span class="line">                <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">                    System.out.println(hit.getSourceAsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//  9.没有数据，结束</span></span><br><span class="line">                System.out.println(<span class="string">"-------------结束---------------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.创建 clearScrollRequest</span></span><br><span class="line">        ClearScrollRequest clearScrollRequest = <span class="keyword">new</span> ClearScrollRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.指定scrollId</span></span><br><span class="line">        clearScrollRequest.addScrollId(scrollId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//12.删除scroll</span></span><br><span class="line">        ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13.输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"删除scroll:"</span>+clearScrollResponse.isSucceeded());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete-by-query"><a href="#delete-by-query" class="headerlink" title="delete-by-query"></a>delete-by-query</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据term,match 等查询方式去删除大量索引</span><br><span class="line">PS:如果你要删除的内容，时index下的大部分数据，推荐创建一个新的index,然后把保留的文档内容，添加到全新的索引</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Delet-by-query 删除</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"lt"</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建DeleteByQueryRequest</span></span><br><span class="line">    DeleteByQueryRequest request = <span class="keyword">new</span> DeleteByQueryRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定条件</span></span><br><span class="line">    request.setQuery(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).lt(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.执行</span></span><br><span class="line">    BulkByScrollResponse response = client.deleteByQuery(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.输出返回结果</span></span><br><span class="line">    System.out.println(response.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复合过滤器，将你的多个查询条件 以一定的逻辑组合在一起，</span><br><span class="line"></span><br><span class="line">must:所有条件组合在一起，表示 and 的意思</span><br><span class="line">must_not: 将must_not中的条件，全部都不匹配，表示not的意思</span><br><span class="line">should:所有条件用should 组合在一起，表示or 的意思</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#省是 晋城 或者北京</span><br><span class="line"># 运营商不能是联通</span><br><span class="line">#smsContent 包含 战士 和的</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"province"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"晋城"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"province"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"北京"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"operatorId"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"2"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"smsContent"</span>: <span class="string">"战士"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"smsContent"</span>: <span class="string">"的"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">boolSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1.创建 searchRequest</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line">        <span class="comment">// 2.指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = <span class="keyword">new</span> BoolQueryBuilder();</span><br><span class="line">        <span class="comment">// #省是 晋城 或者北京</span></span><br><span class="line">        boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>));</span><br><span class="line">        boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"晋城"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//# 运营商不能是联通</span></span><br><span class="line">        boolQueryBuilder.mustNot(QueryBuilders.termQuery(<span class="string">"operatorId"</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//#smsContent 包含 战士 和的</span></span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"战士"</span>));</span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"的"</span>));</span><br><span class="line"></span><br><span class="line">        builder.query(boolQueryBuilder);</span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="boosting-查询"><a href="#boosting-查询" class="headerlink" title="boosting 查询"></a>boosting 查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boosting 查询可以帮助我们去影响查询后的score</span><br><span class="line">   positive:只有匹配上positive 查询的内容，才会被放到返回的结果集中</span><br><span class="line">   negative: 如果匹配上了positive 也匹配上了negative, 就可以 降低这样的文档score.</span><br><span class="line">   negative_boost:指定系数,必须小于1   0.5 </span><br><span class="line">关于查询时，分数时如何计算的：</span><br><span class="line">搜索的关键字再文档中出现的频次越高，分数越高</span><br><span class="line">指定的文档内容越短，分数越高。</span><br><span class="line">我们再搜索时，指定的关键字也会被分词，这个被分词的内容，被分词库匹配的个数越多，分数就越高。</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#boosting 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"boosting"</span>: &#123;</span><br><span class="line">      <span class="attr">"positive"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"smsContent"</span>: <span class="string">"战士"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, </span><br><span class="line">      <span class="attr">"negative"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"smsContent"</span>: <span class="string">"团队"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"negative_boost"</span>: <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">boostSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.创建 searchRequest</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">// 2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoostingQueryBuilder boost = QueryBuilders.boostingQuery(</span><br><span class="line">            QueryBuilders.matchQuery(<span class="string">"smsContent"</span>, <span class="string">"战士"</span>),</span><br><span class="line">            QueryBuilders.matchQuery(<span class="string">"smsContent"</span>, <span class="string">"团队"</span>)</span><br><span class="line">    ).negativeBoost(<span class="number">0.2f</span>);</span><br><span class="line">    builder.query(boost);</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter-查询"><a href="#filter-查询" class="headerlink" title="filter  查询"></a>filter  查询</h2><p>query 查询：根据你的查询条件，去计算文档的匹配度得到一个分数，并根据分数排序，不会做缓存的。</p><p>filter 查询：根据查询条件去查询文档，不去计算分数，而且filter会对经常被过滤的数据进行缓存。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#filter 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"corpName"</span>: <span class="string">"海尔智家公司"</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>:&#123;</span><br><span class="line">            <span class="attr">"fee"</span>:&#123;</span><br><span class="line">              <span class="attr">"lte"</span>:<span class="number">50</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.searchRequest</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    searchRequest.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoolQueryBuilder boolBuilder = QueryBuilders.boolQuery();</span><br><span class="line">    boolBuilder.filter(QueryBuilders.termQuery(<span class="string">"corpName"</span>,<span class="string">"海尔智家公司"</span>));</span><br><span class="line">    boolBuilder.filter(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).gt(<span class="number">20</span>));</span><br><span class="line">    sourceBuilder.query(boolBuilder);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行</span></span><br><span class="line">    SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  4. 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">        System.out.println(hit.getId()+<span class="string">"的分数是："</span>+hit.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高亮查询就是用户输入的关键字，以一定特殊样式展示给用户，让用户知道为什么这个结果被检索出来</span><br><span class="line">高亮展示的数据，本身就是文档中的一个field,单独将field以highlight的形式返回给用户</span><br><span class="line">ES提供了一个highlight 属性，他和query 同级别。</span><br><span class="line"> frament_size: 指定高亮数据展示多少个字符回来</span><br><span class="line"> pre_tags:指定前缀标签&lt;front color=&quot;red&quot;&gt;</span><br><span class="line"> post_tags:指定后缀标签 &lt;/font&gt;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#highlight 高亮查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: <span class="string">"团队"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"pre_tags"</span>:<span class="string">"&lt;font color='red'&gt;"</span>,</span><br><span class="line">    <span class="attr">"post_tags"</span>:<span class="string">"&lt;/font&gt;"</span>,</span><br><span class="line">    <span class="attr">"fragment_size"</span>:<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">highLightQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">// 1.创建request</span></span><br><span class="line">       SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">       request.types(type);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.指定查询条件，指定高亮</span></span><br><span class="line">       SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">       builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"团队"</span>));</span><br><span class="line">       HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">       highlightBuilder.field(<span class="string">"smsContent"</span>,<span class="number">10</span>)</span><br><span class="line">               .preTags(<span class="string">"&lt;font colr='red'&gt;"</span>)</span><br><span class="line">               .postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">       builder.highlighter(highlightBuilder);</span><br><span class="line">       request.source(builder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.执行</span></span><br><span class="line">       SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4. 输出结果</span></span><br><span class="line">       <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">           System.out.println(hit.getHighlightFields().get(<span class="string">"smsContent"</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES的聚合查询和mysql 的聚合查询类似，ES的聚合查询相比mysql 要强大得多。ES提供的统计数据的方式多种多样。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ES 聚合查询的RSTFul 语法</span><br><span class="line">POST /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">        <span class="attr">"(名字)agg"</span>:&#123;</span><br><span class="line">            <span class="attr">"agg_type"</span>:&#123;</span><br><span class="line">                "属性"："值"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去重计数聚合查询"><a href="#去重计数聚合查询" class="headerlink" title="去重计数聚合查询"></a>去重计数聚合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">去重计数，cardinality 先将返回的文档中的一个指定的field进行去重，统计一共有多少条</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 去重计数 查询 province</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"provinceAgg"</span>: &#123;</span><br><span class="line">      <span class="attr">"cardinality"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"province"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggCardinalityC</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.aggregation(AggregationBuilders.cardinality(<span class="string">"provinceAgg"</span>).field(<span class="string">"province"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.输出返回结果</span></span><br><span class="line">    Cardinality agg = response.getAggregations().get(<span class="string">"provinceAgg"</span>);</span><br><span class="line">    System.out.println(agg.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围统计"><a href="#范围统计" class="headerlink" title="范围统计"></a>范围统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">统计一定范围内出现的文档个数，比如，针对某一个field 的值再0~100,100~200,200~300 之间文档出现的个数分别是多少</span><br><span class="line">范围统计 可以针对 普通的数值，针对时间类型，针对ip类型都可以响应。</span><br><span class="line">数值 rang    </span><br><span class="line">时间  date_rang     </span><br><span class="line">ip   ip_rang</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#针对数值方式的范围统计  from 带等于效果 ，to 不带等于效果</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"fee"</span>,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">30</span></span><br><span class="line">          &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">60</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">60</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#时间方式统计</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"date_range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"sendDate"</span>,</span><br><span class="line">        <span class="attr">"format"</span>: <span class="string">"yyyy"</span>, </span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="string">"2000"</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="string">"2000"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#ip 方式 范围统计</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"ip_range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"ipAddr"</span>,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="string">"127.0.0.8"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="string">"127.0.0.8"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggRang</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 1.创建request</span></span><br><span class="line">       SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">       request.types(type);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">       SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">       builder.aggregation(AggregationBuilders.range(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>)</span><br><span class="line">                           .addUnboundedTo(<span class="number">30</span>)</span><br><span class="line">                           .addRange(<span class="number">30</span>,<span class="number">60</span>)</span><br><span class="line">                           .addUnboundedFrom(<span class="number">60</span>));</span><br><span class="line">       request.source(builder);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.执行查询</span></span><br><span class="line">       SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.输出返回结果</span></span><br><span class="line">       Range agg = response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">       <span class="keyword">for</span> (Range.Bucket bucket : agg.getBuckets()) &#123;</span><br><span class="line">           String key = bucket.getKeyAsString();</span><br><span class="line">           Object from = bucket.getFrom();</span><br><span class="line">           Object to = bucket.getTo();</span><br><span class="line">           <span class="keyword">long</span> docCount = bucket.getDocCount();</span><br><span class="line">           System.out.println(String.format(<span class="string">"key: %s ,from: %s ,to: %s ,docCount: %s"</span>,key,from,to,docCount));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="统计聚合"><a href="#统计聚合" class="headerlink" title="统计聚合"></a>统计聚合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他可以帮你查询指定field 的最大值，最小值，平均值，平方和...</span><br><span class="line">使用 extended_stats</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#统计聚合查询 extended_stats</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"extended_stats"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"fee"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java实现   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggExtendedStats</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.aggregation(AggregationBuilders.extendedStats(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>));</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.输出返回结果</span></span><br><span class="line">       ExtendedStats extendedStats =  response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">        System.out.println(<span class="string">"最大值："</span>+extendedStats.getMaxAsString()+<span class="string">",最小值："</span>+extendedStats.getMinAsString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="其他聚合查询-查看官方文档"><a href="#其他聚合查询-查看官方文档" class="headerlink" title="其他聚合查询 查看官方文档"></a>其他聚合查询 查看官方文档</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-aggregations-metrics-weight-avg-aggregation.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-aggregations-metrics-weight-avg-aggregation.html</a></p><h2 id="6-10-地图经纬度搜索"><a href="#6-10-地图经纬度搜索" class="headerlink" title="6.10 地图经纬度搜索"></a>6.10 地图经纬度搜索</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#创建一个经纬度索引,指定一个 name ,一个location</span><br><span class="line">PUT /map</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"map"</span>:&#123;</span><br><span class="line">      <span class="attr">"properties"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"location"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>:<span class="string">"geo_point"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#添加测试数据</span><br><span class="line">PUT /map/map/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"天安门"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.403694</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">39.914492</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /map/map/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"百望山"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.26284</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">40.036576</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /map/map/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"北京动物园"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.347352</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">39.947468</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES-的地图检索方式"><a href="#ES-的地图检索方式" class="headerlink" title="ES 的地图检索方式"></a>ES 的地图检索方式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geo_distance :直线距离检索方式</span><br><span class="line">geo_bounding_box: 以2个点确定一个矩形，获取再矩形内的数据</span><br><span class="line">geo_polygon:以多个点，确定一个多边形，获取多边形的全部数据</span><br></pre></td></tr></table></figure><h3 id="基于RESTFul-实现地图检索"><a href="#基于RESTFul-实现地图检索" class="headerlink" title="基于RESTFul 实现地图检索"></a>基于RESTFul 实现地图检索</h3><p>geo_distance</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#geo_distance </span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_distance"</span>:&#123;</span><br><span class="line">        #确定一个点</span><br><span class="line">      "location":&#123;</span><br><span class="line">        "lon":116.434739,</span><br><span class="line">        "lat":39.909843</span><br><span class="line">      &#125;,</span><br><span class="line">      #确定半径</span><br><span class="line">      "distance":20000,</span><br><span class="line">      #指定形状为圆形</span><br><span class="line">      "distance_type":"arc"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#geo_bounding_box</span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"geo_bounding_box"</span>:&#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">        <span class="attr">"top_left"</span>:&#123;</span><br><span class="line">          <span class="attr">"lon"</span>:<span class="number">116.327805</span>,</span><br><span class="line">          <span class="attr">"lat"</span>:<span class="number">39.95499</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"bottom_right"</span>:&#123;</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">116.363162</span>,</span><br><span class="line">          <span class="attr">"lat"</span>:<span class="number">39.938395</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#geo_polygon</span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"geo_polygon"</span>:&#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">          # 指定多个点确定 位置</span><br><span class="line">       "points":[</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.220296</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">40.075013</span></span><br><span class="line">         &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.346777</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">40.044751</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.236106</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">39.981533</span></span><br><span class="line">         &#125; </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-实现-geo-polygon"><a href="#Java-实现-geo-polygon" class="headerlink" title="Java 实现 geo_polygon"></a>Java 实现 geo_polygon</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoDemo</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"map"</span>;</span><br><span class="line">    String type=<span class="string">"map"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GeoPolygon</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//  1.创建searchRequest</span></span><br><span class="line">            SearchRequest request  = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">            request.types(type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2.指定 检索方式</span></span><br><span class="line"></span><br><span class="line">            SearchSourceBuilder builder =  <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">            List&lt;GeoPoint&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">40.075013</span>,<span class="number">116.220296</span>));</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">40.044751</span>,<span class="number">116.346777</span>));</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">39.981533</span>,<span class="number">116.236106</span>));</span><br><span class="line">            builder.query(QueryBuilders.geoPolygonQuery(<span class="string">"location"</span>,points));</span><br><span class="line">            request.source(builder);</span><br><span class="line">            <span class="comment">// 3.执行</span></span><br><span class="line">            SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">            <span class="comment">// 4.输出结果</span></span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                System.out.println(hit.getSourceAsMap());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Qz411e7yx?t=269&amp;amp;p=5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES简介&quot;&gt;&lt;a href=&quot;#ES简
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>检索系统的评价</title>
    <link href="http://yoursite.com/2020/07/12/ML_Evaluation/"/>
    <id>http://yoursite.com/2020/07/12/ML_Evaluation/</id>
    <published>2020-07-12T13:42:15.000Z</published>
    <updated>2021-05-18T02:13:29.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检索系统的评价"><a href="#检索系统的评价" class="headerlink" title="检索系统的评价"></a>检索系统的评价</h1><h3 id="无序的检索结果评价"><a href="#无序的检索结果评价" class="headerlink" title="无序的检索结果评价."></a>无序的检索结果评价.</h3><p>如果有测试集的话,那么系统效果常用的两个基本指标就是正确率和召回率.不考虑结果的顺序的话.那就和分类的评价差不多.</p><ul><li>正确率:返回与query相关文档所占比例;</li></ul><script type="math/tex; mode=display">Precision = \frac{\text { 返同结果中相关文档的数目 }}{\text { 返同结果的数目 }}=P(\text { relevant } \mid \text { retrieved })</script><ul><li>召回率:返回相关文档所占所有相关文档的比例;</li></ul><script type="math/tex; mode=display">Recall =\frac{\text { 返同结果中相关文档的数目 }}{\text { 所有相关文档的数目 }}=P(\text { retrieved } \mid \text { relevant })</script><div class="table-container"><table><thead><tr><th></th><th>相关(relevant)</th><th>不相关(nonrelevant)</th></tr></thead><tbody><tr><td>retrieved</td><td>true positives(tp)</td><td>false positives(fp)</td></tr><tr><td>not retrieved</td><td>false negatives(fn)</td><td>true negatives(tn)</td></tr></tbody></table></div><p>则有:</p><script type="math/tex; mode=display">\begin{array}{l}P=t p /(t p+f p) \\R=t p /(t p+f n)\end{array}</script><p>在这有个问题就是精确度(accuracy)对于信息检索不是一个很好的指标, 因为信息检索中数据极度不平衡.通常99.99%以上都是不相关文档. 全判定为不相关精确度都很高.<br>采用正确率() 和 召回率() 两个指标的有个有点,他能根据场景不同来确定指标的重要性.<br>如果两种都需要,直觉来看就是平均值, 这就出现了一个新的指标 F</p><script type="math/tex; mode=display">F=\frac{1}{\alpha \frac{1}{P}+(1-\alpha) \frac{1}{R}}=\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>其中, $\beta^{2} = \frac{1 - \alpha}{\alpha} , \alpha \in [0, 1]$,</p><h3 id="有序检索结果的评价方法"><a href="#有序检索结果的评价方法" class="headerlink" title="有序检索结果的评价方法"></a>有序检索结果的评价方法</h3><p>正确率、召回率和F值都是基于集合的评价方法,它们都利用无序的文档集合进行计算.所以需要其他的评价方式.<br>在结果有序的情况下，通常很自然地会将前面k个（k=1,2,…）检索结果组成合适的返回文档子集。对每个这样的集合，都可以得到正确率和召回率，分别以它们作为纵坐标和横<br>坐标在平面上描点并连接便可以得到所示的正确率—召回率曲线<br><img src="20200711110949009_8654.png" alt="png"><br>在某个召回率水平r上的插值正确率（interpolated precision，记为pinterp）定义为对于任意不小于r的召回率水平r′ 所对应的最大正确率，即</p><script type="math/tex; mode=display">p_{\text {interp }}(r)=\max _{r^{\prime} \mathrm{H} r} p\left(r^{\prime}\right)</script><p>根据插值正确率.画出插值正确率—召回率平均曲线<br><img src="20200711111350026_26373.png" alt="png"></p><ul><li>MAP(mean average precision)平均正确率值列表.<br>形式化地，假定信息需求qj∈Q对应的所有相关文档集合<br>为${d<em>1, . . . d</em>{mj}}，R_{jk}$是返回结果中直到遇见$d_k$后其所在位置前（含$d_k$）的所有文档集合，则有</li></ul><script type="math/tex; mode=display">\operatorname{MAP}(Q)=\frac{1}{|Q|} \sum_{j=1}^{|Q|} \frac{1}{m_{j}} \sum_{k=1}^{m_{j}} \operatorname{Prcision}\left(R_{j k}\right)</script><p>如果某篇相关文档未返回，那么上式中其对应的正确率值为0。对于单个信息需求来说，平均正确率是未插值的正确率—召回率曲线下面的面积的近似值，因此，MAP可以粗略地认为是某个查询集合对应的多条正确率—召回率曲线下面积的平均值<br><img src="20200711141728462_15451.png" alt="png"><br><a href="https://blog.csdn.net/leviopku/article/details/80835929" target="_blank" rel="noopener">MAP参考</a></p><ul><li><p>P@k, 在上述基础上,只计算前K个结果的正确率, 该指标的优点九十一不需要计算相关文档的集合数目, 缺点是不稳定, 因为相关文档的总数会对P@k有非常强的影响.</p></li><li><p>R-precision</p></li><li>ROC</li><li>NDCG</li></ul><p>CG表示将每个结果相关性的分值累加后作为整个列表的得分</p><script type="math/tex; mode=display">C G_{k}=\sum_{i=1}^{k} r e l_{i}$$此时没有考虑顺序.$$DCG_k = \sum_{i = 1}^{k} \frac{2^{rel_i} - 1}{log_2(i + 1)}</script><p>同指标P@k一样，它基于前k个检索结果进行计算。设$R(j,d)$是评价人员给出的文档d对查询 j 的相关性得分，那么有</p><script type="math/tex; mode=display">\operatorname{NDCG}(Q, k)=\frac{1}{|Q|} \sum_{j=1}^{|Q|} Z_{j, k} \sum_{m=1}^{k} \frac{2^{R(j, m)}-1}{\log (1+m)}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检索系统的评价&quot;&gt;&lt;a href=&quot;#检索系统的评价&quot; class=&quot;headerlink&quot; title=&quot;检索系统的评价&quot;&gt;&lt;/a&gt;检索系统的评价&lt;/h1&gt;&lt;h3 id=&quot;无序的检索结果评价&quot;&gt;&lt;a href=&quot;#无序的检索结果评价&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://yoursite.com/categories/NLP/"/>
    
    
  </entry>
  
</feed>

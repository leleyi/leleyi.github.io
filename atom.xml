<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FILE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-22T14:18:15.312Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Les</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之ReplicateLog</title>
    <link href="http://yoursite.com/2020/11/22/Raft_AppendEntries/"/>
    <id>http://yoursite.com/2020/11/22/Raft_AppendEntries/</id>
    <published>2020-11-22T05:40:15.000Z</published>
    <updated>2020-12-22T14:18:15.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ReplicateLog"><a href="#ReplicateLog" class="headerlink" title="ReplicateLog"></a>ReplicateLog</h3><p><img src="1.png" alt="png"></p><p><strong>ReplicateLog</strong>是整个Raft中的关键地方.所有的信息都是通过AppendEntries的方式通知到所有节点.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReplicateLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.group().isStandalone()) &#123;</span><br><span class="line">        context.log().advanceCommitIndex(context.log().getNextIndex() - <span class="number">1</span>, role.getTerm());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 GroupMembers 信息决定发送的数据</span></span><br><span class="line">    <span class="keyword">for</span> (GroupMember member : context.group().listReplicationTarget()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (member.shouldReplicate(context.config().getLogReplicationReadTimeout())) &#123;</span><br><span class="line">            doReplicateLog(member, context.config().getMaxReplicationEntries());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry包括几种信息:</p><ol><li><p>no-op. 存粹的心跳.</p></li><li><p>普通信息. curd</p></li><li><p>配置信息. 整个集群的配置.</p><p>​                                                                                                                                                                            </p><p><img src="2.png" alt="png">                                        </p></li></ol><h4 id="NoOpEntry"><a href="#NoOpEntry" class="headerlink" title="NoOpEntry"></a>NoOpEntry</h4><p>普通的心跳信息，当节点当选Leader之后。没有Client的数据请求， Leader需要和Follower保证相互之间是活着的。Leader将一直发送该消息。</p><h4 id="GeneralEntry"><a href="#GeneralEntry" class="headerlink" title="GeneralEntry"></a>GeneralEntry</h4><h5 id="create-and-send"><a href="#create-and-send" class="headerlink" title="create and send"></a>create and send</h5><p>这个通过GenerEntry让节点之间保持最终一致性.</p><ul><li><p>每个节点都是有Log信息的，画了一个简图：</p><p><img src="3.png" alt="png">    </p></li></ul><p>我们可以看到一个Sequence，保存着所有的Entry。每个Entry中存有三大件 Kind ， Index ， Term. LogReplicate 就是根据 index 和 Term来进行判断的。Snapshot是在某个时候的数据快照。帮忙节点快速恢复数据。最后将数据提交到State machine。 下面哪个空白的是ConfigChangeLog.</p><p>那么给Follower发送些什么数据呢-&gt;这就要根据Leader节点记录的每一个Follower信息了。</p><ul><li>Group</li></ul><p><img src="4.png" alt="png">    </p><p>当前Leader中的Follower信息.Follower的地址,是否删除, 是否正在复制.还有比较关键的就是 NextIndex和 MatchIndex.</p><p>Follower通过比较Log的nextLogIndex, 和 GroupMember的 NextIndex.来决定发送的数据.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendEntriesRpc <span class="title">createAppendEntriesRpc</span><span class="params">(<span class="keyword">int</span> term, NodeId selfId, <span class="keyword">int</span> nextIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextLogIndex = entrySequence.getNextLogIndex();</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">if</span> (nextIndex &lt;= snapshot.getLastIncludedIndex()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EntryInSnapshotException(nextIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    AppendEntriesRpc rpc = <span class="keyword">new</span> AppendEntriesRpc();</span><br><span class="line">    rpc.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">    rpc.setTerm(term);</span><br><span class="line">    rpc.setLeaderId(selfId);</span><br><span class="line">    rpc.setLeaderCommit(commitIndex);</span><br><span class="line">    <span class="keyword">if</span> (nextIndex == snapshot.getLastIncludedIndex() + <span class="number">1</span>) &#123;</span><br><span class="line">        rpc.setPrevLogIndex(snapshot.getLastIncludedIndex());</span><br><span class="line">        rpc.setPrevLogTerm(snapshot.getLastIncludedTerm());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Entry entry = entrySequence.getEntry(nextIndex - <span class="number">1</span>);</span><br><span class="line">        rpc.setPrevLogIndex(entry.getIndex());</span><br><span class="line">        rpc.setPrevLogTerm(entry.getTerm());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!entrySequence.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex =  nextLogIndex;</span><br><span class="line">        <span class="comment">//2.1</span></span><br><span class="line">        rpc.setEntries(entrySequence.subList(nextIndex, maxIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rpc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>值得注意的是： Leader 根据每个member的信息不同是发送的不同的数据。</p><ol><li><p><strong>snapshot.LastIndex &gt; member.nextIndex</strong></p><p>member的<strong>nextIndex</strong>比我快照的<strong>最后**</strong>Index**都小,那么肯定是首先发送一个快照信息给member</p></li><li><p><strong>leader.nextlogindex &gt; member.nextIndex</strong></p><p><strong>leader</strong>的<strong>nextLogindex</strong> 大于<strong>member</strong>的<strong>index</strong> 这是最常规的.所以将Leader比member新的部分(subSequence)添加到AppendEntries里面。</p></li></ol></li><li><p>知道什么时候发送些什么之后我们再来看看AppendEntries本身应该发送些什么数据。在论文中我们可以看到</p><p><img src="5.png" alt="png">    </p><p>preLogIndex 和 prevLogTerm：他们用于和Follower进行日志的配置。</p><p>leaderCommit 将 Follower的Commit更新，避免Leader还没有Commit，Follower就Commit了</p><p>entries 自然就是Leader的角度看 Follower 所需要的信息。</p></li></ul><h4 id="receive-and-reply"><a href="#receive-and-reply" class="headerlink" title="receive and reply"></a>receive and reply</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AppendEntriesRpc rpc = rpcMessage.get();</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &lt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    becomeFollower(rpc.getTerm(), <span class="keyword">null</span>, rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rpc.term == my term</span></span><br><span class="line"><span class="keyword">switch</span> (role.getName()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOLLOWER:</span><br><span class="line">        <span class="comment">// reset election timeout and append entries</span></span><br><span class="line">        becomeFollower(rpc.getTerm(), ((FollowerNodeRole) role).getVotedFor(), rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">    <span class="keyword">case</span> CANDIDATE:</span><br><span class="line">        <span class="comment">// more than one candidate but another node won the election</span></span><br><span class="line">        becomeFollower(rpc.getTerm(), <span class="keyword">null</span>, rpc.getLeaderId(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), appendEntries(rpc));</span><br><span class="line">    <span class="keyword">case</span> LEADER:</span><br><span class="line">        <span class="comment">// todo the another leader how can deal with this condition</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendEntriesResult(rpc.getMessageId(), rpc.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unexpected node role ["</span> + role.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rpc.Term &lt; role.Term 任期不同请求来的Term没有我本身的Term大呢. 将单前节点的Term发送回去。</li><li>rpc.Term &gt; role.Term 任期不同比我的任期大,肯定是我的leader. 根据来的信息进行数据更新, 返回更新结果。</li><li>rpc.Term = role.Term  根据当前节点的角色不同 （Follower 和 Candidate），根据来的信息进行数据更新返回更新结果。</li></ul><p>值得注意的， 节点在收到消息之后角色为（Follower 和 Candidate）都会重置 ElectionTimeout。</p><p><strong>节点的数据同步</strong></p><p>当然所有数据也是通过节点的Log首先commit， 然后根据Leader的(apply)commitIndex， 进行apply.</p><ul><li>首先判断rpc.prevLogIndex rpc，prevLogTrem与当前节点的Index是否能够匹配的上。及查询当前节点是否有prevLogIndex数据-&gt; 1.根据快照 2. 更具log序列获取。</li><li>确保当前节点存在pervLog数据时， 删除Follower的未匹配（followerEntryMeta.Term() != leaderEntry.Term()）节点。</li><li>为当前节点log 添加新的节点信息同样如果是ConfigChange信息将会特别的添加到ConfigList</li></ul><h4 id="appendEntriesResult"><a href="#appendEntriesResult" class="headerlink" title="appendEntriesResult"></a>appendEntriesResult</h4><ul><li>在上述 rpc.Term &lt; role.Term的时候我们返回回来的Term，因为 Leader遇到了更大的Term，所以变为Follower</li><li>检测当前节点角色.如果以及不是leader了那就没有必要处理result</li><li>根据返回消息的节点获取Leader中保存的member信息， member被删除了或者不是major的一员就不用处理。</li><li>返回消息是成功的话，将Leader的member信息更新， 并且根据Group中超过半数匹配的Index进行apply，到状态机。</li><li>继续doReplicateLog</li></ul><h4 id="GroupConfigEntry"><a href="#GroupConfigEntry" class="headerlink" title="GroupConfigEntry"></a>GroupConfigEntry</h4><p>这一部分留到改变配置的时候再做详细的分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ReplicateLog&quot;&gt;&lt;a href=&quot;#ReplicateLog&quot; class=&quot;headerlink&quot; title=&quot;ReplicateLog&quot;&gt;&lt;/a&gt;ReplicateLog&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之VoteRequest</title>
    <link href="http://yoursite.com/2020/11/15/Raft_VoteRequest/"/>
    <id>http://yoursite.com/2020/11/15/Raft_VoteRequest/</id>
    <published>2020-11-15T05:40:15.000Z</published>
    <updated>2020-12-18T12:36:44.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LeaderElection"><a href="#LeaderElection" class="headerlink" title="LeaderElection"></a>LeaderElection</h3><p>在之前我们在connector的阶段以及简单使用VoteRequestRPC作为例子来说明底层的网络通信.一节我将详细记录LeaderElection阶段的实现.</p><p><img src="1.png" alt="png"></p><p>Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。Raft算法将时间分为一个个的<strong>任期（term）</strong>，每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p><h4 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h4><p>在之前的概述中我们大概介绍了Raft算法中节点存在有3个角色。即Leader， Candidate， Follower。并且角色中保存着任期（Term）</p><p><img src="2.png" alt="png"></p><p><strong>Candidate</strong>：其中Candidate是最为简单的，因为它只在节点选举阶段短暂存在， 节点的觉大多数时间都是Leader或者Follower。</p><p><strong>Leader</strong>：接受客户端请求，并向Follower同步请求日志（包括心跳， configChange和普通请求数据），当日志同步到大多数节点上后告诉Follower提交日志。</p><p><strong>Follower</strong>：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p><p><img src="3.png" alt="png"></p><h4 id="ElectionTimeout"><a href="#ElectionTimeout" class="headerlink" title="ElectionTimeout"></a>ElectionTimeout</h4><p>从上述UML图中我们可以看到，这里在Follower和Candidate中都已一个electionTimeout字段。ElectionTimeout类中封装了倒计时的Future.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ElectionTimeout <span class="title">scheduleElectionTimeout</span><span class="params">(@Nonnull Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * task : context.taskExecutor().submit(this::doProcessElectionTimeout, LOGGING_FUTURE_CALLBACK);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> timeout = electionTimeoutRandom.nextInt(maxElectionTimeout - minElectionTimeout) + minElectionTimeout;</span><br><span class="line">    ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.schedule(task, timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElectionTimeout(scheduledFuture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Follower在运行的时候就会有一个electionTimeout倒计时钟，防止节点长时间没有收到消息。</p><ul><li>所以当Follower 和Candidate收到来自其他节点的消息的时候都会重置electionTimeout。</li><li>当超时还没有收到消息节点将会转换为Candidate并发起投票请求。</li></ul><h4 id="投票请求（candidate）"><a href="#投票请求（candidate）" class="headerlink" title="投票请求（candidate）"></a>投票请求（candidate）</h4><p>问题来了，节点同时启动到底是谁成为Candidate呢。其实electionTimout的倒计时时间每个节点都在在一个范围内取得随机值。谁先触发超时，谁就先成为Candidate并发起投票请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">changeToRole(<span class="keyword">new</span> CandidateNodeRole(oldTerm + <span class="number">1</span>, scheduleElectionTimeout()));</span><br><span class="line">            EntryMeta lastEntryMeta = context.log().getLastEntryMeta();</span><br><span class="line">            RequestVoteRpc rpc = <span class="keyword">new</span> RequestVoteRpc();</span><br><span class="line">            rpc.setTerm(newTerm);</span><br><span class="line">            rpc.setCandidateId(context.selfId());</span><br><span class="line">            rpc.setLastLogIndex(lastEntryMeta.getIndex());</span><br><span class="line">            rpc.setLastLogTerm(lastEntryMeta.getTerm());</span><br><span class="line">context.connector().sendRequestVote(rpc, context.group().listEndpointOfMajorExceptSelf());</span><br></pre></td></tr></table></figure><h4 id="收到投票请求（members）"><a href="#收到投票请求（members）" class="headerlink" title="收到投票请求（members）"></a>收到投票请求（members）</h4><p>当其他节点收到这个投票请求。根据请求的Term和角色进行相应的回复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip non-major node, it maybe removed node</span></span><br><span class="line"><span class="keyword">if</span> (!context.group().isMemberOfMajor(rpcMessage.getSourceNodeId())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reply current term if result's term is smaller than current one</span></span><br><span class="line">RequestVoteRpc rpc = rpcMessage.get();</span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &lt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// step down if result's term is larger than current term</span></span><br><span class="line"><span class="keyword">if</span> (rpc.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> voteForCandidate = !context.log().isNewerThan(rpc.getLastLogIndex(), rpc.getLastLogTerm());</span><br><span class="line">    becomeFollower(rpc.getTerm(), (voteForCandidate ? rpc.getCandidateId() : <span class="keyword">null</span>), <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(rpc.getTerm(), voteForCandidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (role.getName()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOLLOWER:</span><br><span class="line">        FollowerNodeRole follower = (FollowerNodeRole) role;</span><br><span class="line">        NodeId votedFor = follower.getVotedFor();</span><br><span class="line">        <span class="comment">// reply vote granted for</span></span><br><span class="line">        <span class="comment">// 1. not voted and candidate's log is newer than self</span></span><br><span class="line">        <span class="comment">// 2. voted for candidate</span></span><br><span class="line">        <span class="keyword">if</span> ((votedFor == <span class="keyword">null</span> &amp;&amp; !context.log().isNewerThan(rpc.getLastLogIndex(), rpc.getLastLogTerm())) ||</span><br><span class="line">                Objects.equals(votedFor, rpc.getCandidateId())) &#123;</span><br><span class="line">            becomeFollower(role.getTerm(), rpc.getCandidateId(), <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(rpc.getTerm(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">case</span> CANDIDATE: <span class="comment">// voted for self</span></span><br><span class="line">    <span class="keyword">case</span> LEADER:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestVoteResult(role.getTerm(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unexpected node role ["</span> + role.getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先检测是不是我配置文件配置的一家人啊。正所谓不是一家人不进一家门。 不是 不投票（避免新配置的节点干坏事）</p></li><li><p>再来看看你的任期有没有我的任期大。哟你的任期还没有我的任期高呢 你有什么资格 。 不投票</p><p>rpc.getTerm() &lt; role.getTerm()</p></li><li><p>你的任期比我的高，你是爸爸。 再看看Logindex 呢。 如果logIndex比我的小。 不投票 否则立马成为你的马仔Follower并投票。</p></li><li><p>当任期相等，需要看看当前我的自己的角色是什么啊。是follower更具index判断投票与否，是candidate 已经给自己投票了。leader肯定久更不会投票了 。</p></li></ul><p>总结一下 ： 节点收到消息之后，给Candidate投票的情况其实就很明确的两种情况</p><ul><li><ol><li>节点的任期（Term）小于请求的任期。</li></ol></li><li><ol><li>任期相等的时候，还需要判断下当前节点的角色，本身是Follower，根据logindex来判断是否投票，切换领导。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpcMessage.getChannel().writeRequestVoteResult(result);</span><br></pre></td></tr></table></figure><p>节点收到消息并且处理完之后肯等就是返回处理结果了。</p><h4 id="收到投票结果（candidate）"><a href="#收到投票结果（candidate）" class="headerlink" title="收到投票结果（candidate）"></a>收到投票结果（candidate）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.getTerm() &gt; role.getTerm()) &#123;</span><br><span class="line">    <span class="comment">// remote node have large term， I will never become a Leader -&gt; change to follower</span></span><br><span class="line">    becomeFollower(result.getTerm(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check role  </span></span><br><span class="line"><span class="keyword">if</span> (role.getName() != RoleName.CANDIDATE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do nothing if not vote granted</span></span><br><span class="line"><span class="keyword">if</span> (!result.isVoteGranted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> currentVotesCount = ((CandidateNodeRole) role).getVotesCount() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> countOfMajor = context.group().getCountOfMajor();</span><br><span class="line">role.cancelTimeoutOrTask();</span><br><span class="line"><span class="keyword">if</span> (currentVotesCount &gt; countOfMajor / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// become leader</span></span><br><span class="line">    resetReplicatingStates();</span><br><span class="line">    changeToRole(<span class="keyword">new</span> LeaderNodeRole(role.getTerm(), scheduleLogReplicationTask()));</span><br><span class="line">    context.log().appendEntry(role.getTerm()); <span class="comment">// no-op log</span></span><br><span class="line">    context.connector().resetChannels(); <span class="comment">// close all inbound channels</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update votes count</span></span><br><span class="line">    changeToRole(<span class="keyword">new</span> CandidateNodeRole(role.getTerm(), currentVotesCount, scheduleElectionTimeout()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当candidate收到投票结果之后</p><ul><li>如果收到的结果中任期（Term） 比自己的高。说明member的任期高，并且没有给我投票的。而且自己遇到了高任期就该立马认怂。成为Follower</li><li>如果我当前已经不是Candidate了那投票也就没有意义了。</li><li>查看投票结果<ul><li>如果投票True说明我获取到了当前票。计算我的总票数<ul><li>如果总票数 大于一半 - 成为Leader ——&gt;去做leader该做的事情</li><li>否则更新自己的票数，继续等待投票</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LeaderElection&quot;&gt;&lt;a href=&quot;#LeaderElection&quot; class=&quot;headerlink&quot; title=&quot;LeaderElection&quot;&gt;&lt;/a&gt;LeaderElection&lt;/h3&gt;&lt;p&gt;在之前我们在connector的阶段以及简单
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之Executor , Scheduler</title>
    <link href="http://yoursite.com/2020/11/14/Raft_RPC_Executor/"/>
    <id>http://yoursite.com/2020/11/14/Raft_RPC_Executor/</id>
    <published>2020-11-14T08:23:12.000Z</published>
    <updated>2020-12-19T02:52:52.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="png"></p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p><img src="2.png" alt="png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在每个节点中我们主要的任务有两个最基础的任务, 1. 是ElectionTimeout 任务,选举时发挥作用, 首先timeout的转换为Candidate. 还有就是我日志复制需要一个Leader需要定时调度发送AppendEntries. (心跳, 数据, 配置修改).</p><p>所以在在发送这些请求或者执行这些任务的时候.我需要新开线程进行执行.-&gt;防止阻塞.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    Future&lt;?&gt; submit(<span class="meta">@Nonnull</span> Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit callable task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;  result type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    &lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(@Nonnull Callable&lt;V&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task with callback.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task     task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(@Nonnull Runnable task, @Nonnull FutureCallback&lt;Object&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submit task with callbacks.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callbacks callbacks, should not be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(@Nonnull Runnable task, @Nonnull Collection&lt;FutureCallback&lt;Object&gt;&gt; callbacks)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shutdown.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule log replication task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> log replication task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function">LogReplicationTask <span class="title">scheduleLogReplicationTask</span><span class="params">(@Nonnull Runnable task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedule election timeout.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> election timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function">ElectionTimeout <span class="title">scheduleElectionTimeout</span><span class="params">(@Nonnull Runnable task)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="png"></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>所有的操作实际上都将由Execute中的线程完成.</p><h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>调度任务:</p><ol><li>ElectionTimeout任务.时间超时就会执行相应的逻辑.</li><li>LogReplication任务.定时的发送LogReplication数据包.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务调度&quot;&gt;&lt;a href=&quot;#任务调度&quot; class=&quot;headerlink&quot; title=&quot;任务调度&quot;&gt;&lt;/a&gt;任务调度&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;2.png&quot; alt=&quot;png&quot;&gt;
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之Connector</title>
    <link href="http://yoursite.com/2020/11/13/Raft_RPC_Connector/"/>
    <id>http://yoursite.com/2020/11/13/Raft_RPC_Connector/</id>
    <published>2020-11-13T04:40:15.000Z</published>
    <updated>2020-12-12T07:28:35.651Z</updated>
    
    <content type="html"><![CDATA[<p><img src="1.png" alt="png"></p><h2 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h2><p><img src="2.png" alt="png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>connector</strong> 是Raft中基础的一部分.每个节点需要和其他节点相互连接.所有的RPC都是通过最终都是要经过Connector中通过节点之间的TCP连接.负责将数据传输</p><p>因为每个节点既可以作为Server . 也可以作为Client. 所以我们需要由 InboundChannelGroup 和 OutboundChannelGroup 分别记录与每个节点的网络连接。</p><ul><li><p><strong>InboundChannelGroup</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;NioChannel&gt; channels = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>OutboundChannelGroup</strong></p><p>OutboundChannelGroup 相对就要复杂一些了。我们将Out 看作Client. 所以我们需要复制connect， 并且记录Channel. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as a client</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutboundChannelGroup</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(OutboundChannelGroup<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NodeId selfNodeId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> connectTimeoutMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;NodeId, Future&lt;NioChannel&gt;&gt; channelMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    OutboundChannelGroup(EventLoopGroup workerGroup, EventBus eventBus, NodeId selfNodeId, <span class="keyword">int</span> logReplicationInterval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.workerGroup = workerGroup;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.selfNodeId = selfNodeId;</span><br><span class="line">        <span class="keyword">this</span>.connectTimeoutMillis = logReplicationInterval / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NioChannel <span class="title">connect</span><span class="params">(NodeId nodeId, Address address)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, <span class="title">connectTimeoutMillis</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ToRemoteHandler(eventBus, nodeId, selfNodeId));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        ChannelFuture future = bootstrap.connect(address.getHost(), address.getPort()).sync();</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to connect"</span>, future.cause());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; connected"</span>, nodeId);</span><br><span class="line">        Channel nettyChannel = future.channel();</span><br><span class="line">        nettyChannel.closeFuture().addListener((ChannelFutureListener) cf -&gt; &#123;</span><br><span class="line">            logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; disconnected"</span>, nodeId);</span><br><span class="line">            channelMap.remove(nodeId);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioChannel(nettyChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以我们的Connector 全权负责网络的连接与数据的传输。 具体的逻辑不管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioConnector</span> <span class="keyword">implements</span> <span class="title">Connector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(OutboundChannelGroup<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup bossNioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NioEventLoopGroup workerNioEventLoopGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> workerGroupShared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InboundChannelGroup inboundChannelGroup = <span class="keyword">new</span> InboundChannelGroup();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OutboundChannelGroup outboundChannelGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool((r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">thread  new <span class="title">Thread</span><span class="params">(r)</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioConnector</span><span class="params">(NioEventLoopGroup workerNioEventLoopGroup, <span class="keyword">boolean</span> workerGroupShared,</span></span></span><br><span class="line"><span class="function"><span class="params">                        NodeId selfNodeId, EventBus eventBus,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> port, <span class="keyword">int</span> logReplicationInterval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerNioEventLoopGroup = workerNioEventLoopGroup;</span><br><span class="line">        <span class="keyword">this</span>.workerGroupShared = workerGroupShared;</span><br><span class="line">        <span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        outboundChannelGroup = <span class="keyword">new</span> OutboundChannelGroup(workerNioEventLoopGroup, eventBus, selfNodeId, logReplicationInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// should not call more than once</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(bossNioEventLoopGroup, workerNioEventLoopGroup)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> FromRemoteHandler(eventBus, inboundChannelGroup));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        logger.debug(<span class="string">"node listen on port &#123;&#125;"</span>, port);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverBootstrap.bind(port).sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectorException(<span class="string">"failed to bind port"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequestVote</span><span class="params">(@Nonnull RequestVoteRpc rpc, @Nonnull Collection&lt;NodeEndpoint&gt; destinationEndpoints)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replyRequestVote</span><span class="params">(@Nonnull RequestVoteResult result, @Nonnull RequestVoteRpcMessage rpcMessage)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="png"></p><p>我通过上图来说明一下我们整个Connector网络数据发送的过程.</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>我们以Outbound为起始. 向指定node发送 一个数据 比如  RequestVoteRPC. </p><p>作为发送端. 我们从Node的Config数据. 获取到所有节点的 address. </p><ol><li>当前节点connect远程的节点. </li><li>当channelActive之后. 当前节点 将该Channel 记录下来.</li><li>当前节点再将当前节点信息通过Channel 发送给远程节点。</li><li>远程节点记录当前节点的信息并且把该channel记录。</li></ol><p>在ToRemoteHandler 和 FromRemoteHandler 中都传入了对应节点的EvetBus， 以便用RPC信息来通知Node执行相应的逻辑。</p><h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p><img src="4.png" alt="png"></p><p>建立连接之后就可以进行对应的数据的传输</p><ol><li>Candidate 发送 -&gt; 调用Connector的SendRequetVoteRPC 到指定的Node ，地址 ID 等配置中有。</li><li>Netty 底层的编码节码粘包拆包等细节处理-&gt; 远程节点收到。</li><li>远程节点判定是RequestVoteRPC， 包装Channel信息包装到RPCMessage中-&gt; event.post 通知订阅方法。onReceiveRequestVoteRpc.</li><li>Node 订阅方法触发 -&gt;处理逻辑.</li><li>逻辑处理完毕之后-&gt; 回复, 将回复信息RequestVoteRPCResult写入刚才 PRCMessage中的Chanel.</li><li>Netty 底层的编码节码粘包拆包等细节处理-&gt; RPC请求发送者收到回复.</li><li>Candidate 判定是RequestVoteRPCResult，  event.post 通知订阅方法。onReceiveRequestVoteResult</li><li>订阅方法触发-&gt;处理逻辑</li></ol><h3 id="RPC类图"><a href="#RPC类图" class="headerlink" title="RPC类图."></a>RPC类图.</h3><p><img src="rpc_uml.png" alt="png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Connector&quot;&gt;&lt;a href=&quot;#Connector&quot; class=&quot;headerlink&quot; title=&quot;Connector&quot;&gt;&lt;/a&gt;Connector&lt;/h2&gt;&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_Raft算法之RPC</title>
    <link href="http://yoursite.com/2020/11/11/Raft_PRC_Message/"/>
    <id>http://yoursite.com/2020/11/11/Raft_PRC_Message/</id>
    <published>2020-11-11T08:40:15.000Z</published>
    <updated>2020-12-18T12:40:31.624Z</updated>
    
    <content type="html"><![CDATA[<p>RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想.<br>RPC 最核心要解决的问题就是在分布式系统间，如何执行另外一个地址空间上的函数、方法，就仿佛在本地调用一样<br>RPC 主要需要处理几个核心的问题.1：代理  2.通讯  3：序列化 4：服务实例化</p><p>在我Raft中只有三种RPC请求. 所以我们不通过代理的方式进行</p><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信:"></a>网络通信:</h3><p>Netty 是一个广泛使用的 Java 网络编程框架.隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。</p><p>通过Netty 很容易实现一个高性能的网络通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// connector 初始化 之后就已经在监听了.</span></span><br><span class="line">    ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            .group(bossNioEventLoopGroup, workerNioEventLoopGroup)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> FromRemoteHandler(eventBus, inboundChannelGroup));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    logger.debug(<span class="string">"node listen on port &#123;&#125;"</span>, port);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        serverBootstrap.bind(port).sync();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConnectorException(<span class="string">"failed to bind port"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NioChannel <span class="title">connect</span><span class="params">(NodeId nodeId, Address address)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 连接到开启监听的服务器</span></span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(workerGroup)</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, <span class="title">connectTimeoutMillis</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Decoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> Encoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ToRemoteHandler(eventBus, nodeId, selfNodeId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 数据序列化处理都是再Encoder 和 Decoder， Handler 包含了一些逻辑。</span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(address.getHost(), address.getPort()).sync();</span><br><span class="line">    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to connect"</span>, future.cause());</span><br><span class="line">    &#125;</span><br><span class="line">    logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; connected"</span>, nodeId);</span><br><span class="line">    Channel nettyChannel = future.channel();</span><br><span class="line">    nettyChannel.closeFuture().addListener((ChannelFutureListener) cf -&gt; &#123;</span><br><span class="line">        logger.debug(<span class="string">"channel OUTBOUND-&#123;&#125; disconnected"</span>, nodeId);</span><br><span class="line">        channelMap.remove(nodeId);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioChannel(nettyChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化:"></a>序列化:</h3><p>Java 的序列化工具有很多.例如(<strong>Protobuf、Thrift、Avro</strong>)查询比较之后我选择了ProtoBuf (主要是资料多!)</p><p>Googel 的 ProtoBuf :protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p><blockquote><p><strong>语言无关、平台无关</strong>。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台</p><p><strong>高效</strong>。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单</p><p><strong>扩展性、兼容性好</strong>。你可以更新数据结构，而不影响和破坏原有的旧程序</p></blockquote><div class="table-container"><table><thead><tr><th>序列化工具</th><th>序列化速度</th><th>序列化文件大小</th><th>编程模型复杂度</th><th>社区活跃度</th><th>jar包大小</th></tr></thead><tbody><tr><td>kryo</td><td>极快</td><td>小</td><td>简单</td><td>高</td><td>132kb</td></tr><tr><td>fst-serializer</td><td>快</td><td>小</td><td>非常简单</td><td>高</td><td>246kb</td></tr><tr><td>protobuffer</td><td>快</td><td>较大</td><td>较复杂</td><td>稳定</td><td>329kb</td></tr><tr><td>fastjson</td><td>较快</td><td>较大</td><td>简单</td><td>一般</td><td>338kb</td></tr><tr><td>jackson</td><td>一般</td><td>较大</td><td>简单</td><td>稳定</td><td>1.1mb</td></tr><tr><td>gson</td><td>较慢</td><td>较大</td><td>简单</td><td>稳定</td><td>189kb</td></tr></tbody></table></div><p><strong>高效</strong>。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单</p><p><strong>扩展性、兼容性好</strong>。你可以更新数据结构，而不影响和破坏原有的旧程序.</p><p> 需要预先创建Message 即 <strong>.proto文件定义数据结构.</strong> </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">"org.les"</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"Protos"</span>;</span><br><span class="line"><span class="comment">// common</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">NodeEndpoint</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> host = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> port = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">RequestVoteRpc</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> term = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> candidate_id = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> last_log_index = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int32</span> last_log_term = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>protoc 编译</strong> .proto 文件生成读写接口</p><p>在windows如何使用protoc 编译.proto文件<a href="https://leleyi.github.io/2020/10/28/windows protobuf/#more" target="_blank" rel="noopener">简单的windows protobuf .proto文件编译 | FILE (leleyi.github.io)</a> 见该文章.</p><p><strong>调用接口实现序列化、反序列化以及读写</strong></p><h4 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h4><p>在发出 ProtoMsg.Message 消息前，还需要对二进制消息进一步封装。</p><p>需要预先规定好数据的格式。如下： Type + Length + VAR 分别占了4， 4 + len（VAR）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Protos.RequestVoteRpc protoRpc = Protos.RequestVoteRpc.newBuilder()</span><br><span class="line">                    .setTerm(rpc.getTerm())</span><br><span class="line">                    .setCandidateId(rpc.getCandidateId().getValue())</span><br><span class="line">                    .setLastLogIndex(rpc.getLastLogIndex())</span><br><span class="line">                    .setLastLogTerm(rpc.getLastLogTerm())</span><br><span class="line">                    .build();</span><br><span class="line">     <span class="keyword">this</span>.writeMessage(out, MessageConstants.TYPE, protoResult);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ByteBuf out, <span class="keyword">int</span> messageType, MessageLite message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ByteArrayOutputStream byteOutput = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    message.writeTo(byteOutput);</span><br><span class="line">    out.writeInt(messageType);</span><br><span class="line">    <span class="keyword">this</span>.writeBytes(out, byteOutput.toByteArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeMessage</span><span class="params">(ByteBuf out, <span class="keyword">int</span> messageType, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4 + 4 + VAR</span></span><br><span class="line">    out.writeInt(messageType);</span><br><span class="line">    <span class="keyword">this</span>.writeBytes(out, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(ByteBuf out, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    out.writeInt(bytes.length);</span><br><span class="line">    out.writeBytes(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码器-通过先前的-统一规定-对信息进行解码。"><a href="#解码器-通过先前的-统一规定-对信息进行解码。" class="headerlink" title="解码器 通过先前的 统一规定 对信息进行解码。"></a>解码器 通过先前的 统一规定 对信息进行解码。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> availableBytes = in.readableBytes();</span><br><span class="line"><span class="keyword">if</span> (availableBytes &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.markReaderIndex();</span><br><span class="line"><span class="keyword">int</span> messageType = in.readInt();</span><br><span class="line"><span class="keyword">int</span> payloadLength = in.readInt();</span><br><span class="line"><span class="keyword">if</span> (in.readableBytes() &lt; payloadLength) &#123;</span><br><span class="line">    in.resetReaderIndex();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">     ByteBuf frame = Unpooled.buffer(length);</span><br><span class="line">     in.readBytes(frame);</span><br><span class="line">    <span class="comment">// 处理数据帧。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Netty中的Handler 来处理具体的任务逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> remoteId != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> channel != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前收到的消息.</span></span><br><span class="line">    <span class="comment">// 收到请求投票</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RequestVoteRpc) &#123;</span><br><span class="line">        System.out.println(<span class="string">"type requestVote"</span>);</span><br><span class="line">        RequestVoteRpc rpc = (RequestVoteRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> RequestVoteRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到投票结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RequestVoteResult) &#123;</span><br><span class="line">        eventBus.post(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到追加信息</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> AppendEntriesRpc) &#123;</span><br><span class="line">        AppendEntriesRpc rpc = (AppendEntriesRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> AppendEntriesRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到追加信息结果 同样是 heart beart信息.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> AppendEntriesResult) &#123;</span><br><span class="line">        AppendEntriesResult result = (AppendEntriesResult) msg;</span><br><span class="line">        <span class="keyword">if</span> (lastAppendEntriesRpc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"no last append entries rpc"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(result.getRpcMessageId(), lastAppendEntriesRpc.getMessageId())) &#123;</span><br><span class="line">                logger.warn(<span class="string">"incorrect append entries rpc message id &#123;&#125;, expected &#123;&#125;"</span>, result.getRpcMessageId(), lastAppendEntriesRpc.getMessageId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eventBus.post(<span class="keyword">new</span> AppendEntriesResultMessage(result, remoteId, lastAppendEntriesRpc));</span><br><span class="line">                lastAppendEntriesRpc = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> InstallSnapshotRpc) &#123;</span><br><span class="line">        InstallSnapshotRpc rpc = (InstallSnapshotRpc) msg;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> InstallSnapshotRpcMessage(rpc, remoteId, channel));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> InstallSnapshotResult) &#123;</span><br><span class="line">        InstallSnapshotResult result = (InstallSnapshotResult) msg;</span><br><span class="line">        <span class="keyword">assert</span> lastInstallSnapshotRpc != <span class="keyword">null</span>;</span><br><span class="line">        eventBus.post(<span class="keyword">new</span> InstallSnapshotResultMessage(result, remoteId, lastInstallSnapshotRpc));</span><br><span class="line">        lastInstallSnapshotRpc = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到收到消息同解码之后.根据消息类型进行对应的程序调用. 这里用到的是观察者的方式.通过事件通知相应订阅者.</p><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p><strong>EventBus</strong> 是一个开源库，它利用发布/订阅者者模式来对项目进行解耦。Publisher（发布者）通过post（）方法，把Event事件发布出去，Subscriber（订阅者）在onEvent（）方法中接收事件.</p><p>上述的post方法主要做了这么几件事：</p><ol><li><p>根据传入的Event获取对应的订阅列表subscribers</p></li><li><p>遍历subscribers</p></li><li><p>如果订阅者是异步的，那么就使用线程池启动执行任务</p></li><li><p>如果是同步的那么就调用handleEvent方法向订阅者发布消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnReceiveRequestVoteRpc</span><span class="params">(RequestVoteRpcMessage rpcMessage)</span> </span>&#123;</span><br><span class="line">    context.taskExecutor().submit(()</span><br><span class="line">            -&gt; context.connector().replyRequestVote(doProcessRequestVoteRpc(rpcMessage), rpcMessage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>例如: RequestVotePRC  调用之后. 通过 Ecoder 编码 - 网络传输 - Dcoder 解码  -&gt; 根据请求类型 进行事件的POST. 而订阅者的订阅方法 触发执行逻辑.</p><p>参考:</p><p><a href="https://www.cnblogs.com/luozhiyun/p/11324181.html" target="_blank" rel="noopener">https://www.cnblogs.com/luozhiyun/p/11324181.html</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/overview</a></p><p><a href="https://www.baeldung.com/netty" target="_blank" rel="noopener">https://www.baeldung.com/netty</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想.&lt;br&gt;RPC 最核心要解决的问题就是在分布式系统间，如何执行另外一个地址空间上的函数、方法，就仿佛在本地调用一样&lt;br&gt;RPC 
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java实现Raft算法_理论知识</title>
    <link href="http://yoursite.com/2020/11/09/Java%E5%AE%9E%E7%8E%B0Raft%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/09/Java实现Raft算法/</id>
    <published>2020-11-09T08:40:15.000Z</published>
    <updated>2020-12-10T11:27:46.566Z</updated>
    
    <content type="html"><![CDATA[<p>CAP原则又称CAP定理[2000]，指的是在一个分布式系统中，<strong>一致性</strong>（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。<br><strong>一致性：</strong>多个数据副本之间数据能否保持一致。<br><strong>可用性：</strong>读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作。<br><strong>分区容错性：</strong>单台服务器，或多台服务器出问题（主要是网络问题）后，正常服务的服务器依然能正常提供服务，并且满足设计好的一致性和可用性。</p><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p><p><strong>最终一致性</strong>（Eventually Consistent）：最终一致性是强调系统中所有的数据副本，在经过一段时间的同步之后，最终能够达到一直的状态。即没有保证实时的数据一致。</p><p>Raft算法为了保证高可用，并不是强一致性，而是最终一致性。</p><p><strong>1.分布式一致性算法</strong><br>Paxos<br><strong>Raft</strong>：Raft more understandable than Paxos and also provides a better foundation for building practical systems<br>ZAB</p><h3 id="一、Raft算法概述"><a href="#一、Raft算法概述" class="headerlink" title="一、Raft算法概述"></a>一、Raft算法概述</h3><p><strong>Raft</strong>是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法。</p><p>它将分布式一致性分解为多个子问题：Leader选举（Leader election）、日志复制（Log replication）、安全性（Safety）、日志压缩（Log compaction）等<br><strong>Leader：</strong>接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</p><p><strong>Follower：</strong>接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p><p><strong>Candidate：</strong>Leader选举过程中的临时角色</p><p><img src="1.png" alt="png"></p><p>  可以看出所有节点启动时都是<strong>Follower</strong>状态；在一段时间内如果没有收到来自<strong>leader</strong>的心跳，从Follower切换到candidate，发起选举；如果收到majority的造成票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到Follower。</p><p>Raft 算法将时间划分成为任意不同长度的任期（Term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（<strong>election</strong>），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。</p><p><strong>Term：</strong></p><p>Term（任期）以选举（Election）开始，然后就是一段或长或短的稳定工作期（normal Operation）</p><p><img src="2.png" alt="png"></p><h3 id="二、Leader选举"><a href="#二、Leader选举" class="headerlink" title="二、Leader选举"></a>二、Leader选举</h3><p>每个节点都会有一个 <strong>ElectionTimeout </strong>计时，如果该节点在该时间内没有收到来自 Leader 或者其他Node 的信息，那么该节点就会发起选举。</p><ul><li>增加节点本地的 current term，切换到candidate状态</li><li>投自己一票</li><li>并行给其他节点发送 <em>RequestVote RPCs</em></li><li><p>等待其他节点的回复</p><p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p></li></ul><ul><li>收到majority的投票（含自己的一票），则赢得选举，成为Leader </li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>一段时间内没有收到majority投票，则保持Candidate状态，重新发出选举。</li></ul><h3 id="三、日志复制（保证数据一致性）"><a href="#三、日志复制（保证数据一致性）" class="headerlink" title="三、日志复制（保证数据一致性）"></a>三、日志复制（保证数据一致性）</h3><blockquote><p>当选Leader 之后 就会调用 AppendEntriesRPC 将发送 no-op Log</p></blockquote><p>客户端收到的请求之后 Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC复制日志条目.</p><ul><li>Leader 追加日志条目</li><li>Leader 发送<em>AppendEntries RPC</em></li><li>Leader 等待多数人回应</li><li>Leader 将条目应用到状态机</li><li>Leader 回复 Client</li><li>Leader 通知 Follower 申请日志</li></ul><p> <strong>日志由有序编号（log index）的日志item组成</strong>。<strong>每个日志条目包含它被创建时的任期号（term）和用于状态机执行的命令</strong>。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。</p><p><img src="3.png" alt="png"></p><p>提交的日志都将通过<strong>状态机</strong>持久化到磁盘中</p><p><strong>日志的一致性</strong></p><p><img src="4.png" alt="png"></p><p>复制时保证数据一致</p><ul><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的（原因：leader 最多在一个任期里的一个日志索引位置创建一条日志条目，日志条目在日志的位置从来不会改变）。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的（原因：每次 RPC 发送附加日志时，leader 会把这条日志条目的前面的日志的下标和任期号一起发送给 Follower，如果 Follower 发现和自己的日志不匹配，那么就拒绝接受这条日志，这个称之为一致性检查）。</li></ul><p>Leader崩溃导致数据不一致.</p><p><strong>一个Follower可能会丢失掉Leader上的一些条目，也有可能包含一些Leader没有的条目，也有可能两者都会发生</strong>。丢失的或者多出来的条目可能会持续多个任期。</p><ul><li>Leader通过强制Followers复制它的日志来处理日志的不一致，Followers上的不一致的日志会被Leader的日志覆盖。Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目。</li><li>具体的操作是：Leader会从后往前试，每次 AppendEntries 失败后尝试前一个日志条目，直到成功找到每个Follower的日志一致位置点（基于上述的两条保证），然后向后逐条覆盖Followers在该位置之后的条目。</li></ul><p><strong>Replicated 状态机</strong> </p><p>一致性算法都会涉及到状态机，而状态机保证系统从一个一致的状态开始，以相同的顺序执行一些列指令最终会达到另一个一致的状态。</p><h3 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h3><p><img src="5.png" alt="png"></p><ul><li>拥有<strong>最新的已提交的log entry的Follower才有资格成为leader</strong>。</li><li><strong>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志</strong>，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li></ul><h3 id="五、日志压缩"><a href="#五、日志压缩" class="headerlink" title="五、日志压缩"></a>五、日志压缩</h3><p><img src="6.png" alt="png"></p><p>在实际的系统中，不能让<strong>日志无限增长</strong>，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行<strong>snapshot</strong>来解决，snapshot之前的日志都可以丢弃（以前的数据已经落盘了）。每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p><p>【<strong>Snapshot中包含以下内容</strong>】：</p><ul><li><strong>日志元数据，最后一条已提交的 log entry的 log index和term</strong>。这两个值在snapshot之后的第一条log entry的<em>AppendEntries RPC</em>的完整性检查的时候会被用上。</li><li><strong>系统当前状态</strong>。</li></ul><p>  当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用<em>InstalledSnapshot RPC</em></p><p>  做snapshot既不要做的太频繁，否则<strong>消耗磁盘带宽</strong>， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。<strong>推荐当日志达到某个固定的大小做一次snapshot</strong>。</p><p>  做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h3 id="六、成员变更"><a href="#六、成员变更" class="headerlink" title="六、成员变更"></a>六、成员变更</h3><p><img src="7.png" alt="png"></p><p>我们先将成员变更请求当成普通的写请求，由领导者得到多数节点响应后，每个节点提交成员变更日志，将从旧成员配置（$C<em>{old}$）切换到新成员配置（$C</em>{new}$)。但每个节点提交成员变更日志的时刻可能不同，这将造成各个服务器切换配置的时刻也不同，这就有可能选出两个领导者，破坏安全性。</p><p>考虑以下这种情况：集群配额从 3 台机器变成了 5 台，可能存在这样的一个时间点，两个不同的领导者在同一个任期里都可以被选举成功（双主问题），一个是通过旧的配置，一个通过新的配置。简而言之，成员变更存在的问题是增加或者减少的成员太多了，导致旧成员组和新成员组没有交集，因此出现了双主节点.</p><p><strong>Raft解决方法是每次成员变更只允许增加或删除一个成员（如果要变更多个成员，连续变更多次）</strong>。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC."></a>RPC.</h3><p>在上述 我们有三种 RPC 请求. </p><p>RequestVoteRPC : 候选人发送投票请求.</p><p>AppendEntriesRPC: 日志复制. 包括了 no-op (刚成为Leader). 普通的Entries 如(CURD).成员变更的信息.</p><p>InstallSnapshotRPC: 通过快照给落后的Follower. 或者时刚来的Follower.</p><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/98627822" target="_blank" rel="noopener">RAFT算法详解_青萍之末的博客-CSDN博客_raft算法</a></p><p><a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">Raft Consensus Algorithm</a></p><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">In Search of an Understandable Consensus Algorithm (raft.github.io)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAP原则又称CAP定理[2000]，指的是在一个分布式系统中，&lt;strong&gt;一致性&lt;/strong&gt;（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>linux中v2ray以及proxychains</title>
    <link href="http://yoursite.com/2020/11/09/v2ray/"/>
    <id>http://yoursite.com/2020/11/09/v2ray/</id>
    <published>2020-11-09T04:40:15.000Z</published>
    <updated>2021-01-23T08:15:12.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="V2Ray-搭建"><a href="#V2Ray-搭建" class="headerlink" title="V2Ray 搭建"></a>V2Ray 搭建</h3><ul><li><p>安装 wget</p></li><li><p>下载脚本</p><p>安装完 wget 之后就可以进行下载操作了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>执行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash go.sh</span><br></pre></td></tr></table></figure></li></ul><pre><code>显示一下信息代表安装成功:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ts@ubuntu v2ray]$ sudo bash go.sh Installing V2Ray v3.14 on x86_64Downloading V2Ray.%Total%Received%XferdAverageSpeedTimeTimeTimeCurrentDloadUploadTotalSpentLeftSpeed10060806080022290--:--:----:--:----:--:--22351008482k1008482k002501k00:00:030:00:03--:--:--2813kExtracting V2Ray package to /tmp/v2ray.Archive:/tmp/v2ray/v2ray.zip   creating:/tmp/v2ray/v2ray-v3.14-linux-64/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/geoip.dat    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/geosite.dat    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/readme.md     creating:/tmp/v2ray/v2ray-v3.14-linux-64/systemd/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/systemd/v2ray.service     creating:/tmp/v2ray/v2ray-v3.14-linux-64/systemv/  inflating:/tmp/v2ray/v2ray-v3.14-linux-64/systemv/v2ray    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/v2ctl   extracting:/tmp/v2ray/v2ray-v3.14-linux-64/v2ctl.sig    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/v2ray   extracting:/tmp/v2ray/v2ray-v3.14-linux-64/v2ray.sig    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/vpoint_socks_vmess.json    inflating:/tmp/v2ray/v2ray-v3.14-linux-64/vpoint_vmess_freedom.json  PORT:13437UUID:f500ecf5-e135-49c6-9ce2-78eb490d0aa9Created symlink from/etc/systemd/system/multi-user.target.wants/v2ray.service to /etc/systemd/system/v2ray.service.V2Ray v3.14is installed.</span><br></pre></td></tr></table></figure>好了到这里我们就搭建成功了</code></pre><ul><li><p>如果要更新</p><p>更新 V2Ray 的方法是再次执行安装脚本！再次执行安装脚本！再次执行安装脚本！</p></li></ul><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>在首次安装完成之后，V2Ray 不会自动启动，需要手动运行上述启动命令。</p><p>而在已经运行 V2Ray 的 VPS 上再次执行安装脚本，安装脚本会自动停止 V2Ray 进程，升级 V2Ray 程序，然后自动运行 V2Ray。在升级过程中，配置文件不会被修改。</p><ul><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装完成之后，需要对服务器端、客户端进行配置才能进行使用，配置文件位于 / etc/v2ray/config.json：</p><p>v2ray 支持多种协议，针对不同的协议需要进行不同的配置，下面是各种协议对应的服务端配置：</p><ul><li><p>vmess 协议配置</p><p>按照上面的步骤安装完之后就是类似与下面的配置，如果你想使用 vmess 协议，基本不用修改，就可以使用客户端进行连接。</p><p>查看配置文件 (该配置在后面链接时使用):</p><p>如果你已经有window的可用户端, 可以直接到处config.json</p></li></ul><p><img src="1.png" alt="png"></p><p><img src="2.png" alt="png"></p><p><img src="3.png" alt="png"></p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>注意：有些系统需要开放端口或者关闭防火墙才能连接。停止防火墙请执行:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>重启防火墙:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>查看防火墙状态 not running 表示已关闭:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reloa</span><br></pre></td></tr></table></figure></code></pre><h3 id="ProxyChain-使用"><a href="#ProxyChain-使用" class="headerlink" title="ProxyChain  使用"></a>ProxyChain  使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install proxychains</span><br><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>加上一行你自己的配置端口配置</p><p><img src="4.png" alt="png"></p><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains git clone https://github.com/haad/proxychains.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;V2Ray-搭建&quot;&gt;&lt;a href=&quot;#V2Ray-搭建&quot; class=&quot;headerlink&quot; title=&quot;V2Ray 搭建&quot;&gt;&lt;/a&gt;V2Ray 搭建&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 wget&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载脚本&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>简单的windows protobuf  .proto文件编译</title>
    <link href="http://yoursite.com/2020/10/28/windows%20protobuf/"/>
    <id>http://yoursite.com/2020/10/28/windows protobuf/</id>
    <published>2020-10-28T09:57:15.000Z</published>
    <updated>2020-11-27T13:36:24.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="windows-protobuf-proto文件编译器"><a href="#windows-protobuf-proto文件编译器" class="headerlink" title="windows protobuf  .proto文件编译器"></a>windows protobuf  .proto文件编译器</h3><p><a href="https://repo1.maven.org/maven2/com/google/protobuf/protoc/" target="_blank" rel="noopener">com/google/protobuf/protoc)</a></p><p>选择你对应的编译器版本,这里我选择的是3.6.0版本的</p><p><img src="1.png" alt="png"></p><p>下载protoc-3.6.0-windows-x86_64.exe </p><p>cmd 进入到你的protoc-3.6.0-windows-x86_64.exe文件的目录</p><p>执行 protoc.exe path/to/your/proto/file —java_out=OUTPUT_DIR</p><p><img src="2.png" alt="png"></p><p><img src="3.png" alt="png"></p><p>生成成功.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;windows-protobuf-proto文件编译器&quot;&gt;&lt;a href=&quot;#windows-protobuf-proto文件编译器&quot; class=&quot;headerlink&quot; title=&quot;windows protobuf  .proto文件编译器&quot;&gt;&lt;/a&gt;win
      
    
    </summary>
    
    
      <category term="tool" scheme="http://yoursite.com/categories/tool/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 权限.</title>
    <link href="http://yoursite.com/2020/09/12/linux%E6%9D%83%E9%99%90/"/>
    <id>http://yoursite.com/2020/09/12/linux权限/</id>
    <published>2020-09-12T06:56:15.000Z</published>
    <updated>2020-12-30T06:09:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 中，增加用户或改变用户的组属性可以使用 <code>useradd</code> 或者 <code>usermod</code> 命令。<code>useradd</code> 增加一个新用户或者更新默认新用户信息。<code>usermod</code> 则是更改用户帐户属性，例如将其添加到一个已有的组中。</p><p>在 Linux 用户系统中存在两类组。第一类是主要用户组，第二类是附加用户组。所有的用户帐户及相关信息都存储在 <code>/etc/passwd</code> 文件中，<code>/etc/shadow</code> 和 <code>/etc/group</code> 文件存储了用户信息。</p><h2 id="useradd-示例-–-增加一个新用户到附加用户组-¶"><a href="#useradd-示例-–-增加一个新用户到附加用户组-¶" class="headerlink" title="useradd 示例 – 增加一个新用户到附加用户组 ¶"></a>useradd 示例 – 增加一个新用户到附加用户组 <a href="#useradd_1">¶</a></h2><p>新增加一个用户并将其列入一个已有的用户组中需要用到 <code>useradd</code> 命令。如果还没有这个用户组，可以先创建该用户组。</p><p>命令参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -G &#123;group-name&#125; username</span><br></pre></td></tr></table></figure><p>例如，我们要创建一个新用户 xjj并将其添加到用户组 developers 中。首先需要以 root 用户身份登录到系统中。先确认一下是否存在 developers 这个用户组，在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# grep developers /etc/group</span><br></pre></td></tr></table></figure><p>输出类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">developers:x:1124:</span><br></pre></td></tr></table></figure><p>如果看不到任何输出，那么就需要先创建这个用户组了，使用 <code>groupadd</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# groupadd xjj</span><br></pre></td></tr></table></figure><p>然后创建用户 xjj并将其加入到 developers 用户组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# useradd -G xjj dl</span><br></pre></td></tr></table></figure><p>为用户 xjj设置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# passwd xjj</span><br></pre></td></tr></table></figure><p>为确保已经将该用户正确的添加到 developers 用户组中，可以查看该用户的属性，使用 <code>id</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# id xjj</span><br></pre></td></tr></table></figure><p>前面命令中用到的大写的 G （-G） 参数就是为了将用户添加到一个附加用户组中，而同时还会为此用户创建一个属于他自己的新组 如果要将该用户同时增加到多个附加用户组中，可以使用英文半角的逗号来分隔多个附加组名（不要加空格）。例如，同时将 xjj 增加到 admins, ftp, www, 和 developers 用户组中，可以输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# useradd -G admins,ftp,www,developers cnzhx</span><br></pre></td></tr></table></figure><h2 id="useradd-示例-–-增加一个新用户到主要用户组-¶"><a href="#useradd-示例-–-增加一个新用户到主要用户组-¶" class="headerlink" title="useradd 示例 – 增加一个新用户到主要用户组 ¶"></a>useradd 示例 – 增加一个新用户到主要用户组 <a href="#useradd_2">¶</a></h2><p>要增加用户 xjj到组 developers，可以使用下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\# useradd -g developers xjj </span><br><span class="line"># id xjj</span><br></pre></td></tr></table></figure><p>输出类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=1123(cnzhx) gid=1124(developers) groups=1124(developers)</span><br></pre></td></tr></table></figure><p>请注意如前面的示例的区别，这里使用了小写字母 g （-g）作为参数，此时用户的主要用户组不再是 xjj而直接就是 developers。</p><p>小写字母 g （-g）将新增加的用户初始化为指定为登录组（主要用户组）。此组名必须已经存在。组号（gid）即是此已有组的组号。</p><h2 id="usermod-示例-–-将一个已有用户增加到一个已有用户组中-¶"><a href="#usermod-示例-–-将一个已有用户增加到一个已有用户组中-¶" class="headerlink" title="usermod 示例 – 将一个已有用户增加到一个已有用户组中 ¶"></a>usermod 示例 – 将一个已有用户增加到一个已有用户组中 <a href="#usermod">¶</a></h2><p>将一个已有用户 xjj增加到一个已有用户组 apache 中，使此用户组成为该用户的附加用户组，可以使用带 -a 参数的 <code>usermod</code>  指令。-a 代表 append， 也就是将用户添加到新用户组中而不必离开原有的其他用户组。不过需要与 -G 选项配合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# usermod -a -G apache xjj</span><br></pre></td></tr></table></figure><p>如果要同时将 xjj 的主要用户组改为 apache，则直接使用 -g 选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\# usermod -g apache xjj</span><br></pre></td></tr></table></figure><p>如果要将一个用户从某个组中删除，则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -d user group</span><br></pre></td></tr></table></figure><p>但是这个时候需要保证 group 不是 user 的主组。</p><h2 id="附：管理用户（user）和用户组（group）的相关工具或命令-¶"><a href="#附：管理用户（user）和用户组（group）的相关工具或命令-¶" class="headerlink" title="附：管理用户（user）和用户组（group）的相关工具或命令 ¶"></a>附：管理用户（user）和用户组（group）的相关工具或命令 <a href="#commands">¶</a></h2><p><strong>1）管理用户（user）的工具或命令</strong></p><p><code>useradd    注：添加用户  adduser    注：添加用户  passwd     注：为用户设置密码  usermod    注：修改用户命令，可以通过usermod 来修改登录名、用户的家目录等等；  pwcov      注：同步用户从/etc/passwd 到/etc/shadow  pwck       注：pwck是校验用户配置文件/etc/passwd 和/etc/shadow 文件内容是否合法或完整；  pwunconv   注：是pwcov 的立逆向操作，是从/etc/shadow和 /etc/passwd 创建/etc/passwd ，然后会删除 /etc/shadow 文件；  finger     注：查看用户信息工具  id         注：查看用户的UID、GID及所归属的用户组  chfn       注：更改用户信息工具  su         注：用户切换工具  sudo       注：sudo 是通过另一个用户来执行命令（execute a command as another user），su 是用来切换用户，然后通过切换到的用户来完成相应的任务，但sudo 能后面直接执行命令，比如sudo 不需要root 密码就可以执行root 赋与的执行只有root才能执行相应的命令；但得通过visudo 来编辑/etc/sudoers来实现；  visudo     注：visodo 是编辑 /etc/sudoers 的命令；也可以不用这个命令，直接用vi 来编辑 /etc/sudoers 的效果是一样的；  sudoedit   注：和sudo 功能差不多；</code></p><p><strong>2）管理用户组（group）的工具或命令</strong><br><code>groupadd    注：添加用户组；  groupdel    注：删除用户组；  groupmod    注：修改用户组信息  groups      注：显示用户所属的用户组  grpck  grpconv     注：通过/etc/group和/etc/gshadow 的文件内容来同步或创建/etc/gshadow ，如果/etc/gshadow 不存在则创建；  grpunconv   注：通过/etc/group 和/etc/gshadow 文件内容来同步或创建/etc/group ，然后删除gshadow文件；</code></p><p>将一个用户添加到某个组，即可让此用户拥有该组的权限。比如在<a href="https://cnzhx.net/blog/vps-centos-6-lamp-phpmyadmin/" title="Linode VPS 上 CentOS 6 安装 LAMP + phpMyAdmin 记录" target="_blank" rel="noopener">配置 VPS 上的 LAMP 服务器</a>的时候，运行网站的 apache 用户修改的文件，如果服务器管理用户 cnzhx（可以通过 ssh 登录到服务器）需要修改此文件的话，就可以将 xjj加入到 apache 组中达到目的</p><h2 id="更改文件权限-（chmod-命令）"><a href="#更改文件权限-（chmod-命令）" class="headerlink" title="更改文件权限 （chmod 命令）"></a>更改文件权限 （chmod 命令）</h2><h3 id="一般使用格式"><a href="#一般使用格式" class="headerlink" title="一般使用格式"></a>一般使用格式</h3><blockquote><p>chmod [可选项] <mode> <file...></file...></mode></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">可选项：</span><br><span class="line">  -c, --changes          like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作)</span><br><span class="line">  -f, --silent, --quiet  suppress most error messages  （若该档案权限无法被更改也不要显示错误讯息）</span><br><span class="line">  -v, --verbose          output a diagnostic <span class="keyword">for</span> every file processed（显示权限变更的详细资料）</span><br><span class="line">       --no-preserve-root  <span class="keyword">do</span> not treat <span class="string">'/'</span> specially (the default)</span><br><span class="line">       --preserve-root    fail to operate recursively on <span class="string">'/'</span></span><br><span class="line">       --reference=RFILE  use RFILE<span class="string">'s mode instead of MODE values</span></span><br><span class="line"><span class="string">  -R, --recursive        change files and directories recursively （以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更)</span></span><br><span class="line"><span class="string">       --help显示此帮助信息</span></span><br><span class="line"><span class="string">       --version显示版本信息</span></span><br><span class="line"><span class="string">mode ：权限设定字串，详细格式如下：</span></span><br><span class="line"><span class="string">[ugoa...][[+-=][rwxX]...][,...]，其中</span></span><br><span class="line"><span class="string">[ugoa...]</span></span><br><span class="line"><span class="string">u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示所有（包含上面三者）。</span></span><br><span class="line"><span class="string">[+-=]</span></span><br><span class="line"><span class="string">+ 表示增加权限，- 表示取消权限，= 表示唯一设定权限。</span></span><br><span class="line"><span class="string">[rwxX]</span></span><br><span class="line"><span class="string">r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">file...</span></span><br><span class="line"><span class="string">文件列表（单个或者多个文件、文件夹）</span></span><br></pre></td></tr></table></figure><p>范例：</p><ul><li>设置所有用户可读取文件 a.conf</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod ugo+r a.sh </span><br><span class="line">或 </span><br><span class="line">chmod a+r  a.conf</span><br></pre></td></tr></table></figure><ul><li>设置 <a href="http://c.sh/" target="_blank" rel="noopener">c.sh</a> 只有 拥有者可以读写及执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rwx c.sh</span><br></pre></td></tr></table></figure><ul><li>设置文件 a.conf 与 b.xml 权限为拥有者与其所属同一个群组 可读写，其它组可读不可写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+r,ug+w,o-w a.conf b.xml</span><br></pre></td></tr></table></figure><ul><li>设置当前目录下的所有档案与子目录皆设为任何人可读写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R a+rw *</span><br></pre></td></tr></table></figure><h3 id="数字权限使用格式"><a href="#数字权限使用格式" class="headerlink" title="数字权限使用格式"></a>数字权限使用格式</h3><p>在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1 表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，如： rwx = 4 + 2 + 1 = 7 rw = 4 + 2 = 6 rx = 4 +1 = 5 即</p><p>若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7 若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6 若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5</p><p>上面我们提到，每个文件都可以针对三个粒度，设置不同的 rwx(读写执行)权限。即我们可以用用三个 8 进制数字分别表示 拥有者 、群组 、其它组 ( u、 g 、o) 的权限详情，并用 chmod 直接加三个 8 进制数字的方式直接改变文件权限。语法格式为 ：</p><blockquote><p>chmod <abc> file…</abc></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">其中</span><br><span class="line">a,b,c各为一个数字，分别代表User、Group、及Other的权限。</span><br><span class="line">相当于简化版的</span><br><span class="line">chmod u=权限,g=权限,o=权限 file...</span><br><span class="line">而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</span><br></pre></td></tr></table></figure><p>范例：</p><ul><li>设置所有人可以读写及执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file  (等价于  chmod u=rwx,g=rwx,o=rwx file 或  chmod a=rwx file)</span><br></pre></td></tr></table></figure><ul><li>设置拥有者可读写，其他人不可读写执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 file (等价于  chmod u=rw,g=---,o=--- file 或 chmod u=rw,go-rwx file )</span><br></pre></td></tr></table></figure><h2 id="更改文件拥有者（chown-命令）"><a href="#更改文件拥有者（chown-命令）" class="headerlink" title="更改文件拥有者（chown 命令）"></a>更改文件拥有者（chown 命令）</h2><p>linux/Unix 是多人多工作业系统，每个的文件都有拥有者（所有者），如果我们想变更文件的拥有者（利用 chown 将文件拥有者加以改变），一般只有系统管理员 (root) 拥有此操作权限，而普通用户则没有权限将自己或者别人的文件的拥有者设置为别人。</p><p>语法格式：</p><blockquote><p>chown [可选项] user[:group] file…</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用权限：root</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">[可选项] : 同上文chmod</span><br><span class="line">user : 新的文件拥有者的使用者 </span><br><span class="line">group : 新的文件拥有者的使用者群体(group)</span><br></pre></td></tr></table></figure><p>范例：</p><ul><li>设置文件 d.key、e.scrt 的拥有者设为 users 群体的 tom</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown tom:users file d.key e.scrt</span><br></pre></td></tr></table></figure><ul><li>设置当前目录下与子目录下的所有文件的拥有者为 users 群体的 James</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R James:users  *</span><br></pre></td></tr></table></figure><h2 id="二、Linux-权限详解"><a href="#二、Linux-权限详解" class="headerlink" title="二、Linux 权限详解"></a>二、Linux 权限详解</h2><p>Linux 系统上对文件的权限有着严格的控制，用于如果相对某个文件执行某种操作，必须具有对应的权限方可执行成功。这也是 Linux 有别于 Windows 的机制，也是基于这个权限机智，Linux 可以有效防止病毒自我运行，因为运行的条件是必须要有运行的权限，而这个权限在 Linux 是用户所赋予的。</p><p>Linux 的文件权限有以下设定：</p><ul><li>Linux 下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。</li><li>Linux 下权限的属组有 拥有者 、群组 、其它组 三种。每个文件都可以针对这三个属组（粒度），设置不同的 rwx(读写执行) 权限。</li><li>通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</li></ul><p>如果我们要表示一个文件的所有权限详情，有两种方式：</p><ul><li>第一种是十位二进制表示法，(三个属组每个使用二进制位，再加一个最高位共十位)，可简化为三位八进制形式</li><li>另外一种十二位二进制表示法 (十二个二进制位)，可简化为四位八进制形式</li></ul><h2 id="十位权限表示"><a href="#十位权限表示" class="headerlink" title="十位权限表示"></a>十位权限表示</h2><p>常见的权限表示形式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rw------- (600)      只有拥有者有读写权限。</span><br><span class="line">-rw-r--r-- (644)      只有 拥有者有读写权限；而 属组用户和 其他用户只有读权限。</span><br><span class="line">-rwx------ (700)     只有拥有者有读、写、执行权限。</span><br><span class="line">-rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</span><br><span class="line">-rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。</span><br><span class="line">-rw-rw-rw- (666)   所有用户都有文件读、写权限。</span><br><span class="line">-rwxrwxrwx (777)  所有用户都有读、写、执行权限。</span><br></pre></td></tr></table></figure><p>后九位解析： 我们知道 Linux 权限总共有三个属组，这里我们给每个属组使用三个位置来定义三种操作（读、写、执行）权限，合起来则是权限的后九位。 上面我们用字符表示权限，其中 - 代表无权限，r 代表读权限，w 代表写权限，x 代表执行权限。</p><p>实际上，后九位每个位置的意义（代表某个属组的某个权限）都是固定的，如果我们将各个位置权限的有无用二进制数 1 和 0 来代替，则只读、只写、只执行权限，可以用三位二进制数表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r-- = 100</span><br><span class="line">-w- = 010</span><br><span class="line">--x = 001</span><br><span class="line">--- = 000</span><br></pre></td></tr></table></figure><p>转换成八进制数，则为 r=4, w=2, x=1, -=0（这也就是用数字设置权限时为何是 4 代表读，2 代表写，1 代表执行）</p><p>实际上，我们可以将所有的权限用二进制形式表现出来，并进一步转变成八进制数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rwx = 111 = 7</span><br><span class="line">rw- = 110 = 6</span><br><span class="line">r-x = 101 = 5</span><br><span class="line">r-- = 100 = 4</span><br><span class="line">-wx = 011 = 3</span><br><span class="line">-w- = 010 = 2</span><br><span class="line">--x = 001 = 1</span><br><span class="line">--- = 000 = 0</span><br></pre></td></tr></table></figure><p>由上可以得出，每个属组的所有的权限都可以用一位八进制数表示，每个数字都代表了不同的权限（权值）。如 最高的权限为是 7，代表可读，可写，可执行。</p><p>故 如果我们将每个属组的权限都用八进制数表示，则文件的权限可以表示为三位八进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw------- =  600</span><br><span class="line">-rw-rw-rw- =  666</span><br><span class="line">-rwxrwxrwx = 777</span><br></pre></td></tr></table></figure><p>关于第一位最高位的解释： 上面我们说到了权限表示中后九位的含义，剩下的第一位代表的是文件的类型，类型可以是下面几个中的一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d代表的是目录(directroy)</span><br><span class="line">-代表的是文件(regular file)</span><br><span class="line">s代表的是套字文件(socket)</span><br><span class="line">p代表的管道文件(pipe)或命名管道文件(named pipe)</span><br><span class="line">l代表的是符号链接文件(symbolic link)</span><br><span class="line">b代表的是该文件是面向块的设备文件(block-oriented device file)</span><br><span class="line">c代表的是该文件是面向字符的设备文件(charcter-oriented device file)</span><br></pre></td></tr></table></figure><h2 id="十二位权限（Linux-附加权限）"><a href="#十二位权限（Linux-附加权限）" class="headerlink" title="十二位权限（Linux 附加权限）"></a>十二位权限（Linux 附加权限）</h2><h3 id="附加权限相关概念"><a href="#附加权限相关概念" class="headerlink" title="附加权限相关概念"></a>附加权限相关概念</h3><p>linux 除了设置正常的读写操作权限外，还有关于一类设置也是涉及到权限，叫做 Linxu 附加权限。包括 SET 位权限（suid，sgid）和粘滞位权限（sticky）。</p><p><strong>SET 位权限：</strong></p><p>suid/sgid 是为了使 “没有取得特权用户要完成一项必须要有特权才可以执行的任务” 而产生的。 一般用于给可执行的程序或脚本文件进行设置，其中 SUID 表示对属主用户增加 SET 位权限，SGID 表示对属组内用户增加 SET 位权限。执行文件被设置了 SUID、SGID 权限后，任何用户执行该文件时，将获得该文件属主、属组账号对应的身份。在许多环境中，suid 和 sgid 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。所以应该尽量避免使用 SET 位权限程序。（passwd 命令是为数不多的必须使用 “suid” 的命令之一）。</p><ul><li>suid(set User ID,set UID) 的意思是进程执行一个文件时通常保持进程拥有者的 UID。然而，如果设置了可执行文件的 suid 位，进程就获得了该文件拥有者的 UID。</li><li>sgid(set Group ID,set GID) 意思也是一样，只是把上面的进程拥有者改成进程组就好了。</li></ul><p>SET 位权限表示形式（10 位权限）：</p><p>如果一个文件被设置了 suid 或 sgid 位，会分别表现在所有者或同组用户的权限的可执行位上；如果文件设置了 suid 还设置了 x（执行）位，则相应的执行位表示为 s(小写)。但是，如果没有设置 x 位，它将表示为 S(大写)。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、-rwsr-xr-x 表示设置了suid，且拥有者有可执行权限</span><br><span class="line">2、-rwSr--r-- 表示suid被设置，但拥有者没有可执行权限</span><br><span class="line">3、-rwxr-sr-x 表示sgid被设置，且群组用户有可执行权限</span><br><span class="line">4、-rw-r-Sr-- 表示sgid被设置，但群组用户没有可执行权限</span><br></pre></td></tr></table></figure><p>设置方式：</p><p>SET 位权限可以通过 chmod 命令设置，给文件加 suid 和 sgid 的命令如下 (类似于上面 chmod 赋予一般权限的命令)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename 设置suid位</span><br><span class="line">chmod u<span class="_">-s</span> filename 去掉suid设置</span><br><span class="line">chmod g+s filename 设置sgid位</span><br><span class="line">chmod g<span class="_">-s</span> filename 去掉sgid设置</span><br></pre></td></tr></table></figure><h4 id="粘滞位权限："><a href="#粘滞位权限：" class="headerlink" title="粘滞位权限："></a>粘滞位权限：</h4><p>粘滞位权限即 sticky。一般用于为目录设置特殊的附加权限，当目录被设置了粘滞位权限后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据。设置了粘滞位权限的目录，是用 ls 查看其属性时，其他用户权限处的 x 将变为 t。 使用 chmod 命令设置目录权限时，+t、-t 权限模式可分别用于添加、移除粘滞位权限。</p><p>粘滞位权限表示形式（10 位权限）：</p><p>一个文件或目录被设置了粘滞位权限，会表现在其他组用户的权限的可执行位上。如果文件设置了 sticky 还设置了 x（执行）位，其他组用户的权限的可执行位为 t(小写)。但是，如果没有设置 x 位，它将表示为 T(大写)。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、-rwsr-xr-t 表示设置了粘滞位且其他用户组有可执行权限</span><br><span class="line">2、-rwSr--r-T 表示设置了粘滞位但其他用户组没有可执行权限</span><br></pre></td></tr></table></figure><p>设置方式：</p><p>sticky 权限同样可以通过 chmod 命令设置：</p><blockquote><p>chmod +t &lt;文件列表..&gt;</p></blockquote><h3 id="十二位的权限表示方法"><a href="#十二位的权限表示方法" class="headerlink" title="十二位的权限表示方法"></a>十二位的权限表示方法</h3><p>附加权限除了用十位权限形式表示外，还可以用用十二位字符表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11 10 9 8 7 6 5 4 3 2 1 0</span><br><span class="line">S  G  T r w x r w x r w x</span><br></pre></td></tr></table></figure><p>SGT 分别表示 SUID 权限、SGID 权限、和 粘滞位权限，这十二位分别对应关系如下：</p><p>第 11 位为 SUID 位，第 10 位为 SGID 位，第 9 位为 sticky 位，第 8-0 位对应于上面的三组 rwx 位（后九位）。</p><p>在这十二位的每一位上都置值。如果有相应的权限则为 1， 没有此权限则为 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-sr-- 的值为： 0 1 0  1 1 0  1 0 0  1 0 0</span><br><span class="line">-rwsr-xr-x 的值为： 1 0 0  1 1 1  1 0 1  1 0 1</span><br><span class="line">-rwsr-sr-x 的值为： 1 1 0  1 1 1  1 0 1  1 0 1 </span><br><span class="line">-rwsr-sr-t 的值为： 1 1 1  1 1 1  1 0 1  1 0 1</span><br></pre></td></tr></table></figure><p>如果将则前三位 SGT 也转换成一个二进制数，则</p><ul><li>suid 的八进制数字是 4</li><li>sgid 的代表数字是 2</li><li>sticky 位代表数字是 1</li></ul><p>这样我们就可以将十二位权限三位三位的转化为 4 个八进制数。其中</p><ul><li>最高的一位八进制数就是 suid，sgdi，sticky 的权值。</li><li>第二位为 拥有者的权值</li><li>第三位为 所属组的权值</li><li>最后一位为 其他组的权值</li></ul><h3 id="附加权限的八进制形式"><a href="#附加权限的八进制形式" class="headerlink" title="附加权限的八进制形式"></a>附加权限的八进制形式</h3><p>通过上面，我们知道，正常权限和附加权限可以用 4 位八进制数表示。类似于正常权限的数字权限赋值模式（使用三位八进制数字赋值）</p><blockquote><p>chmod <abc> file…</abc></p></blockquote><p>我们可以进一步使用 4 位八进制数字同时赋值正常权限和附加权限。</p><blockquote><p>chmod <sabc> file…</sabc></p></blockquote><p>其中 s 是表示附加权限的把八进制数字，abc 与之前一致，分别是对应 User、Group、及 Other（拥有者、群组、其他组）的权限。因为 SUID 对应八进制数字是 4，SGID 对于八进制数字是 2，则 “4755” 表示设置 SUID 权限，“6755”表示同时设置 SUID、SGID 权限。</p><p>我们进一步将上小节的例子中的二进制数转变为八进制表示形式，则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-sr-- = 0 1 0 1 1 0 1 0 0 1 0 0 = 2644 </span><br><span class="line">-rwsr-xr-x = 1 0 0 1 1 1 1 0 1 1 0 1 = 4755</span><br><span class="line">-rwsr-sr-x = 1 1 0 1 1 1 1 0 1 1 0 1 = 6755</span><br><span class="line">-rwsr-sr-t = 1 1 1 1 1 1 1 0 1 1 0 1 = 7755</span><br></pre></td></tr></table></figure><p>对比范例：</p><ul><li>设置 netlogin 的权限为拥有者可读写执行，群组和其他权限为可读可执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 netlogin</span><br></pre></td></tr></table></figure><ul><li>设置 netlogin 的权限为拥有者可读写执行，群组和其他权限为可读可执行，并且设置 suid</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 4755 netlogin</span><br></pre></td></tr></table></figure><p>chmod 4755 与 chmod 755 对比多了附加权限值 4，这个 4 表示其他用户执行文件时，具有与所有者同样的权限（设置了 SUID）。</p><blockquote><p>为什么要设置 4755 而不是 755？<br>假设 netlogin 是 root 用户创建的一个上网认证程序，如果其他用户要上网也要用到这个程序，那就需要 root 用户运行 chmod 755 netlogin 命令使其他用户也能运行 netlogin。但假如 netlogin 执行时需要访问一些只有 root 用户才有权访问的文件，那么其他用户执行 netlogin 时可能因为权限不够还是不能上网。这种情况下，就可以用 chmod 4755 netlogin 设置其他用户在执行 netlogin 也有 root 用户的权限，从而顺利上网。</p></blockquote><p>在 Linux 命令中，<code>chmod</code>用于<strong>修改文件或者目录的权限</strong>。对于文件或者目录的普通权限，共有 3 种，分别为：</p><ul><li><code>r</code>：读取；</li><li><code>w</code>：写入；</li><li><code>x</code>：执行。</li></ul><p>此外，还有 3 种特殊权限，分别为：</p><ul><li><code>suid</code>：Set User ID；</li><li><code>sgid</code>：Set Group ID；</li><li><code>sticky</code>：粘滞位。</li></ul><p>在此，我们仅介绍如何利用<code>chmod</code>修改文件及目录的普通权限。</p><h3 id="权限范围及代号"><a href="#权限范围及代号" class="headerlink" title="权限范围及代号"></a>权限范围及代号</h3><p>文件及目录的权限范围，包括：</p><ul><li><code>u</code>：User，即文件或目录的拥有者；</li><li><code>g</code>：Group，即文件或目录的所属群组；</li><li><code>o</code>：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；</li><li><code>a</code>：All，即全部的用户，包含拥有者、所属群组以及其他用户。</li></ul><p>权限的代号包括：</p><ul><li><code>r</code>：读取权限，数字代号为<code>4</code>；</li><li><code>w</code>：写入权限，数字代号为<code>2</code>；</li><li><code>x</code>：执行或切换权限，数字代号为<code>1</code>；</li><li><code>-</code>：不具任何权限，数字代号为<code>0</code>；</li><li><code>s</code>：当文件被执行时，根据<code>who</code>参数指定的用户类型设置文件的<code>setuid</code>或者<code>setgid</code>权限。</li></ul><h3 id="语法及选项说明"><a href="#语法及选项说明" class="headerlink" title="语法及选项说明"></a>语法及选项说明</h3><ul><li><p><code>chmod</code>语法：</p><ul><li><code>chmod [-cfRv][--help][--version][&lt;权限范围&gt;+/-/=&lt;权限设置...&gt;][文件或目录...]</code></li><li><code>chmod [-cfRv][--help][--version][数字代号][文件或目录...]</code></li><li><code>chmod [-cfRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</code></li></ul></li><li><p>选项说明:</p><ul><li><code>-c</code>或<code>--changes</code>：效果类似<code>-v</code>参数，但仅返回更改的部分；</li><li><code>-f</code>或<code>--quiet</code>或<code>--silent</code>：不显示错误信息；</li><li><code>-R</code>或<code>--recursive</code>：递归处理，将指定目录下的所有文件及子目录一并处理；</li><li><code>-v</code>或<code>--verbose</code>：显示指令执行过程；</li><li><code>--help</code>：显示在线帮助信息；</li><li><code>--reference=&lt;参考文件或目录&gt;</code>：把指定文件或目录的权限全部设成和参考文件或目录的权限相同；</li><li><code>--version</code>：显示版本信息；</li><li><code>&lt;权限范围&gt;+&lt;权限设置&gt;</code>：开启权限范围的文件或目录的该项权限设置；</li><li><code>&lt;权限范围&gt;-&lt;权限设置&gt;</code>：关闭权限范围的文件或目录的该项权限设置；</li><li><code>&lt;权限范围&gt;=&lt;权限设置&gt;</code>：指定权限范围的文件或目录的该项权限设置。</li></ul></li></ul><ul><li><p>将用户加入到su组. </p><p>  su 到root 用户.<br>  vim /etc/sudoers<br>  leleyi(用户名)     ALL=(ALL)       ALL.<br>  包保存即可.</p></li></ul><p>Linux下创建用户时会用到useradd和adduser这两个命令，他们的区别如下：<br>　　1.使用useradd时，如果后面不添加任何参数选项，例如：#sudo useradd test创建出来的用户将是默认“三无”用户：一无Home Directory，二无密码，三无系统Shell。<br>　　2.使用adduser时，创建用户的过程更像是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。</p><ul><li>adduser会提示设置密码，而useradd不会。</li><li>adduser会创建用户目录，比如/home/freebird freebird是用户，useradd不会</li><li>dduser会创建用户目录，比如/home/freebird freebird是用户，useradd不会</li><li>adduser会询问全名，房间号码，电话号码等用户信息，useradd不会</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Linux 中，增加用户或改变用户的组属性可以使用 &lt;code&gt;useradd&lt;/code&gt; 或者 &lt;code&gt;usermod&lt;/code&gt; 命令。&lt;code&gt;useradd&lt;/code&gt; 增加一个新用户或者更新默认新用户信息。&lt;code&gt;usermod&lt;/code&gt; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Authorisation not recognised</title>
    <link href="http://yoursite.com/2020/08/20/Authorisation/"/>
    <id>http://yoursite.com/2020/08/20/Authorisation/</id>
    <published>2020-08-20T13:44:15.000Z</published>
    <updated>2021-01-23T08:07:49.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Authorisation-not-recognised"><a href="#Authorisation-not-recognised" class="headerlink" title="Authorisation not recognised"></a>Authorisation not recognised</h3><p><strong>Can’t open display: localhost:10.0</strong></p><h4 id="Error"><a href="#Error" class="headerlink" title="Error :"></a>Error :</h4><p>Sometimes your users complain they can’t use GUI via X server from Linux box (in this case mobaXterm). They are receiving their display authorization is not recognized. An error like below –</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks@ xclock</span><br><span class="line">MobaXterm X11 proxy: Authorisation not recognised</span><br><span class="line">Error: Can<span class="string">'t open display: localhost:10.0</span></span><br></pre></td></tr></table></figure><p>Sometimes these errors show up when you switch user from the root account or any other account.</p><h4 id="Quick-Solution"><a href="#Quick-Solution" class="headerlink" title="Quick Solution:"></a>Quick Solution:</h4><p><strong>Login directly with</strong> user<strong> on which you want to use xclock</strong></p><p><code>appuser</code> needs to log in directly on the server and you won’t see this issue. Most of the time it arises once you su to <code>appuser</code> from root or different users.</p><p>Read further if you have to switch user and then use x-term.</p><p><code>appuser</code> need to add its entry to authorization. This entry will be the last entry in <code>.Xauthority</code> file in a home directory of the previous user with which you have logged in the server in the first place. Let’s say its <code>root</code> in our case. i.e. we logged in as <code>root</code> and then su to <code>appuser</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kerneltalks <span class="comment"># xauth -f .Xauthority list |tail -1</span></span><br><span class="line">kerneltalks/unix:10 MIT-MAGIC-COOKIE-1 df22dfc7df88b60f0653198cc85f543c</span><br><span class="line"> </span><br><span class="line">appuser@kerneltalks $ xauth add kerneltalks/unix:10 MIT-MAGIC-COOKIE-1 df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>So here we got values from root home directory file and then we added it in using xauth in currently su user i.e. <code>appuser</code></p><p>and you are good to go!</p><h4 id="Bit-of-an-explanation"><a href="#Bit-of-an-explanation" class="headerlink" title="Bit of an explanation :"></a>Bit of an explanation :</h4><p>This error occurs since your ID doesn’t have the authorization to connect to the X server.  Let’s walk through how to resolve this error. List out authorization entries for displays using <code>xauth list</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth list</span><br><span class="line">kerneltalks/unix:12  MIT-MAGIC-COOKIE-1  60c402df81f68e721qwe531d1c99c1eb</span><br><span class="line">kerneltalks/unix:11  MIT-MAGIC-COOKIE-1  ad81da801d778fqwe6aea383635be27d</span><br><span class="line">kerneltalks/unix:10  MIT-MAGIC-COOKIE-1  0bd591485031d0ae670475g46db1b8b9</span><br></pre></td></tr></table></figure><p>The output shows entries column wise –</p><ol><li>Display name</li><li>Protocol name (MIT-MAGIC-COOKIE-1 referred to single period)</li><li>hexkey</li></ol><p>If you have many sessions and you are on test/dev environment and you are the only one using your system you can remove all the above entries using xauth remove to make sure you have a clean slate and getting only your session cookie. Or, you can save this output for reference. Log in again, try  <code>xclock</code> and new the entry will be generated. Compare the latest output with the older one and get your new entry filtered out. Or as mentioned above in a quick solution it will be last entry in <code>.Xauthority</code> file in a home directory of <code>appuser</code>. You can not read  <code>.Xauthority</code> file like text file so you have to use <code>xauth -f</code> command to view its content.</p><p>Logout from all sessions. Login again with the app user and run <code>xclock</code> once. This will generate a new session cookie token which you can see in <code>xauth list</code> .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth list</span><br><span class="line">kerneltalks/unix:10  MIT-MAGIC-COOKIE-1  df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>Now, grab this entry and add authorization using below command –</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appuser@kerneltalks $ xauth add APCSFIOGWDV02/unix:10  MIT-MAGIC-COOKIE-1  df22dfc7df88b60f0653198cc85f543c</span><br></pre></td></tr></table></figure><p>and that’s it. You <code>xclock</code> should work now!</p><hr><h4 id="Error-1"><a href="#Error-1" class="headerlink" title="Error :"></a>Error :</h4><p>You are seeing below error in mobaXterm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X11-forwarding  : ✘  (disabled or not supported by server)</span><br></pre></td></tr></table></figure><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution :"></a>Solution :</h4><p>The best way to make sure you have all X11 stuff installed is to run the install package <code>xclock</code>. Additionally, you need to install <code>xauth</code> package as well.</p><p>Secondly, make sure you have <code>X11Forwarding yes</code> set in your <code>/etc/ssh/sshd_config</code>. If not then set and restart sshd daemon.</p><p>That’s all! Try re-logging to the server and it should work. You should see the below message after login using MobXterm.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X11-forwarding  : ✔  (remote display is forwarded through SSH)</span><br></pre></td></tr></table></figure><p><a href="https://kerneltalks.com/troubleshooting/mobaxterm-x11-proxy-authorisation-not-recognised/" target="_blank" rel="noopener">原文连接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Authorisation-not-recognised&quot;&gt;&lt;a href=&quot;#Authorisation-not-recognised&quot; class=&quot;headerlink&quot; title=&quot;Authorisation not recognised&quot;&gt;&lt;/a&gt;Au
      
    
    </summary>
    
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Googel EvenBus</title>
    <link href="http://yoursite.com/2020/08/20/Google_EvenBus/"/>
    <id>http://yoursite.com/2020/08/20/Google_EvenBus/</id>
    <published>2020-08-20T13:44:15.000Z</published>
    <updated>2021-01-23T08:16:05.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Google-EvenBus-源码"><a href="#Google-EvenBus-源码" class="headerlink" title="Google EvenBus 源码"></a>Google EvenBus 源码</h3><p><strong>EventBus</strong> 发布/订阅者者模式</p><p><img src="1.png" alt="png"></p><p>简单的使用放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventBus bus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    bus.register(<span class="keyword">this</span>);</span><br><span class="line">    bus.post(<span class="number">1024</span>);</span><br><span class="line">    bus.post(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveInteger</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Integer : "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveString</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"String : "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="png"></p><h3 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h3><p>我们在上面可以看到 <strong> @Subscribe</strong>  注解表示向EventBus总线订阅了该方法. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到该注解是基于方法上的. 通过对方法添加注解,当有时间来临的时候.便会执行该方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus.register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将当前对象注册到EventBus中. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) &#123;</span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();</span><br><span class="line">  Class&lt;?&gt; clazz = listener.getClass();</span><br><span class="line">  <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">    methodsInListener.put(eventType, Subscriber.create(bus, listener, method));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> methodsInListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以通过遍历当前对象 (listener中) 的所有包含Subscribe的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Google-EvenBus-源码&quot;&gt;&lt;a href=&quot;#Google-EvenBus-源码&quot; class=&quot;headerlink&quot; title=&quot;Google EvenBus 源码&quot;&gt;&lt;/a&gt;Google EvenBus 源码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Ev
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Domain name system</title>
    <link href="http://yoursite.com/2020/08/13/nslookup/"/>
    <id>http://yoursite.com/2020/08/13/nslookup/</id>
    <published>2020-08-13T13:42:15.000Z</published>
    <updated>2020-08-14T00:41:11.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Domain-name-system"><a href="#Domain-name-system" class="headerlink" title="Domain name system"></a>Domain name system</h2><h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h3><ol><li><p>List 3 different protocols that appear in the protocol column in the unfiltered<br> packet-listing window in step 7 above.</p><p><img src="image-20200813143931097.png" alt="image-20200813143931097"></p></li><li><p>How long did it take from when the HTTP GET message was sent until the HTTP<br> OK reply was received? (By default, the value of the Time column in the packet listing window is the amount of time, in seconds, since Wireshark tracing began.</p><p><img src="image-20200813144423850.png" alt="image-20200813144423850"></p></li></ol><p>To display the Time field in time-of-day format, select the Wireshark View pull<br>down menu, then select Time Display Format, then select Time-of-day.)</p><ol><li><p>What is the Internet address of the gaia.cs.umass.edu (also known as www.net.<br> cs.umass.edu)? What is the Internet address of your computer</p><p><img src="image-20200813144743605.png" alt="image-20200813144743605"></p></li><li><p>Print the two HTTP messages (GET and OK) referred to in question 2 above. To<br> do so, select Print from the Wireshark File command menu, and select the<br> “Selected Packet Only” and “Print as displayed” radial buttons, and then click<br> OK.</p><p><img src="image-20200813145358276.png" alt="image-20200813145358276"></p></li></ol><h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h3><p><strong>PREREQUISITES</strong> </p><pre><code>1. Computer Networking: A Top-Down Approach, 7th ed., J.F. Kurose and K.W. Ross (Chapter 1 and Chapter 2) TASK </code></pre><p><strong>TASK</strong></p><pre><code>1. Install Wireshark (lab. 1 part 1) – you already have all information.2. Use nslookup to analyze DNS messages 3. Use ipconfig to analyze DNS messages 4. Use Wireshark to analyze DNS messages</code></pre><h4 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h4><ol><li><p>Run nslookup to obtain the IP-address of a Web-server in China. What is the IP-address of that server</p><p><img src="image-20200813140126152.png" alt="image-20200813140126152"></p></li><li><p>Run nslookup to determine the authoritative dNs servers for a university in Europe</p><p><img src="image-20200813140220702.png" alt="image-20200813140220702"></p></li><li><p>Run nslookup so that one of the dns servers obtained in Question 2 is queried for the mail servers for Yandex mail(or any other What is its iP address?</p><p><img src="image-20200813141637442.png" alt="image-20200813141637442"></p></li><li><p>Make screenshots of your command line and put them in the report put them in the report along with the answers to questions</p></li></ol><h4 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h4><p><img src="image-20200813140706733.png" alt="image-20200813140706733"></p><p><img src="image-20200813141105155.png" alt="image-20200813141105155"></p><p><img src="image-20200813141148746.png" alt="image-20200813141148746"></p><h4 id="Tracing-DNS-with-Wireshark"><a href="#Tracing-DNS-with-Wireshark" class="headerlink" title="Tracing DNS with Wireshark"></a><strong>Tracing DNS with Wireshark</strong></h4><ul><li>Use ipconfig to empty the dns cache in your host</li><li>Open your browser and empty your browser cache. (With Internet Explorer, go to Tools menu and select Internet Options; then in the general tab select Delete Files.</li><li>Open Wireshark and enter ip addr =- your ip address into the filter, where you obtain your IP address with ipconfig. This filter removes all packets that neither originate nor are destined to your host</li><li>Start packet capture in Wireshark</li><li>With your browser, visit the some Web page</li><li>Stop packet capture</li></ul><ol><li><p>Locate the DNS query and response messages. are then sent over UDP or TCP?</p><p> <img src="image-20200813150611186.png" alt="image-20200813150611186"></p></li></ol><p>​    It can be seen from the query message information and the response messages information they are Sending message via <strong>UDP</strong>.</p><ol><li><p>What is the destination port for the DNS query message? What is the source port of DNS response message?</p><p> <img src="image-20200813150750618.png" alt="image-20200813150750618"></p><p> <img src="image-20200813151051501.png" alt="image-20200813151051501"></p><p> Ports are both <strong>53</strong></p></li><li><p>To what IP address is the DNS query message sent? Use ipconfig to determine the IP address of your local DNS server. Are these two IP addresses the same.</p><p>  <img src="image-20200813151609517.png" alt="image-20200813151609517"></p><p> <img src="image-20200813151711412.png" alt="image-20200813151711412"></p><p> both are <strong>202.101.172.35</strong></p></li><li><p>Examine the DNS query message. What Type’of DNS query is it? Does the query message contain any“ answers”?</p></li></ol><p><img src="image-20200813152007576.png" alt="image-20200813152007576"></p><pre><code>Type:A and query message does not contain any &quot;answers&quot;.</code></pre><ol><li><p>Examine the DNS response message. How many answers are provided? what do each of these answers contain?</p><p> <img src="image-20200813152229592.png" alt="image-20200813152229592"></p><p> See the picture.</p></li><li><p>Does this web page contain images? Before retrieving each image, does your host issue new DNS queries?</p><p> <img src="image-20200813152229592.png" alt="image-20200813152229592"></p><p> None</p></li></ol><h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><h4 id="nslookup-domain"><a href="#nslookup-domain" class="headerlink" title="nslookup domain"></a>nslookup domain</h4><ul><li><p>Start packet capture.</p></li><li><p>Do 𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 𝑤𝑤𝑤.ℎ𝑑𝑢.𝑒𝑑𝑢.𝑐𝑛</p><p><img src="image-20200813153853249.png" alt="image-20200813153853249"></p></li><li><p>Stop packet capture. You should get a trace that looks something like the following (on the last pictures).</p></li></ul><ol><li><p>What is the destination port for the DNS query message? What is the source port of DNS response message?</p><p><img src="image-20200813154043327.png" alt="image-20200813154043327"></p><p>The destination port for the DNS query message is <strong>53</strong>.</p><p>The source port of DNS response message is also <strong>53</strong>.</p></li><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server</p><p><img src="image-20200813154248959.png" alt="image-20200813154248959"></p><p><img src="image-20200813153853249.png" alt="image-20200813153853249"></p><p>Same as the IP address of the local DNS server</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”? </p><p><img src="image-20200813154557227.png" alt="image-20200813154557227"></p></li><li><p>Examine the DNS response message. How many “answers” are provided? What do each of these answers contain?</p><p><img src="image-20200813154731464.png" alt="image-20200813154731464"></p><p>have 3 answers. </p></li></ol><h4 id="nslookup-type"><a href="#nslookup-type" class="headerlink" title="nslookup -type"></a>nslookup -type</h4><p>Now repeat the previous experiment, but instead issue the command:</p><p>​                    𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 – 𝑡𝑦𝑝𝑒=𝑁𝑆 𝑎𝑑𝑑𝑟𝑒𝑠𝑠<em> 𝑤ℎ𝑎𝑡 </em> 𝑦𝑜𝑢_𝑤𝑎𝑛𝑡</p><p><strong>nslookup -type = NS baidu.com</strong></p><p><img src="image-20200813155226270.png" alt="image-20200813155226270"></p><p>Answer the following questions:</p><ol><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server?</p><p><img src="image-20200813155813591.png" alt="image-20200813155813591"></p><p>Same as the IP address of the local DNS server.</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</p><p><img src="image-20200813155822201.png" alt="image-20200813155822201"></p><p>Type: NS </p><p>query message does not contain any “answers”.</p></li><li><p>Examine the DNS response message. What nameservers does the response message provide?</p><p><img src="image-20200813155925788.png" alt="image-20200813155925788"></p><p>result obtained in Wireshark is the same as the result obtained by running in nslookup.</p></li></ol><h4 id="nslookup-𝑦𝑜𝑢𝑟-𝐷𝑁𝑆"><a href="#nslookup-𝑦𝑜𝑢𝑟-𝐷𝑁𝑆" class="headerlink" title="nslookup 𝑦𝑜𝑢𝑟 _ 𝐷𝑁𝑆"></a>nslookup 𝑦𝑜𝑢𝑟 _ 𝐷𝑁𝑆</h4><p>Now repeat the previous experiment, but instead issue the command:</p><p>​                    𝑛𝑠𝑙𝑜𝑜𝑘𝑢𝑝 𝑎𝑑𝑑𝑟𝑒𝑠𝑠 <em> 𝑤ℎ𝑎𝑡 </em> 𝑦𝑜𝑢 <em> 𝑤𝑎𝑛𝑡 𝑦𝑜𝑢𝑟 </em> 𝐷𝑁𝑆</p><p><strong>nslookup www.baidu.com 114.114.114.114</strong></p><p><img src="image-20200813160230801.png" alt="image-20200813160230801"></p><p>Answer the following questions:</p><ol><li><p>To what IP address is the DNS query message sent? Is this the IP address of your default local DNS server? If not, what does the IP address correspond to?</p><p><img src="image-20200813160716347.png" alt="image-20200813160716347"></p><p> They are not the same.This ip corresponds to the ip specified last by entering “nslookup baidu.com 114.114.114.114” in the terminal.</p></li><li><p>Examine the DNS query message. What “Type” of DNS query is it? Does the query message contain any “answers”?</p><p><img src="image-20200813160716347.png" alt="image-20200813160716347"></p><p>Type: A </p><p>query message does not contain any “answers”.</p></li><li><p>Examine the DNS response message. How many “answers” are provided? What does each of these answers contain?</p><p><img src="image-20200813160906241.png" alt="image-20200813160906241"></p><p>you can see from the picture above, it contains 3 answers</p><p>The result is the same as the result obtained by nslookup in the Terminal.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Domain-name-system&quot;&gt;&lt;a href=&quot;#Domain-name-system&quot; class=&quot;headerlink&quot; title=&quot;Domain name system&quot;&gt;&lt;/a&gt;Domain name system&lt;/h2&gt;&lt;h3 id=&quot;P
      
    
    </summary>
    
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Document_Embedding</title>
    <link href="http://yoursite.com/2020/08/07/document_embedding/"/>
    <id>http://yoursite.com/2020/08/07/document_embedding/</id>
    <published>2020-08-07T08:57:15.000Z</published>
    <updated>2020-08-07T08:51:33.592Z</updated>
    
    <content type="html"><![CDATA[<p>[原文连接]<a href="https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d" target="_blank" rel="noopener">https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d</a></p><p>近年来，单词嵌入（将单词映射到数值向量空间中）已被证明是自然语言处理（NLP）任务的一种非常重要的方法，它使各种依赖于向量表示作为输入的机器学习模型都可以享受更丰富的文本表示输入。这些表示形式保留了更多关于单词的语义和句法信息，从而导致几乎所有可以想象的NLP任务的性能得到改善。</p><p>新颖的想法本身及其巨大的影响，都促使研究人员考虑如何将这种丰富的矢量表示形式提供给更大的文本单位（从句子到书籍）的问题。这项工作导致产生了许多新方法来生成这些映射，并为该问题提供了各种创新解决方案以及一些显着的突破。</p><blockquote><p><strong>注意</strong>”：这里使用“ <strong>文档</strong>”一词来指代<strong>任何单词序列</strong>，从句子和段落到社交媒体帖子，一直到文章，书籍和结构更复杂的文本文档。</p></blockquote><p>在本文中，我不仅会介绍单词嵌入技术的直接扩展方法（例如<em>doc2vec</em> 扩展<em>word2vec</em> 的方法），还将介绍其他值得注意的技术，这些技术有时会在其他输出中生成ℝⁿ中的文档到向量的映射。 。</p><h2 id="文件嵌入的应用"><a href="#文件嵌入的应用" class="headerlink" title="文件嵌入的应用"></a>文件嵌入的应用</h2><p>将文档映射到信息矢量表示的能力具有广泛的应用。以下只是部分列表。</p><p>[<a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Le &amp; Mikolov, 2014</a>]展示了他们的<em>段落向量</em>法在几种文本分类和情感分析任务上的功能，而[<a href="https://arxiv.org/pdf/1507.07998.pdf" target="_blank" rel="noopener">Dai et al, 2015</a>] 在文档相似性任务的背景下对其进行了检验， [<a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau &amp; Baldwin, 2016</a>]进行了基准测试它针对论坛问题重复任务和 <a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener">the Semantic Textual Similarity (STS) SemEval shared task</a>.</p><p>[<a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Kiros et al, 2015</a>] 已经证明了他们的<em>Skip-thought</em>向量在语义相关性，释义检测，图像句子排名，问题类型分类以及四个情感和主观性数据集上的使用。[Broere，2017]使用它们来预测POS标签和依赖关系。</p><p>[<a href="https://arxiv.org/pdf/1810.09302.pdf" target="_blank" rel="noopener">Chen et al, 2018</a>] 显示了<em>BioSentVec</em> ，他们在生物医学文本上训练过的句子嵌入集，在句子对相似性任务(<a href="https://github.com/ncbi-nlp/BioSentVec" target="_blank" rel="noopener">official Python implementation</a>).上表现良好。</p><p>最后，<a href="https://www.microsoft.com/en-us/research/project/dssm/" target="_blank" rel="noopener">Deep Semantic Similarity Model was used by various authors</a> 进行信息检索和Web搜索排名，广告选择/相关性，上下文实体搜索和兴趣度任务，问题解答，知识推断，图像字幕和机器翻译任务。</p><p>但是请注意，尽管文档嵌入的问题已经很久了，但许多当前有影响力的解决方案还是很年轻的，并且在紧随当代基于编码器-解码器的单词成功之后，这一领域在最近（大约在2014年）开始兴起嵌入技术，所以现在还很早。话虽如此，我希望这部分内容可以将以下各节放在更广阔的背景下，并以有意义的方式进行组织。</p><h2 id="突出的方法和趋势"><a href="#突出的方法和趋势" class="headerlink" title="突出的方法和趋势"></a>突出的方法和趋势</h2><hr><h3 id="文本嵌入的方法"><a href="#文本嵌入的方法" class="headerlink" title="文本嵌入的方法"></a>文本嵌入的方法</h3><p>映射领域的一种可能方法是采用以下四种主要方法：</p><ol><li><strong>总结词向量</strong><br>这是<em>对</em>经典的方法。<em>Bag-of-words</em> 正是针对一个热门单词向量而做到的，而您可以应用到它的各种加权方案都是以这种方式总结单词向量的方式。但是，这种方法在与最先进的词表示形式一起使用时（通常通过求平均值而不是求和）也有效，尤其是在考虑到这种用法优化词嵌入时，并且可以与任何这里介绍的更性感的方法。</li><li><strong>主题建模</strong><br>虽然这通常不是主题建模技术（如LDA和PLSI）的主要应用，但它们<em>固有地生成了一个文档嵌入空间</em>，用于对语料库中的单词分布进行建模和解释，而维可以看作是隐藏在<em>文档</em>中的潜在语义结构。数据，因此在我们的上下文中很有用。我没有在本文中真正介绍这种方法（LDA的简要介绍除外），因为我认为LDA很好地代表了这种方法，并且众所周知。</li><li><strong>编码器-解码器模型</strong><br>这是场景中最新的无监督功能，具有<em>doc2vec</em> 和 <em>skip-thought</em> 之类的功能。尽管这种方法自2000年代初就出现了（以 <em>神经概率语言模型</em> 的名义），但随着其成功地应用于词嵌入生成，它最近获得了新生，目前的研究集中在如何将其用途扩展到文档嵌入。这种方法从大型未标记语料库的可用性不断提高中获得了比其他方法更多的收益。</li><li><strong>有监督的表示学习</strong><br>这种方法的应用源于神经网络模型的兴起（或兴起），以及它们使用各种非线性多层算子学习输入数据的丰富表示的能力，<a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" target="_blank" rel="noopener">该函数可以近似各种映射</a>.。通过简单地将单词袋输入到神经网络中以解决与文本相关的监督问题，您将得到一个模型，其中隐藏层包含输入文本的丰富表示形式，这正是我们所追求的。</li></ol><p>有几种不受监督的方法不适用于上述任何一种方法（特别是<em>想到的是快速思考</em>和<em>Word Mover的距离</em>），但是我认为大多数技术确实属于这四大类之一。</p><blockquote><p><strong>注意：</strong>虽然很容易指出经典的单词袋技术遭受独特的顺序信息缺失的困扰，但这实际上是规则，而不是例外。通过本文回顾的大多数新方法获得的主要信息是将分布假设扩展到更大的文本单元。基于神经网络的序列模型是例外。</p></blockquote><h3 id="挑战和趋势"><a href="#挑战和趋势" class="headerlink" title="挑战和趋势"></a>挑战和趋势</h3><p>整体上研究文档嵌入技术的研究和应用时，会出现几种广泛的趋势，并且可能会发现一些挑战。</p><ol><li><strong>编码器-解码器优化：研究</strong>的重要部分集中在优化无监督的精确体系结构（例如ANN / CNN / RNN）和某些组件/超参数（例如n-gram，投影函数，权重等）上编码器-解码器方法，用于学习文档嵌入。尽管此微调的目标之一是提高各种任务的成功指标，但目标还是能够在较大的语料库上或更短的时间内训练模型。</li><li><strong>学习目标设计：</strong>无监督（或自我监督）表示学习的关键在于设计一个学习目标，该目标利用数据中自由可用的标签，从而生成对下游任务有用的表示。对我来说，这是最令人兴奋的趋势，并且我认为对NLP任务影响最大的趋势可能等同于一个词嵌入技术。目前，我仅将<em>快速思考</em>和<em>Word Mover的距离</em>视为编码器/解码器方法的替代方法。这种趋势的另一个吸引人的方面是，此处的创新也可能适用于词嵌入问题。</li><li><strong>基准测试：</strong>一般来说，机器学习研究是整个领域趋势的一部分，文档嵌入（可能由于它是一个年轻的子领域）很好地证明了研究在越来越广泛的领域对技术基准进行研究的重点（请参阅<a href="https://gluebenchmark.com/leaderboard" target="_blank" rel="noopener">GLUE排行榜</a>)。但是，几乎所有关于该主题的论文都宣称与当前SOTA技术具有可比或更好的结果，但这尚未导致明显的领先者出现。</li><li><strong>开放源代码：</strong>再次，这是更广泛趋势的一部分，大量使用易于使用的代码实现技术（通常还包括实验）来实现可重现性，并推动了与学术界之外的更广泛的数据科学界的互动，并推动了对真实单词问题的使用。</li><li><strong>跨任务的适用性：</strong>在有监督的嵌入式学习中，情况可能更多，尽管并非所有无监督的技术都具有相同的综合水平。无论如何，依靠文本数据中不同类型的信息，各种各样非常多样化的NLP任务使这一问题成为突出问题。从多个任务中共同学习嵌入是一种受监督的方法可以解决这一挑战的有趣方式。</li><li><strong>标记语料库：</strong>大型标记语料库的有限可用性也是今后有监督方法的问题。这可能代表了未来几年无监督方法在有监督的表示学习中的真正优势。</li></ol><p><strong>注意：</strong>如果您发现这部分内容与上下文不符，建议您在仔细阅读本文中介绍的大部分技巧后再进行访问。</p><p>本节简要介绍了两种适用于文档嵌入的成熟技术：<em>词袋</em>  和*潜在Dirichlet 分配。</p><h2 id="传统经典方法"><a href="#传统经典方法" class="headerlink" title="传统经典方法"></a>传统经典方法</h2><h3 id="Bag-of-words"><a href="#Bag-of-words" class="headerlink" title="Bag-of-words"></a>Bag-of-words</h3><p> <strong>Bag-of-words</strong><br>在[Harris，1954]中提出的这种方法将文本表示为单词的包（<a href="https://en.wikipedia.org/wiki/Multiset" target="_blank" rel="noopener">Multiset</a>) （丢失语法和排序信息）。这是通过确定一组<em>n个</em>单词组成的，这些单词将构成映射支持的词汇表，并为词汇表中的每个单词分配唯一索引。然后，每个文档都由长度为<em>n</em> 的向量表示，其中第<em>i</em> 个条目包含单词<em>i</em> 在文档中出现的次数。</p><p><img src="1.png" alt="png"></p><p>图1：例句中的单词袋表示</p><p>例如，句子“<strong>dog eat dog world, baby</strong>!” （在清理标点之后）可能由550个长度的向量<em>v表示</em>（假设选择了550个单词的词汇），除以下条目外，其他地方均为零：</p><p>•$ V_{76}= 1$，因为词汇的第76个词是<em>world</em> 。       </p><p>• $ V_{200}= 2$，因为词汇的第200个单词是<em>dog</em> 。       </p><p>• $ V_{322}= 1$，因为第332个单词是 <em>eat</em>。       </p><p>• 单词中没有选择“ <em>baby</em> ”一词，因此在不输入向量的情况下其值为1。       </p><p>尽管它非常简单，除了单词出现频率之外，所有信息都丢失了，并且表示大小迅速增长以支持丰富的词汇的趋势，这种技术几乎在几十年中几乎全部用于NLP任务，并获得了巨大成功。即使近年来在文本的矢量表示方面取得了显着进展，但仍在使用此方法的常见细微变化（如下所述），如今，这种变化并不总是唯一的，因为它只是很快被超越的第一个基线。</p><p><strong>Bag-of-n-grams</strong><br>为了获得某些单词袋方法丢失的某些单词顺序信息，可以使用短单词序列（长度为2、3等）的频率（附加或替代）构造单词向量。自然地，对于<em>n = 1</em> ，词袋是此方法的一个私有案例。</p><p>对于“<strong>dog eat dog world, baby</strong>!” 一词对是”<strong>dog eat</strong>“，”<strong>eat dog </strong>“，”<strong>dog world </strong>“和”<strong>world baby</strong>“，词汇表由输入语料库中的所有连续单词对组成。</p><p> <img src="2.png" alt="2"></p><p>图2：“电影很棒”这句话的2-gram表示法</p><p>这种方法的一个主要缺点是词汇量大小对唯一单词数量的非线性依赖性，这对于大型语料库可能非常大。过滤技术通常用于减小词汇量。</p><p><strong>TF-IDF weighting</strong><br>在词袋环境中值得一提的最后一项相关技术是<a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank" rel="noopener"><em>术语频率-逆文档频率</em></a>, 通常称为<strong>tf-idf</strong> 。此方法使用每个单词的<em>文档反向频率</em>（<strong>IDF</strong>）对上述单词（或<strong>n-gram</strong>）频率向量进行加权。单词的IDF就是语料库中文档数量除以该单词出现在其中的文档数量的对数。</p><script type="math/tex; mode=display">DIF_i = log( \frac{ \# of documents  in corpus}{\# of documents in which word i appears in})</script><p>简而言之，TF术语随着单词出现的增加而增长，而IDF术语则随着单词的稀有性而增加。这是为了针对某些单词通常更多（或更少）频繁出现这一事实来调整频率得分。参见[<a href="http://pmcnamee.net/744/papers/SaltonBuckley.pdf" target="_blank" rel="noopener">Salton &amp; Buckley, 1988</a>]，可以全面了解术语加权方法。</p><h3 id="Latent-Dirichlet-allocation-LDA"><a href="#Latent-Dirichlet-allocation-LDA" class="headerlink" title="Latent Dirichlet allocation (LDA)"></a>Latent Dirichlet allocation (LDA)</h3><p>LDA是一种生成统计模型，它允许由未观察组解释一组观察结果，这些观察组解释了为什么某些数据部分相似。例如，如果观察是收集到文档中的单词，则假定每个文档都是少量主题的混合，并且每个单词的出现都可归因于文档的一个主题。</p><p>要将其与单词袋联系起来，可以将前一种方法视为文档在单词上的分布的简单化概率模型。然后，词袋向量代表我们对每个文档中非规范化词分布的最佳近似值；但是这里的文档是概率的基本单位，每个都是其唯一分布的单个样本。</p><p>因此，问题的关键在于通过添加潜在的（隐藏的）<em>K</em> 主题中间层，从这种简单的概率性文档模型（按单词分布）转移到更复杂的模型。</p><p> <img src="3.png" alt="3"></p><p>图3：概率模型从单词袋转移到LDA</p><p>现在，主题的特征是单词的分布，而文档则是主题的分布。文档的这种概率模型对应于文档的生成模型。假设预定数量的<em>K个</em>主题，要生成一<em>组长</em>度为<em>{Nᵢ}</em> 的<em>M个</em>文档，其中<em>Dir（）</em>表示<a href="https://en.wikipedia.org/wiki/Dirichlet_distribution" target="_blank" rel="noopener">Dirichlet分布</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 对于每个主题 v ，采样一个单词分布φᵥ〜Dir  （β） 。</span><br><span class="line">2. 对于每个文档 i ，采样一个主题分布（或混合）θᵢ〜Dir  （ α  ） 。</span><br><span class="line">3. 为每个单词 j  生成长度为 Nᵢ的 文档 i ：</span><br><span class="line">   1. 为单词 j 进行服从于 Multinomial(θᵢ)分布的主题采样  .   </span><br><span class="line">   2. 对单词 j 服从于Multinomial(zᵢⱼ)分布 进行采样 。</span><br></pre></td></tr></table></figure></p><p>给定此模型和大量文档，问题就成为了推论之一，并且在推论过程中发现了上述各种分布的近似值。其中有θᵢ，每个文档<em>i</em> 的主题分布，维数<em>K的</em>向量。</p><p>因此，在推断模型的过程中，推断出维度为<em>K</em> 的向量空间，该向量空间以某种方式捕获了我们语料库中的主题或主题以及它们在文档中的共享方式。当然，可以将其视为这些文档的嵌入空间，并且-取决于<em>K</em> 的选择-其维数可以比基于词汇的维数小得多。</p><p>确实，虽然LDA的主要用例是无监督的主题/社区发现，但其他情况包括将所得的潜在主题空间用作文档语料库的嵌入空间。另外，请注意，其他主题建模技术（例如<a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" target="_blank" rel="noopener">非负矩阵分解（NMF）</a> 和<a href="https://en.wikipedia.org/wiki/Probabilistic_latent_semantic_analysis" target="_blank" rel="noopener">概率潜在语义索引（PLSI））</a> 也可以类似的方式用于学习文档嵌入空间。</p><blockquote><p><strong>注意：</strong>从业者对概率主题模型的主要问题是稳定性。由于训练主题模型需要对概率分布进行采样，因此随着随机数生成器种子的变化，同一语料库的模型可能会有所不同。主题模型对相对较小的语料库更改的敏感性使此问题更加复杂。</p></blockquote><h2 id="无监督的文本嵌入"><a href="#无监督的文本嵌入" class="headerlink" title="无监督的文本嵌入"></a>无监督的文本嵌入</h2><p>本节中介绍的许多方法均受著名的词嵌入技术的启发，其中主要的方法是<em>word2vec</em> ，它们有时甚至是这些方法的直接概括。这些词嵌入技术有时也称为<em>神经概率语言模型</em>; 这些不是完全相同的术语，因为概率语言模型是<em>单词序列上的概率分布</em>，但是由于此方法是在[ <a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">Bengio，2003</a>],中作为学习语言模型的一种方法而引入的，因此它们紧密相关。</p><p>即使假设您熟悉<em>word2vec</em> ，我仍然希望注意到此模型所做的重要假设，并且可能由这里审查的每个模型<em>（分布假设）推崇</em>。这是<a href="https://en.wikipedia.org/wiki/Distributional_semantics#Distributional_hypothesis" target="_blank" rel="noopener">维基百科</a>的简短描述：</p><blockquote><p>语言学中的<strong>分布假设</strong>源于语言使用的<a href="https://en.wikipedia.org/w/index.php?title=Semantic_theory&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">语义理论</a>，即在相同上下文中使用和出现的单词往往具有相似的含义。<a href="https://en.wikipedia.org/wiki/J._R._Firth" target="_blank" rel="noopener">Firth</a>推广了“单词由其所拥有的公司来表征”的基本思想。分布假设是<a href="https://en.wikipedia.org/wiki/Statistical_semantics" target="_blank" rel="noopener">统计语义</a>.的基础。</p></blockquote><p>确实，很容易看到<em>word2vec</em> 和其他用于学习单词表示的自我监督方法都严重依赖此假设。毕竟，模型的症结在于，在学习从单词本身来预测单词上下文时（反之亦然）学习到的单词表示形式代表了捕获深层语义和句法概念和现象的向量空间。意思是，从单词的上下文中学习可以教会我们有关单词的含义和句法作用的知识。</p><p>在本节中，将介绍自我监督的文档表示学习，您将看到所有这些方法都维护单词的这一假设，并以某种方式将其扩展到较大的文本单元。</p><h3 id="n-gram-embeddings"><a href="#n-gram-embeddings" class="headerlink" title="n-gram embeddings"></a>n-gram embeddings</h3><p>[ <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Mikolov et al，2013b</a> ]扩展了<em>word2vec</em> 的skip-gram模型，通过使用数据驱动方法识别大量短短语（作者专注于两个单词和三个单词的短语）来处理短短语。在<em>word2vec</em> 模型训练期间，将这些短语作为单独的标记。自然地，这不适合学习更长的短语-因为随着短语长度的增加，词汇量会激增-并且<em>势必不会泛化到看不见的短语</em> 及其遵循的方法。</p><p>莫西·哈祖姆（Moshe Hazoom）<a href="https://towardsdatascience.com/word2vec-for-phrases-learning-embeddings-for-more-than-one-word-727b6cf723cf" target="_blank" rel="noopener">对这种方法进行了精彩的实践回顾，</a>他的将其用于专注于金融领域的搜索引擎。</p><h3 id="Averaging-word-embeddings"><a href="#Averaging-word-embeddings" class="headerlink" title="Averaging word embeddings"></a>Averaging word embeddings</h3><p>有一种非常直观的方法可以从有意义的单词嵌入中构造文档嵌入：给定文档，对与文档单词对应的所有矢量执行一些矢量算术，以将它们汇总到同一嵌入空间中的单个矢量中；两种常见的汇总运算符是平均值和和。</p><p>在此基础上，您可能已经可以想象到，扩展<em>word2vec</em> 及其亲属的编码器-解码器体系结构以学习<em>如何</em>将单词向量组合到文档嵌入中可能会很有趣。遵循这一方法的方法属于这一类。</p><p>第二种可能性是使用固定的（不可学习的）运算符进行矢量汇总（例如求平均），并使用旨在产生丰富文档嵌入的学习目标来学习上一层中的单词嵌入；一个常见的示例是使用句子来预测上下文句子。因此，这里的主要优点是优化了词嵌入，以平均化成文档表示形式。</p><p> <img src="4.png" alt="4"></p><p>图4：来自[ <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Kenter等，2016</a> ]的暹罗CBOW网络架构</p><p>[ <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Kenter等人，2016</a> ]做到了这一点，即使用平均单词向量的简单神经网络，通过给定句子表示形式预测周围的句子，从而学习单词嵌入。他们将结果与平均的<em>word2vec</em> 向量和<em>跳思想</em>向量进行了比较（请参见下面的相应小节）。[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等，2016</a> ]比较了许多方法，包括训练CBOW和skip-gram词嵌入，同时优化句子表示（此处使用词向量的逐元素加法）。[ <a href="http://wwwusers.di.uniroma1.it/~navigli/pubs/KBS_Sinoaraetal_2019.pdf" target="_blank" rel="noopener">Sinoara等人，2019</a> ]还提出了将单词嵌入向量和其他知识源（例如单词感知向量）直接嵌入其质心以表示文档的方法。</p><p>最后，[ <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">Arora等人，2016年</a> ]进一步表明，当通过两个小变化进行增强时，此方法是一种简单但难以击败的基线：（1）使用平滑的逆频率加权方案，以及（2）消除常见的词向量的语篇成分；该组件是使用PCA找到的，它被用作最常用语的更正词，大概与语法有关。作者提供了一个<a href="https://github.com/peter3125/sentence2vec" target="_blank" rel="noopener">Python实现</a>。</p><blockquote><p><strong>注意：</strong>当查看基于注意力的机器翻译模型时，也许可以找到正确平均的单词“嵌入”功能的另一种证明。单向解码器RNN获得先前翻译的单词作为输入，不仅是要翻译的当前单词的“嵌入”（即，来自编码器RNN的双向激活），还包括周围单词的翻译。这些以加权的方式平均为上下文向量。据教导，这种加权平均能够从编码器网络的激活中维护复杂的成分和与顺序相关的信息（回想一下，这些不是像我们的情况那样不是孤立的嵌入;每个嵌入都包含前一个/后续单词的上下文）。</p></blockquote><h3 id="Sent2Vec"><a href="#Sent2Vec" class="headerlink" title="Sent2Vec"></a>Sent2Vec</h3><p>在[ <a href="https://aclweb.org/anthology/N18-1049" target="_blank" rel="noopener">Pagliardini et al，2017</a> ]和[ <a href="https://www.aclweb.org/anthology/N19-1098" target="_blank" rel="noopener">Gupta et al，2019</a> ]中提出（包括<a href="https://github.com/epfml/sent2vec" target="_blank" rel="noopener">基于C ++的官方Python实现</a>），该技术很大程度上是上述两种方法的组合：<em>word2vec</em> 的经典CBOW模型都得到了扩展包括单词n-gram <em>并</em>适用于优化单词（和n-grams）嵌入，以便对其求平均以产生文档向量。</p><p> <img src="5.png" alt="5"></p><p>图5：sent2vec可以看作是fastText的无监督版本</p><p>另外，删除了输入子采样的过程，而是将整个句子视为上下文。这意味着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（a）放弃使用频繁的单词二次采样（以防止生成n元语法特征）</span><br><span class="line">（b）放弃word2vec 使用的动态上下文窗口：考虑整个句子作为上下文窗口，而不是在1和当前句子的长度之间均匀采样每个子采样单词的上下文窗口大小。</span><br></pre></td></tr></table></figure><p>想到另一种方式<em>sent2vec</em> 是作为一种无监督的版本<em>fastText</em> ，其中整个句子是上下文和可能的类标签都是词汇。巧合的是，[ <a href="https://link.springer.com/article/10.1186/s12859-018-2496-4" target="_blank" rel="noopener">Agibetov等人，2018</a> ]感知使用比较多层的性能<em>sent2vec</em> 向量作为特征到的<em>fastText</em> ，针对生物医学句子分类的任务。</p><h3 id="Paragraph-vectors-doc2vec"><a href="#Paragraph-vectors-doc2vec" class="headerlink" title="Paragraph vectors (doc2vec)"></a>Paragraph vectors (doc2vec)</h3><p>有时称为<em>doc2vec</em> ，此方法在[ <a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Le＆Mikolov，2014</a> ]中提出，可能是首次尝试推广<em>word2vec</em> 以使其与单词序列配合使用。作者介绍了<em>段落向量</em>模型的两个变体：<em>分布式内存</em>和<em>分布式词袋。</em></p><h3 id="Paragraph-Vectors-Distributed-Memory-PV-DM"><a href="#Paragraph-Vectors-Distributed-Memory-PV-DM" class="headerlink" title="Paragraph Vectors: Distributed Memory (PV-DM)"></a>Paragraph Vectors: Distributed Memory (PV-DM)</h3><p>PV-DM模型通过添加旨在捕捉段落主题或输入内容的内存向量来增强标准的编码器-解码器模型。这里的训练任务与<em>连续单词</em>的训练非常类似; 一个单词要根据其上下文进行预测。在这种情况下，上下文单词是前面的单词，而不是段落周围的单词。</p><p> <img src="6.png" alt="6"></p><p>图6：段落向量的分布式内存模型（PV-DM）</p><p>为了实现这一点，每个段落都映射到一个唯一的向量，该向量由词汇表中矩阵中的一列表示（用<em>D</em> 表示）。上下文是固定长度的，并从段落上的滑动窗口中采样。段落向量在同一段落生成的所有上下文之间共享，但不跨段落共享。自然，词嵌入是全局的，并且可以使用经过预训练的词嵌入（请参见下面的<em>实现和增强</em>）。</p><p>与<em>word2vec中一样</em>，向量必须以某种方式汇总为单个向量。但是与<em>word2vec</em> 不同，作者在实验中使用串联。请注意，这将保留订单信息。与<em>word2vec</em> 相似，在此汇总的矢量表示上使用了一个简单的softmax分类器（在这种情况下，实际上是分层的softmax）来预测任务输出。使用随机梯度下降法并通过反向传播获得梯度，以标准方式进行训练。</p><p>请注意，只有训练语料库中的段落才具有来自<em>D</em> 的列向量。在预测时，需要执行一个推理步骤来计算新段落的段落向量：文档向量是随机初始化的。然后，重复地从新文档中选择一个随机词，并使用梯度下降来调整输入到隐藏层的权重，以使所选词的softmax概率最大化，而隐藏到softmax的输出权重为固定。这导致将新文档表示为训练语料库文档向量（即<em>D的</em>列）的混合物，自然而然地位于文档嵌入空间中。</p><p><strong>段落向量：分布式词袋（PV-DBOW）</strong><br>的第二种变体，尽管其名称如此，也许与<em>word2vec</em> 的<em>skip-gram</em> 体系结构相似。分类任务是仅使用段落向量来预测单个上下文词。在随机梯度下降的每次迭代中，对文本窗口进行采样，然后从该窗口中采样单个随机词，从而形成以下分类任务。</p><p> <img src="7.png" alt="7"></p><p>图7：段落向量的分布式词袋模型（PV-DBOW）</p><p>除不与段落向量一起共同学习单词向量的事实外，训练在其他方面相似。这使得PV-DBOW变体的内存和运行时性能都更好。</p><blockquote><p><strong>注意：</strong>在<a href="https://radimrehurek.com/gensim/models/doc2vec.html" target="_blank" rel="noopener">其Gensim实现中</a>，PV-DBOW默认情况下使用随机初始化的词嵌入；如果dbow_words设置为1，则在运行dbow之前运行一次skip-gram步骤以更新单词嵌入。[ <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau＆Baldwin，2016</a> ]认为，尽管dbow在理论上可以与随机词嵌入一起使用，但这在他们检查的任务中会严重降低性能。</p></blockquote><p>直观的解释可以追溯到模型的目标函数，该函数的目的是使文档嵌入与其组成的单词嵌入之间的点积最大化：如果单词嵌入是随机分布的，则优化文档嵌入使其更接近于变得更加困难。其更关键的内容词。</p><p><strong>应用</strong><br>[Le＆Mikolov，2014]演示了<em>段落向量</em>在多个文本分类和情感分析任务上的使用，而[Dai等，2015]在文档相似性任务和[Lau＆Baldwin， [2016年]以论坛问题重复任务和<a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener"><em>语义文本相似性（STS）SemEval</em></a>共享任务为<a href="http://ixa2.si.ehu.es/stswiki/index.php/Main_Page" target="_blank" rel="noopener"><em>基准</em></a>。后面的两篇论文都对该方法进行了扩展评估（前者侧重于PV-DBOW变体），将其与其他几种方法进行了比较，并提供了实用建议（后者<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">包括代码</a>）。</p><p>该方法具有<a href="https://radimrehurek.com/gensim/models/doc2vec.html" target="_blank" rel="noopener">gensim包的一部分的Python实现</a>和<a href="https://github.com/inejc/paragraph-vectors" target="_blank" rel="noopener">PyTorch实现</a>。再次，[ <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">Lau＆Baldwin，2016年</a> ]还<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">提供了用于检查的代码</a>。</p><p>最后，提出了对该方法的各种增强。例如，[ <a href="https://arxiv.org/abs/1512.08183" target="_blank" rel="noopener">Li等人，2016年</a> ]将该方法扩展为还包含n元语法特征，而[Thongtan＆Phienthrakul，2019年]建议在计算嵌入投影时也使用余弦相似度代替点积（也提供<a href="https://github.com/tanthongtan/dv-cosine" target="_blank" rel="noopener">Java实现</a>）。</p><h3 id="Doc2VecC"><a href="#Doc2VecC" class="headerlink" title="Doc2VecC"></a>Doc2VecC</h3><p>[ <a href="https://arxiv.org/pdf/1707.02377.pdf" target="_blank" rel="noopener">Chen，2017</a> ]提出了一种有趣的方法，该方法受段向量方法（PV-DM）的分布式存储模型以及平均词嵌入来表示文档的方法的启发。</p><p> <img src="8.png" alt="8"></p><p>图8：Doc2VecC模型的架构</p><p>类似于<em>段落向量</em>，<em>Doc2VecC</em> （通过损坏的文档向量的缩写）由输入层，投影层和输出层组成，以预测目标单词（在上例中为<strong>“ceremony”</strong>）。相邻单词的嵌入(e.g. <strong>“opening”, “for”, “the”</strong>)提供局部上下文，而整个文档的矢量表示（以灰色显示）用作全局上下文。与直接针对每个文档学习唯一矢量的<em>段落矢量</em>相反，<em>Doc2VecC</em> 将每个文档表示为从文档中随机采样的单词嵌入的平均值（例如，位置<em>p</em> 处的<strong>“performance”</strong>，位置<em>q</em> 处的<strong>“praised”</strong> 和<strong>“brazil”</strong>在位置<em>r</em> ）。</p><p>另外，作者选择通过随机删除大部分单词来破坏原始文档，从而仅对其余单词的嵌入进行平均，从而代表文档。这种破坏机制可以在训练期间加快速度，因为它大大减少了反向传播中要更新的参数数量。作者还展示了它是如何引入一种特殊形式的正则化的，他们认为这种形式可导致观察到的性能提高，以情感分析任务，文档分类任务和语义相关性任务为基准，而不是大量的最新技术。文档嵌入技术。</p><p>可以在<a href="https://github.com/mchen24/iclr2017" target="_blank" rel="noopener">公共Github存储库中</a>找到基于C语言的开源实现，用于重现本文中的实验。</p><p>[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016</a> ]还对<em>Skip-thought</em>模型（请参见以下小节）应用了破坏或增加噪声的一般思想，以增加文档的嵌入学习过程以产生更强大的嵌入空间。创建其顺序降噪自动编码器（SDAE）模型。</p><h3 id="Skip-thought-vectors"><a href="#Skip-thought-vectors" class="headerlink" title="Skip-thought vectors"></a>Skip-thought vectors</h3><p>这是在[ <a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Kiros等，2015</a> ]中提出的，这是对<em>word2vec</em> 进行泛化的另一种早期尝试，并且已与<a href="https://github.com/ryankiros/skip-thoughts" target="_blank" rel="noopener">官方的纯Python实现一起发布</a>（并且最近还夸耀了<a href="https://github.com/sanyam5/skip-thoughts" target="_blank" rel="noopener">PyTorch</a>和<a href="https://github.com/tensorflow/models/tree/master/research/skip_thoughts" target="_blank" rel="noopener">TensorFlow的实现</a>）。</p><p>但是，这以另一种直观的方式扩展了<em>word2vec</em> （尤其是<em>skip-gram</em> 体系结构）：基本单元现在是句子，并且已编码的句子用于预测其周围的句子。使用在上述任务上训练的编码器-解码器模型学习矢量表示。作者使用具有GRU激活功能的RNN编码器和具有条件GRU的RNN解码器。训练了两个不同的解码器以用于上一个和下一个句子。</p><p> <img src="9.png" alt="9"></p><p>图9：跳过思路模型。给定一个连续句子元组，对句子$s<em>i$进行编码，并尝试重建上一个句子$s</em>{i- 1}$和下一个句子$s_{i + 1}$</p><p>的<strong>词汇扩展跳</strong>字<em>思维</em>编码器使用单词嵌入层，将输入句子中的每个单词转换为对应的单词嵌入，从而有效地将输入句子转换为单词嵌入序列。该嵌入层也与两个解码器共享。</p><p> <img src="10.png" alt="10"></p><p>图10：在Skip-thought vectors中，句子sᵢ由编码器编码；两个解码器以编码器输出hᵢ的隐藏表示为条件，以预测$s<em>{i - 1}$和$s</em>{i + 1}$[摘自<a href="https://sourcediving.com/building-recipe-skill-representations-using-skip-thought-vectors-8a6e4c38ae6c" target="_blank" rel="noopener">Ammar Zaher的帖子</a> ]</p><p>但是，作者仅使用了20,000个单词的小词汇量，因此在执行各种任务期间可能会遇到许多看不见的单词。为了克服这个问题，通过解决矩阵<em>W</em> 参数化的非正规<em>L2</em> 线性回归损失，可以从在更大的词汇量上训练的词嵌入空间（例如<em>word2vec</em> ）到<em>Skip-thought</em>模型的词嵌入空间中学习映射。此映射。</p><p><strong>应用程序</strong><br>作者演示了使用<em>Skip-thought的</em>向量进行语义相关性，释义检测，图像句子排名，问题类型分类以及四个情感和主观性数据集。[ <a href="http://arno.uvt.nl/show.cgi%3Ffid%3D146003" target="_blank" rel="noopener">Broere，2017</a> ]进一步研究了<em>跳思维</em>句子表示的句法属性，方法是对它们进行逻辑回归训练以预测POS标签和依赖关系。</p><p>[ <a href="https://arxiv.org/abs/1706.03146" target="_blank" rel="noopener">Tang等，2017a</a> ]提出了一种邻域方法，用于<em>Skip-thought</em>，丢弃排序信息并使用单个解码器预测前一句话和下一句话。[ <a href="https://www.groundai.com/project/trimming-and-improving-skip-thought-vectors/1" target="_blank" rel="noopener">Tang et al，2017b</a> ]扩展了这项检查，以提出对模型的三个增强，他们声称使用更快更轻的模型可以提供可比的性能：</p><p>（1）仅学习解码下一个句子</p><p>（2）添加<em>avg  编码器和解码器之间的</em>最大*连接层（作为一种允许进行非线性非参数特征工程的方法）</p><p>（3）执行良好的词嵌入初始化。最后，[ <a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">Gan等，2016</a> ]在广泛的应用中，使用基于分层CNN-LSTM的编码器而非仅基于RNN的编码器<a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">，</a>采用了相同的方法。</p><p>在[ <a href="https://openreview.net/pdf%3Fid%3DH1a37GWCZ" target="_blank" rel="noopener">Lee＆Park，2018</a> ]中提出的另一种变体是通过基于文档结构为每个目标句子选择整个文档中有影响力的句子来学习句子嵌入的，从而使用元数据或文本样式识别句子的依存关系。此外，[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016年</a> ]提出了<em>顺序降噪自动编码器（SDAE）</em>模型，这是一种<em>跳</em>变<em>思想</em>的变体，其中输入数据根据某些噪声函数而被破坏，并且训练该模型以从破坏的数据中恢复原始数据。 。</p><p>有关进一步的非学术阅读<em>跳跃思维</em> 模式，<a href="http://sanyam5.github.io/my-thoughts-on-skip-thoughts/" target="_blank" rel="noopener">Sanyam Agarwa给出了他的博客的方法有很大的详细介绍</a></p><h3 id="FastSent"><a href="#FastSent" class="headerlink" title="FastSent"></a>FastSent</h3><p>[ <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Hill等人，2016年</a> ]提出了一种关于<em>跳跃思维</em>模型的明显简化的变体。<em>FastSent</em> 是一个简单的加法（对数双线性）语句模型，旨在利用相同的信号，但计算成本却低得多。给定某些上下文句子的BOW表示，该模型仅预测相邻句子（也表示为BOW）。更正式地说，<em>FastSent</em> 为模型词汇表中的每个单词<em>w</em> 学习源uᵂ和目标vᵂ嵌入。对于训练例如$S<em>{i- 1}$，$S</em>{i}$，连续句子$S<em>{i+1}$，$S</em>{i- 1}$被表示为它的源的嵌入的总和$s_i = \sum u^w $超过$w∈S_i$ 。$φ（s_i，v^w）$超过</p><p>$w∈ S<em>{i- 1}∪S</em>{i + 1}$，其中φ是SOFTMAX功能。本文附带了<a href="https://github.com/fh295/SentenceRepresentation" target="_blank" rel="noopener">一个官方的Python实现</a>。</p><h3 id="Quick-thought-vectors"><a href="#Quick-thought-vectors" class="headerlink" title="Quick-thought vectors"></a>Quick-thought vectors</h3><p>[ <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">Logeswaran＆Lee，2018</a> ]将文件嵌入任务（即预测句子出现上下文的问题）重新设计为监督分类问题（参见图12b），而不是先前方法的预测任务（参见图12a）。</p><p> <img src="11.png" alt="11"></p><p>图11：快速思考问题的表述（b）与跳过思考方法（a）的对比</p><p>要点是使用当前句子的含义来预测相邻句子的含义，其中含义由从编码函数计算出的句子的嵌入表示；注意，这里学习了两个编码器：<em>f</em> 代表输入语句，<em>g</em> 代表候选项。给定一个输入语句，它由编码器（在这种情况下为RNN）进行编码，但是模型没有生成目标语句，而是从一组候选语句中选择了正确的目标语句。候选集是根据有效的上下文句子（基本事实）和许多其他非上下文句子构建的。最后，构造的训练目标最大程度地为训练数据中的每个句子标识了正确的上下文句子。将以前的句子预测公式看作是从所有可能的句子中选择一个句子，这种新方法可以看作是对预测问题的判别近似。</p><p>作者评估了他们在各种文本分类，释义识别和语义相关性任务上的方法，并提供<a href="https://github.com/lajanugen/S2V" target="_blank" rel="noopener">了官方的Python实现</a>。</p><h3 id="Word-Mover’s-Embedding-WME"><a href="#Word-Mover’s-Embedding-WME" class="headerlink" title="Word Mover’s Embedding (WME)"></a>Word Mover’s Embedding (WME)</h3><p>来自IBM研究的一种非常新的方法是在[ <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Wu et al，2018b</a> ]中提出的<em>Word Mover的嵌入</em>（WME）。<a href="https://github.com/IBM/WordMoversEmbeddings" target="_blank" rel="noopener">提供了一个基于C的官方官方Python封装实现</a>。</p><p>[ <a href="http://proceedings.mlr.press/v37/kusnerb15.pdf" target="_blank" rel="noopener">Kushner et al，2015</a> ]提出了世界<em>移动距离</em>（WMD）；这测量了两个文本文档之间的差异，这是一个文档的嵌入单词<strong>在嵌入空间中</strong>需要“移动” 才能到达另一文档的嵌入单词的最小距离（参见图13a）。另外，[ <a href="https://arxiv.org/pdf/1802.04956.pdf" target="_blank" rel="noopener">Wu等，2018a</a> ]提出了D2KE（到核和嵌入的距离），这是一种从给定距离函数推导正定核的通用方法。</p><p> <img src="12.png" alt="12"></p><p>图12：WMD与WME的对比。（a）WMD测量两个文档<em>x</em> 和y 之间的距离，而（b）WME近似于从WMD导出的带有一组随机文档kernel的核。</p><p>WME基于三个组件来学习长度可变的文本的连续矢量表示形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 以无人监督的方式学习高质量词嵌入的能力（例如，使用*word2vec* ）。</span><br><span class="line">2. 使用WMD基于所述嵌入为文档构造距离度量的能力。</span><br><span class="line">3. 使用D2KE从给定的距离函数导出正定核的能力。</span><br></pre></td></tr></table></figure><p>使用这三个组件，将应用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 使用D2KE，通过给定分布中*单词移动器的距离*（WMD）到随机文档given的无限维特征图，构造正定*单词移动器的内核（WMK）。由于使用了WMD，因此特征图考虑了预训练单词嵌入所给出的语义空间中文档之间各个单词的对齐方式（请参见图12b）。</span><br><span class="line">2. 基于该内核，通过该内核的随机特征近似推导嵌入的文档，其内积近似于精确的内核计算。</span><br></pre></td></tr></table></figure><p>该框架是可扩展的，因为它的两个构件<em>word2vec</em> 和WMD可以用其他技术代替，例如<em>GloVe</em> （用于词嵌入）或S-WMD（用于将词嵌入空间转换为文档距离度量）。</p><p>作者在9个真实世界中的文本分类任务和22个文本相似性任务上对WME进行了评估，并证明了WME与其他最新技术始终如一地匹配，甚至优于其他最新技术。</p><h3 id="Sentence-BERT-SBERT"><a href="#Sentence-BERT-SBERT" class="headerlink" title="Sentence-BERT (SBERT)"></a>Sentence-BERT (SBERT)</h3><p>NLP的2018年以Transformer的兴起为标志，最新的神经语言模型受到[ <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Vaswani et al 2017</a> ]中提出的Transformer模型的启发-序列模型同时消除了卷积和重复发生，而是将注意力转移到序列表示中。这个蓬勃发展的系列包括BERT（及其扩展名），GPT（1和2）以及XL风味的Transformer。</p><p>这些模型生成输入令牌（通常为子单词单元）的上下文嵌入，每个令牌都注入了其邻域的信息，但并非旨在为输入序列生成丰富的嵌入空间。BERT甚至有一个特殊的[CLS]令牌，其输出嵌入用于分类任务，但对于其他任务而言，输入序列的嵌入仍然很差。[ <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Reimers＆Gurevych，2019年</a> ]</p><p><em>Sentence-BERT</em> ，在[ <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Reimers＆Gurevych，2019</a> ]中提出，并附带<a href="https://github.com/UKPLab/sentence-transformers" target="_blank" rel="noopener">一个Python实现</a>，旨在通过使用暹罗和三元组网络结构来派生可以使用余弦相似度进行比较的语义有意义的句子嵌入，以适应BERT体系结构（请参见Fifure 14）。</p><p><img src="13.png" alt="13"></p><p>图14：针对分类目标（左）和推理（右）的训练中的SBERT架构</p><h2 id="有监督的向量嵌入"><a href="#有监督的向量嵌入" class="headerlink" title="有监督的向量嵌入"></a>有监督的向量嵌入</h2><p><code>上一节中介绍的无监督方法使我们可以从大型未标记的语料库中学习有用的表示形式。这种方法并非自然语言处理所独有，而是通过设计学习目标来学习学习表示形式，这些学习目标利用了数据中可自由使用的标签。因此，这些方法的强度和鲁棒性不仅在很大程度上取决于学习框架，而且还取决于人工设计的学习目标要求或带来对有意义的特征或知识的学习的良好程度，这些特征或知识在各种下游任务中将是有用的。例如，我们希望通过单词和文档嵌入空间可以很好地捕获语义和句法信息。</code></p><p><code>学习数据有意义的表示法（在我们的情况下是单词序列）的对比方法是利用显式标签（几乎总是由人类注释者以某种方式生成）。在这里，与各种任务的相关性取决于显式任务和用于最终应用程序的标签的接近程度，并且再次取决于此任务带来了对通用特性和知识的学习程度。</code></p><p><code>我们将看到有监督的方法，从直接利用特定标记任务来学习表示形式的方法，到重组任务或从中提取新标记任务以引发更好表示的方法。</code></p><p><strong>通过标签数据学习文本嵌入</strong></p><p>已经进行了各种尝试来使用标记的或结构化的数据来学习句子表示。具体来说，[ <a href="https://www.aclweb.org/anthology/D14-1179" target="_blank" rel="noopener">Cho等，2014a</a> ]和[ <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">Sutskever等，2014</a> ]可能是首次尝试使用编码器/解码器方法来显式学习带有标记数据的句子/短语嵌入；第一个使用<em>Europarl</em> （统计机器翻译的平行短语语料库），第二个使用WMT-14数据集中的英语到法语的翻译任务。[ <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Wieting et al，2015</a> ]和[Wieting＆Gimpel，2017] 提出了另一种此类显着尝试，其中共同学习了单词嵌入及其在文档嵌入中的映射，以最大程度地减少了复述对之间的余弦相似度（来自<a href="http://paraphrase.org/%23/#/" target="_blank" rel="noopener">PPDB数据集</a>） 。[ <a href="https://arxiv.org/pdf/1504.00548.pdf" target="_blank" rel="noopener">Hill等，2015</a> ]训练了神经语言模型，以将字典定义映射到由这些定义定义的单词的预训练单词嵌入。最后，[ <a href="https://www.aclweb.org/anthology/D17-1070.pdf" target="_blank" rel="noopener">Conneau等，2017</a> ]在斯坦福大学自然语言推理任务上训练了各种体系结构的NN编码器（请参见图16）。</p><p> <img src="14.png" alt="14"></p><p>图15：通用的NLI训练方案</p><h3 id="文档相似性的上下文嵌入"><a href="#文档相似性的上下文嵌入" class="headerlink" title="文档相似性的上下文嵌入"></a>文档相似性的上下文嵌入</h3><p>上述方法的一种特定情况是由文档相似性驱动的。[ <a href="https://www.aclweb.org/anthology/P16-1036" target="_blank" rel="noopener">Das等，2016</a> ]展示了文档嵌入，这些嵌入是通过针对社区Q / A的暹罗网络使两个文档之间的相似度最大化的。（见图17）</p><p> <img src="15.png" alt="png"></p><p>图16：SCQA网络由重复的卷积，最大池和ReLU层以及一个完全连接的层组成。权重W1到W5在子网之间共享。</p><p>同样，[ <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Nicosia＆Moschitti，2017</a> ]使用暹罗网络在学习二进制文本相似性的同时产生单词表示，同时考虑相同类别中的示例相似。（参见图18）</p><p> <img src="16.png" alt="16"></p><p>图17：[ <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Nicosia＆Moschitti，2017</a> ] 中的暹罗网络架构。每个句子的单词嵌入由3个双向GRU的堆栈使用。两个网络分支共享参数权重。</p><p>跨语言降<strong>秩岭回归（Cr5）</strong>[Josifoski et al，2019]引入了一种方法，用于将以任何语言编写的文档嵌入到一个独立于语言的向量空间中。这是通过训练基于岭回归的分类器来完成的，该分类器使用特定于语言的词袋功能来预测给定文档所涉及的概念。当将学习的权重矩阵约束为低等级时，作者表明可以将其作为因素来获得从特定于语言的词袋到独立于语言的嵌入的期望映射。<a href="https://github.com/epfl-dlab/Cr5" target="_blank" rel="noopener">提供了一个官方的Python实现</a>。</p><h3 id="特定于任务的监督文档嵌入"><a href="#特定于任务的监督文档嵌入" class="headerlink" title="特定于任务的监督文档嵌入"></a>特定于任务的监督文档嵌入</h3><p>一种用于生成文档嵌入的常见监督方法是使用各种神经网络体系结构，学习将单词向量映射到文档向量的合成运算符；它们被传递给受监督的任务，并依赖于类标签，以便在合成权重之间反向传播（请参见图19）。</p><p>因此，网络的几乎所有隐藏层都可以被视为产生输入文档的向量嵌入，其中直到该层的网络前缀都是从单词向量到嵌入空间的学习映射。在[ <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Wieting等人，2015</a> ]中可以找到对基于单词向量和监督学习任务的学习句子向量的不同方法的严格检查。</p><p> <img src="17.png" alt="17"></p><p>图18：神经网络隐式学习将单词嵌入序列映射到文档嵌入</p><p>请注意，虽然所使用的单词嵌入可以预先生成并且与任务无关（至少在一定程度上），但从它们中学到的文档嵌入映射是特定于任务的。尽管这些方法对相关任务很有用，但至少在理论上，与无监督方法相比，此方法势必不那么健壮和通用。[ <a href="https://arxiv.org/pdf/1506.06726.pdf" target="_blank" rel="noopener">Kiros等，2015</a> ]</p><p>值得注意的用途包括使用RNN进行情感分类[Socher等，2013]，使用CNN进行各种文本分类[Kalchbrenner等，2014] [Kim，2014]以及使用递归卷积神经网络进行机器翻译和文本分类[Cho等]等，2014a，2014b] [Zhao等，2015]。</p><ul><li><p><strong>GPT</strong><br>[ <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener">Radford等人，2018</a> ] <a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener">提出了一种</a><a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener"><em>生成式预训练</em></a><a href="https://openai.com/blog/language-unsupervised/" target="_blank" rel="noopener">（GPT）方法</a>（<a href="https://github.com/openai/finetune-transformer-lm" target="_blank" rel="noopener">伴随Python实现</a>），使用[ <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Vaswani等人2017</a> ]中介绍的转换模型，将无监督和有监督的表示学习结合起来，学习无监督语言对未标记的语料库进行建模，然后使用监督数据分别微调其在每个任务中的使用。<a href="https://openai.com/blog/better-language-models/" target="_blank" rel="noopener">他们随后</a>在[ <a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener">Radford et al，2019</a> ]中<a href="https://openai.com/blog/better-language-models/" target="_blank" rel="noopener">介绍了GPT-2</a>，重点是加强他们工作中的无监督学习部分，并再次<a href="https://github.com/openai/gpt-2" target="_blank" rel="noopener">发布了正式的Python实现</a>。</p></li><li><p><strong>深度语义相似性模型（DSSM）</strong><br><a href="https://www.microsoft.com/en-us/research/project/dssm/" target="_blank" rel="noopener">作为Microsoft研究项目</a>，DSSM是一种深度神经网络建模技术，用于表示连续语义空间中的文本字符串并为两个文本字符串之间的语义相似性建模（请参见图20）。</p><p><img src="19.png" alt="19"></p></li></ul><p>图19：DSSM神经网络的架构</p><p>除其他应用程序外，DSSM还用于开发潜在语义模型，该模型将不同类型的实体（例如查询和文档）投影到公共的低维语义空间中，以用于各种机器学习任务，例如排名和分类。例如，[ <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf" target="_blank" rel="noopener">Huang et al，2013</a> ]使用它将查询和文档投影到一个公共的低维空间，在该空间中，给定查询的文档的相关性被计算为它们之间的距离。</p><p>实现包括<a href="https://kishorepv.github.io/DSSM/" target="_blank" rel="noopener">TensorFlow</a>，<a href="https://github.com/airalcorn2/Deep-Semantic-Similarity-Model" target="_blank" rel="noopener">Keras</a>和<a href="https://github.com/nishnik/Deep-Semantic-Similarity-Model-PyTorch" target="_blank" rel="noopener">2个PyTorch </a><a href="https://github.com/moinnadeem/CDSSM" target="_blank" rel="noopener">变化</a>。</p><h3 id="联合学习句子表示"><a href="#联合学习句子表示" class="headerlink" title="联合学习句子表示"></a>联合学习句子表示</h3><p>[ <a href="https://arxiv.org/pdf/1810.00681v1.pdf" target="_blank" rel="noopener">Ahmad et al，2018</a> ]建议从多个文本分类任务中共同学习句子表示，并将它们与预训练的单词级和句子级编码器结合使用，可以得到健壮的句子表示，可用于迁移学习</p><p> <img src="18.png" alt="18"></p><p>图20：使用辅助任务共同学习句子嵌入</p><p>[ <a href="https://www.semanticscholar.org/paper/Learning-Sentence-Embeddings-with-Auxiliary-Tasks-Yu-Jiang/2d38f7aab07d4435b2110602db4138ef20da4cc0" target="_blank" rel="noopener">Yu＆Jiang，2016</a> ]类似地表明，使用两个辅助任务来帮助诱导句子嵌入在情感分类中跨域的工作很有效，与情感分类器本身一起共同学习该句子的嵌入（图21）。</p><p>在[ <a href="https://arxiv.org/pdf/1803.11175.pdf" target="_blank" rel="noopener">Cer等人，2018a</a> ]和[ <a href="https://www.aclweb.org/anthology/D18-2029/" target="_blank" rel="noopener">Cer等人，2018b</a> ]中提出的</p><p><strong>通用句子编码器</strong>，并伴随<a href="https://tfhub.dev/google/universal-sentence-encoder/2" target="_blank" rel="noopener">着TensorFlow实现</a>，该方法实际上包括两种可能的句子表示学习模型：<em>Transformer</em> 模型和<em>Deep Averaging Network（DAN） ）</em>模型（请参见图22）。两者都旨在允许多任务学习，并且支持的任务包括（1）作为无监督学习的<em>基调思维</em>任务；（2）对话输入响应任务，用于包含已解析的对话数据；（3）用于监督数据训练的分类任务（请参阅前面的小节）。作者专注于具有转移学习任务的实验，并对照简单的CNN和DAN基准对他们的模型进行了基准测试。该方法后来<a href="https://ai.googleblog.com/2019/07/multilingual-universal-sentence-encoder.html" target="_blank" rel="noopener">扩展为解决多语言设置</a>。</p><p>的<em>变压器</em>模型直接基于在[提出的变压器模型<a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">瓦斯瓦尼等人2017</a> ]，所述第一序列转导模型完全基于注意，取代在编码器-解码器的体系结构最常用的多双头自关注的复发性层（参见图22a）。</p><p>该模型使用转换器体系结构的编码子图构造句子嵌入。编码器使用注意力来计算句子中单词的上下文感知表示，同时考虑其他单词的顺序和身份。将上下文感知的单词表示形式平均在一起，以获得句子级的嵌入。</p><p>  <img src="20.png" alt="png"></p><p>图22：通用句子编码器的两种模型：（a）变压器和（b）DAN</p><p>相反，在[ <a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">Iyyer et al，2015</a> ]中提出的DAN模型中，单词和<a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">二元语法的</a>输入嵌入首先被平均在一起，然后通过前馈深度神经网络（DNN）生成句子嵌入（见图22b）。 。</p><p><strong>GenSen</strong><br>与通用句子编码器非常相似，[ <a href="https://arxiv.org/pdf/1804.00079.pdf" target="_blank" rel="noopener">Subramanian et al，2018</a> ]中介绍的GenSen方法与<a href="https://github.com/Maluuba/gensen" target="_blank" rel="noopener">官方Python实现一起</a>，结合了多个有监督和无监督的学习任务，以训练基于RNN w / GRU的编码器-解码器模型，嵌入被提取。支持的四个任务是：（1）<em>跳跳</em>向量，（2）神经机器翻译，（3）选区解析和（4）自然语言推论（三向分类问题；给定前提和假设句子，目的是将他们的关系归类为牵连，矛盾或中立。<a href="https://github.com/Maluuba/gensen" target="_blank" rel="noopener">正式的Python实现已发布</a>。</p><h2 id="如何选择各种嵌入方法"><a href="#如何选择各种嵌入方法" class="headerlink" title="如何选择各种嵌入方法"></a>如何选择各种嵌入方法</h2><p>我在这里没有简单的答案，但是这里有一些可能的要点：</p><ol><li><strong>平均单词向量是一个很强的基准</strong>，因此一个好主意是通过着重于生成非常好的单词向量并首先简单地对其求<strong>平均</strong>来开始寻求好的文档嵌入。毫无疑问，文档嵌入的强大功能大部分来自构建它们的词向量，我可以肯定地说，在前进之前，有大量信息要优化。您可以尝试不同的预训练词嵌入，探索哪些源域和哪些方法（例如word2vec，GloVe，BERT，ELMo）可以更好地捕获所需的信息类型。然后，通过尝试使用不同的汇总运算符或其他技巧（如[ <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">Arora等，2016</a> ]中的那些技巧）稍微扩展一下可能已足够。</li><li><strong>性能可能是一个关键考虑因素</strong>，尤其是在方法之间没有明确领导者的情况下。在这种情况下，<a href="https://translate.googleusercontent.com/translate_f#ecd3" target="_blank" rel="noopener">平均单词向量</a>和一些精益方法（如<a href="https://translate.googleusercontent.com/translate_f#e3d4" target="_blank" rel="noopener"><em>send2vec</em></a>和<a href="https://translate.googleusercontent.com/translate_f#e6e8" target="_blank" rel="noopener"><em>FastSent</em></a>）都是不错的选择。相反，在使用<em>doc2vec</em> 时，给定每个句子所需的实时向量表示推断，可能会因应用程序限制而证明代价高昂。<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">SentEval</a>是[ <a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Conneau＆Kiela，2018</a> ]中提出的<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">用于句子表示的评估工具包，</a>在这种情况下值得一提。</li><li><strong>考虑学习目标对您任务的有效性</strong>。上面介绍的不同的自我监督技术以不同的方式扩展<em>了分布假设</em>，而<em>Skip-thought</em>和<em>快速思想则</em>基于句子/段落在文档中的距离对它们之间的紧密关系进行建模。这可能对书籍，文章和社交媒体帖子而言微不足道，但可能不适用于其他文本序列，尤其是结构化文本序列，因此可能会将您的文档投影到不适用于它们的嵌入空间中。同样，WME依赖的单词对齐方法可能并不适用于所有情况。</li><li><strong>开源实现非常丰富</strong>，因此针对您的任务对不同方法进行基准测试可能是可行的。</li><li><strong>没有明确的特定任务负责人。</strong>论文经常针对分类，释义和语义相关性任务对不同的方法进行基准测试。然而，上述结论是在考虑有关该主题的全部文献时，特别是在考虑了2018年的两个最新基准的结果时得出的，[ <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">Logeswaran＆Lee，2018</a> ]首先提出了他们的<em>快速思考方法。</em>第二种方法是[ <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Wu et al，2018b</a> ]，这是他们关于<em>Word Mover嵌入</em>的论文的一部分。</li></ol><p>最后，我发现它值得一提的是<em>关键词中包含的代码</em>有<a href="https://paperswithcode.com/task/document-embedding" target="_blank" rel="noopener">一个专门的文件嵌入任务</a>，而且Facebook的研究具有开源<a href="https://github.com/facebookresearch/SentEval" target="_blank" rel="noopener">SentEval，评估工具包句子表示</a>在[呈现<a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Conneau＆Kiela，2018</a> ]</p><p>本文章翻译自原文[原文连接]<a href="https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d.其对目前大概的文本嵌入方式进行了总结" target="_blank" rel="noopener">https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d.其对目前大概的文本嵌入方式进行了总结</a>. </p><p>我后面将会把最新的文本嵌入方法进行更新.并且计划将上述文本表示进行实践.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Agibetov, A., Blagec, K., Xu, H., &amp; Samwald, M. (2018). <a href="https://link.springer.com/article/10.1186/s12859-018-2496-4" target="_blank" rel="noopener">Fast and scalable neural embedding models for biomedical sentence classification</a>. <em>BMC bioinformatics</em>, <em>19</em>(1), 541.</p><p>Ahmad, W. U., Bai, X., Peng, N., &amp; Chang, K. W. (2018). <a href="https://arxiv.org/pdf/1810.00681v1.pdf" target="_blank" rel="noopener">Learning Robust, Transferable Sentence Representations for Text Classification</a>. <em>arXiv preprint arXiv:1810.00681</em>.</p><p>Arora, S., Liang, Y., &amp; Ma, T. (2016). <a href="https://pdfs.semanticscholar.org/3fc9/7768dc0b36449ec377d6a4cad8827908d5b4.pdf" target="_blank" rel="noopener">A simple but tough-to-beat baseline for sentence embeddings</a>. [<a href="https://github.com/peter3125/sentence2vec" target="_blank" rel="noopener">unofficial implementation</a>]</p><p>Bengio, Y., Ducharme, R., Vincent, P., &amp; Jauvin, C. (2003). <a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="noopener">A neural probabilistic language model</a>. <em>Journal of machine learning research</em>, <em>3</em>(Feb), 1137–1155.</p><p>B. Broere, (2017). <a href="http://arno.uvt.nl/show.cgi?fid=146003" target="_blank" rel="noopener">Syntactic properties of skip-thought vectors</a>. <em>Master’s thesis, Tilburg University</em>.</p><p>Cer, D., Yang, Y., Kong, S. Y., Hua, N., Limtiaco, N., John, R. S., … &amp; Sung, Y. H. (2018). <a href="https://arxiv.org/pdf/1803.11175.pdf" target="_blank" rel="noopener">Universal sentence encoder</a>. <em>arXiv preprint arXiv:1803.11175</em>.</p><p>Cer, D., Yang, Y., Kong, S. Y., Hua, N., Limtiaco, N., John, R. S., … &amp; Strope, B. (2018, November). <a href="https://www.aclweb.org/anthology/D18-2029/" target="_blank" rel="noopener">Universal sentence encoder for English</a>. In <em>Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing: System Demonstrations</em> (pp. 169–174).</p><p>Chen, M. (2017). <a href="https://arxiv.org/pdf/1707.02377.pdf" target="_blank" rel="noopener">Efficient vector representation for documents through corruption</a>. <em>arXiv preprint arXiv:1707.02377</em>.</p><p>Chen, Q., Peng, Y., &amp; Lu, Z. (2018). <a href="https://arxiv.org/pdf/1810.09302.pdf" target="_blank" rel="noopener">BioSentVec: creating sentence embeddings for biomedical texts</a>. arXiv preprint arXiv:1810.09302.</p><p>Cho, K., Van Merriënboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., &amp; Bengio, Y. (2014). <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning phrase representations using RNN encoder-decoder for statistical machine translation</a>. <em>arXiv preprint arXiv:1406.1078</em>.</p><p>Cho, K., Van Merriënboer, B., Bahdanau, D., &amp; Bengio, Y. (2014). <a href="https://arxiv.org/abs/1409.1259" target="_blank" rel="noopener">On the properties of neural machine translation: Encoder-decoder approaches</a>. <em>arXiv preprint arXiv:1409.1259</em>.</p><p>Conneau, A., Kiela, D., Schwenk, H., Barrault, L., &amp; Bordes, A. (2017). <a href="https://www.aclweb.org/anthology/D17-1070.pdf" target="_blank" rel="noopener">Supervised learning of universal sentence representations from natural language inference data</a>. <em>arXiv preprint arXiv:1705.02364</em>.</p><p>Conneau, A., &amp; Kiela, D. (2018). <a href="https://arxiv.org/pdf/1803.05449.pdf" target="_blank" rel="noopener">Senteval: An evaluation toolkit for universal sentence representations</a>. <em>arXiv preprint arXiv:1803.05449</em>.</p><p>Dai, A. M., Olah, C., &amp; Le, Q. V. (2015). <a href="https://arxiv.org/pdf/1507.07998.pdf" target="_blank" rel="noopener">Document embedding with paragraph vectors</a>. <em>arXiv preprint arXiv:1507.07998</em>.</p><p>Das, A., Yenala, H., Chinnakotla, M., &amp; Shrivastava, M. (2016, August). <a href="https://www.aclweb.org/anthology/P16-1036" target="_blank" rel="noopener">Together we stand: Siamese networks for similar question retrieval</a>. In <em>Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</em> (pp. 378–387).</p><p>Gan, Z., Pu, Y., Henao, R., Li, C., He, X., &amp; Carin, L. (2016). Unsupervised learning of sentence representations using convolutional neural networks. <em>arXiv preprint arXiv:1611.07897</em>.</p><p>Gan, Z., Pu, Y., Henao, R., Li, C., He, X., &amp; Carin, L. (2016). <a href="https://arxiv.org/pdf/1611.07897.pdf" target="_blank" rel="noopener">Learning generic sentence representations using convolutional neural networks</a>. <em>arXiv preprint arXiv:1611.07897</em>.</p><p>Gupta, P., Pagliardini, M., &amp; Jaggi, M. (2019). <a href="https://www.aclweb.org/anthology/N19-1098" target="_blank" rel="noopener">Better Word Embeddings by Disentangling Contextual n-Gram Information</a>. <em>arXiv preprint arXiv:1904.05033</em>.</p><p>Harris, Z. S. (1954). Distributional structure. Word, 10(2–3), 146–162.</p><p>Hill, F., Cho, K., Korhonen, A., &amp; Bengio, Y. (2015). <a href="https://arxiv.org/pdf/1504.00548.pdf" target="_blank" rel="noopener">Learning to understand phrases by embedding the dictionary</a>. <em>Transactions of the Association for Computational Linguistics</em>, <em>4</em>, 17–30.</p><p>Hill, F., Cho, K., &amp; Korhonen, A. (2016). <a href="https://www.aclweb.org/anthology/N16-1162" target="_blank" rel="noopener">Learning distributed representations of sentences from unlabelled data</a>. <em>arXiv preprint arXiv:1602.03483</em>.</p><p>Huang, P. S., He, X., Gao, J., Deng, L., Acero, A., &amp; Heck, L. (2013, October). <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/cikm2013_DSSM_fullversion.pdf" target="_blank" rel="noopener">Learning deep structured semantic models for web search using clickthrough data</a>. In <em>Proceedings of the 22nd ACM international conference on Information &amp; Knowledge Management</em> (pp. 2333–2338). ACM.</p><p>Iyyer, M., Manjunatha, V., Boyd-Graber, J., &amp; Daumé III, H. (2015). <a href="https://people.cs.umass.edu/~miyyer/pubs/2015_acl_dan.pdf" target="_blank" rel="noopener">Deep unordered composition rivals syntactic methods for text classification</a>. In <em>Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)</em> (Vol. 1, pp. 1681–1691).</p><p>Josifoski, M., Paskov, I. S., Paskov, H. S., Jaggi, M., &amp; West, R. (2019, January). <a href="https://dl.acm.org/citation.cfm?id=3291023" target="_blank" rel="noopener">Crosslingual Document Embedding as Reduced-Rank Ridge Regression</a>. In <em>Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining</em> (pp. 744–752). ACM.</p><p>Kalchbrenner, N., Grefenstette, E., &amp; Blunsom, P. (2014). A convolutional neural network for modelling sentences. <em>arXiv preprint arXiv:1404.2188</em>.</p><p>Kenter, T., Borisov, A., &amp; De Rijke, M. (2016). <a href="https://arxiv.org/pdf/1606.04640.pdf" target="_blank" rel="noopener">Siamese cbow: Optimizing word embeddings for sentence representations</a>. <em>arXiv preprint arXiv:1606.04640</em>.</p><p>Kim, Yoon. “Convolutional neural networks for sentence classification.” <em>arXiv preprint arXiv:1408.5882</em> (2014).</p><p>Kiros, R., Zhu, Y., Salakhutdinov, R. R., Zemel, R., Urtasun, R., Torralba, A., &amp; Fidler, S. (2015). <a href="https://arxiv.org/abs/1506.06726" target="_blank" rel="noopener">Skip-thought vectors</a>. In <em>Advances in neural information processing systems</em> (pp. 3294–3302).</p><p>Kusner, M., Sun, Y., Kolkin, N., &amp; Weinberger, K. (2015, June). <a href="http://proceedings.mlr.press/v37/kusnerb15.pdf" target="_blank" rel="noopener">From word embeddings to document distances</a>. In <em>International conference on machine learning</em> (pp. 957–966).</p><p>Lau, J. H., &amp; Baldwin, T. (2016). <a href="https://arxiv.org/pdf/1607.05368.pdf" target="_blank" rel="noopener">An empirical evaluation of doc2vec with practical insights into document embedding generation</a>. <em>arXiv preprint arXiv:1607.05368</em>. [<a href="https://github.com/jhlau/doc2vec" target="_blank" rel="noopener">code</a>]</p><p>Le, Q., &amp; Mikolov, T. (2014, January). <a href="https://cs.stanford.edu/~quocle/paragraph_vector.pdf" target="_blank" rel="noopener">Distributed representations of sentences and documents</a>. In <em>International conference on machine learning</em> (pp. 1188–1196).</p><p>Lee, T., &amp; Park, Y. (2018). <a href="https://openreview.net/forum?id=H1a37GWCZ" target="_blank" rel="noopener">UNSUPERVISED SENTENCE EMBEDDING USING DOCUMENT STRUCTURE-BASED CONTEXT</a>.</p><p>Logeswaran, L., &amp; Lee, H. (2018). <a href="https://arxiv.org/pdf/1803.02893.pdf" target="_blank" rel="noopener">An efficient framework for learning sentence representations</a>. arXiv preprint arXiv:1803.02893.</p><p>Li, B., Liu, T., Du, X., Zhang, D., &amp; Zhao, Z. (2015). <a href="https://arxiv.org/abs/1512.08183" target="_blank" rel="noopener">Learning document embeddings by predicting n-grams for sentiment classification of long movie reviews</a>. <em>arXiv preprint arXiv:1512.08183</em>.</p><p>Liu, Y., &amp; Lapata, M. (2018). Learning structured text representations. Transactions of the Association for Computational Linguistics, 6, 63–75.</p><p>Mikolov, T., Chen, K., Corrado, G., &amp; Dean, J. (2013). <a href="https://arxiv.org/pdf/1301.3781.pdf" target="_blank" rel="noopener">Efficient estimation of word representations in vector space</a>. arXiv preprint arXiv:1301.3781.</p><p>Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf" target="_blank" rel="noopener">Distributed representations of words and phrases and their compositionality</a>. In <em>Advances in neural information processing systems</em> (pp. 3111–3119).</p><p>Nicosia, M., &amp; Moschitti, A. (2017, August). <a href="https://www.aclweb.org/anthology/K17-1027" target="_blank" rel="noopener">Learning contextual embeddings for structural semantic similarity using categorical information</a>. In <em>Proceedings of the 21st Conference on Computational Natural Language Learning (CoNLL 2017)</em>(pp. 260–270).</p><p>Pagliardini, M., Gupta, P., &amp; Jaggi, M. (2017). <a href="https://aclweb.org/anthology/N18-1049" target="_blank" rel="noopener">Unsupervised learning of sentence embeddings using compositional n-gram features</a>. <em>arXiv preprint arXiv:1703.02507</em>.</p><p>Pennington, J., Socher, R., &amp; Manning, C. (2014, October). <a href="https://www.aclweb.org/anthology/D14-1162" target="_blank" rel="noopener">Glove: Global vectors for word representation</a>. In <em>Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP)</em> (pp. 1532–1543).</p><p>Radford, A., Narasimhan, K., Salimans, T., &amp; Sutskever, I. (2018). <a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener"><em>Improving language understanding with unsupervised learning</em></a>. Technical report, OpenAI.</p><p>Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., &amp; Sutskever, I. (2019). <a href="https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener">Language models are unsupervised multitask learners</a>. <em>OpenAI Blog</em>, <em>1</em>(8).</p><p>Reimers, N., &amp; Gurevych, I. (2019). <a href="https://arxiv.org/pdf/1908.10084.pdf" target="_blank" rel="noopener">Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</a>. <em>arXiv preprint arXiv:1908.10084</em>.</p><p>Rudolph, M., Ruiz, F., Athey, S., &amp; Blei, D. (2017). Structured embedding models for grouped data. In <em>Advances in neural information processing systems</em> (pp. 251–261).</p><p>Salton, G., &amp; Buckley, C. (1988). <a href="http://pmcnamee.net/744/papers/SaltonBuckley.pdf" target="_blank" rel="noopener">Term-weighting approaches in automatic text retrieval</a>. <em>Information processing &amp; management</em>, <em>24</em>(5), 513–523.</p><p>Sinoara, R. A., Camacho-Collados, J., Rossi, R. G., Navigli, R., &amp; Rezende, S. O. (2019). <a href="https://www.sciencedirect.com/science/article/pii/S0950705118305124" target="_blank" rel="noopener">Knowledge-enhanced document embeddings for text classification</a>. <em>Knowledge-Based Systems</em>, <em>163</em>, 955–971.</p><p>Socher, R., Perelygin, A., Wu, J., Chuang, J., Manning, C. D., Ng, A., &amp; Potts, C. (2013, October). <a href="https://nlp.stanford.edu/~socherr/EMNLP2013_RNTN.pdf" target="_blank" rel="noopener">Recursive deep models for semantic compositionality over a sentiment treebank</a>. In <em>Proceedings of the 2013 conference on empirical methods in natural language processing</em> (pp. 1631–1642).</p><p>Subramanian, S., Trischler, A., Bengio, Y., &amp; Pal, C. J. (2018). <a href="https://arxiv.org/pdf/1804.00079.pdf" target="_blank" rel="noopener">Learning general purpose distributed sentence representations via large scale multi-task learning</a>. <em>arXiv preprint arXiv:1804.00079</em>.</p><p>Sutskever, I., Vinyals, O., &amp; Le, Q. V. (2014). <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">Sequence to sequence learning with neural networks</a>. In <em>Advances in neural information processing systems</em> (pp. 3104–3112).</p><p>Tang, S., Jin, H., Fang, C., Wang, Z., &amp; de Sa, V. R. (2017). <a href="https://arxiv.org/abs/1706.03146" target="_blank" rel="noopener">Rethinking skip-thought: A neighborhood based approach</a>. <em>arXiv preprint arXiv:1706.03146</em>.</p><p>Tang, S., Jin, H., Fang, C., Wang, Z., &amp; de Sa, V. R. (2017). <a href="https://www.groundai.com/project/trimming-and-improving-skip-thought-vectors/1" target="_blank" rel="noopener">Trimming and improving skip-thought vectors</a>. <em>arXiv preprint arXiv:1706.03148</em>.</p><p>Thongtan, T., &amp; Phienthrakul, T. (2019, July). Sentiment Classification using Document Embeddings trained with Cosine Similarity. In <em>Proceedings of the 57th Conference of the Association for Computational Linguistics: Student Research Workshop</em> (pp. 407–414).</p><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … &amp; Polosukhin, I. (2017). <a href="https://arxiv.org/pdf/1706.03762.pdf" target="_blank" rel="noopener">Attention is all you need</a>. <em>In Advances in neural information processing systems</em> (pp. 5998–6008).</p><p>Wieting, J., Bansal, M., Gimpel, K., &amp; Livescu, K. (2015). <a href="https://arxiv.org/pdf/1511.08198.pdf" target="_blank" rel="noopener">Towards universal paraphrastic sentence embeddings</a>. arXiv preprint arXiv:1511.08198.</p><p>Wieting, J., &amp; Gimpel, K. (2017). Revisiting recurrent networks for paraphrastic sentence embeddings. <em>arXiv preprint arXiv:1705.00364</em>.</p><p>Wu, L., Yen, I. E. H., Xu, F., Ravikumar, P., &amp; Witbrock, M. (2018). <a href="https://arxiv.org/pdf/1802.04956.pdf" target="_blank" rel="noopener">D2ke: From distance to kernel and embedding</a>. <em>arXiv preprint arXiv:1802.04956</em>.</p><p>Wu, L., Yen, I. E., Xu, K., Xu, F., Balakrishnan, A., Chen, P. Y., … &amp; Witbrock, M. J. (2018). <a href="https://arxiv.org/pdf/1811.01713v1.pdf" target="_blank" rel="noopener">Word Mover’s Embedding: From Word2Vec to Document Embedding</a>. <em>arXiv preprint arXiv:1811.01713</em>.</p><p>Yu, J., &amp; Jiang, J. (2016, November). <a href="https://www.semanticscholar.org/paper/Learning-Sentence-Embeddings-with-Auxiliary-Tasks-Yu-Jiang/2d38f7aab07d4435b2110602db4138ef20da4cc0" target="_blank" rel="noopener">Learning sentence embeddings with auxiliary tasks for cross-domain sentiment classification</a>. In <em>Proceedings of the 2016 conference on empirical methods in natural language processing</em> (pp. 236–246).</p><p>Zhang, Y., Chen, Q., Yang, Z., Lin, H., &amp; Lu, Z. (2019). BioWordVec, improving biomedical word embeddings with subword information and MeSH. <em>Scientific data</em>, <em>6</em>(1), 52.</p><p>Zhao, H., Lu, Z., &amp; Poupart, P. (2015, June). Self-adaptive hierarchical sentence model. In <em>Twenty-Fourth International Joint Conference on Artificial Intelligence</em>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[原文连接]&lt;a href=&quot;https://towardsdatascience.com/document-embedding-techniques-fed3e7a6a25d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://towardsd
      
    
    </summary>
    
    
      <category term="nlp" scheme="http://yoursite.com/categories/nlp/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://yoursite.com/2020/08/01/docker/"/>
    <id>http://yoursite.com/2020/08/01/docker/</id>
    <published>2020-08-01T01:57:15.000Z</published>
    <updated>2020-08-07T08:56:23.030Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://search.bilibili.com/video?keyword=elastic" target="_blank" rel="noopener">参考b站教程</a></p><h2 id="一、Docker-介绍"><a href="#一、Docker-介绍" class="headerlink" title="一、Docker 介绍"></a>一、Docker 介绍</h2><h3 id="1-安装需要的包"><a href="#1-安装需要的包" class="headerlink" title="1. 安装需要的包"></a>1. 安装需要的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">想安装Docker，需要先将依赖的环境全部下载下来</span></span><br><span class="line">sudo apt install apt-transport-https ca-certificates software-properties-common curl</span><br></pre></td></tr></table></figure><h3 id="2-指定-Docker-镜像源"><a href="#2-指定-Docker-镜像源" class="headerlink" title="2. 指定 Docker 镜像源"></a>2. 指定 Docker 镜像源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">.更换国内软件源，推荐中国科技大学的源，稳定速度快（可选）</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="3-添加-GPG-密钥"><a href="#3-添加-GPG-密钥" class="headerlink" title="3.添加 GPG 密钥"></a>3.添加 GPG 密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例</span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">$</span><span class="bash">(lsb_release -cs) stable<span class="string">"</span></span></span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><h3 id="4-启动-Docker-并测试"><a href="#4-启动-Docker-并测试" class="headerlink" title="4. 启动 Docker 并测试"></a>4. 启动 Docker 并测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker</span><br><span class="line"><span class="meta">#</span><span class="bash">启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机自动启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="二、Docker-的中央仓库"><a href="#二、Docker-的中央仓库" class="headerlink" title="二、Docker 的中央仓库"></a>二、Docker 的中央仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。</span><br><span class="line">https://hub.docker.com/</span><br><span class="line">2.国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。</span><br><span class="line">https://c.163yun.com/hub#/home </span><br><span class="line">http://hub.daocloud.io/ （推荐使用）</span><br><span class="line">3.在公司内部会采用私服的方式拉取镜像（添加配置）</span><br><span class="line"><span class="meta">#</span><span class="bash">需要创建 /etc/docker/daemon.json，并添加如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors":["https://registry.docker-cn.com"],</span><br><span class="line">"insecure-registries":["ip:port"]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">重启两个服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="三、镜像的操作"><a href="#三、镜像的操作" class="headerlink" title="三、镜像的操作"></a>三、镜像的操作</h2><h3 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从中央仓库拉取镜像到本地</span><br><span class="line">docker pull 镜像名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">举个栗子:docker pull daocloud.io/library/tomcat:8.5.15-jre8</span></span><br></pre></td></tr></table></figure><h3 id="2-查看本地全部镜像"><a href="#2-查看本地全部镜像" class="headerlink" title="2. 查看本地全部镜像"></a>2. 查看本地全部镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3. 删除本地镜像"></a>3. 删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取</span></span><br><span class="line">docker rmi 镜像的标识</span><br></pre></td></tr></table></figure><h3 id="4-镜像的导入导出"><a href="#4-镜像的导入导出" class="headerlink" title="4. 镜像的导入导出"></a>4. 镜像的导入导出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将本地的镜像导出</span></span><br><span class="line">docker save -o 导出的路径 镜像id</span><br><span class="line"><span class="meta">#</span><span class="bash">加载本地的镜像文件</span></span><br><span class="line">docker load -i 镜像文件</span><br><span class="line"><span class="meta">#</span><span class="bash">修改镜像文件</span></span><br><span class="line">docker tag 镜像id 新镜像名称：版本</span><br></pre></td></tr></table></figure><h2 id="四、容器的操作"><a href="#四、容器的操作" class="headerlink" title="四、容器的操作"></a>四、容器的操作</h2><h3 id="1-运行容器"><a href="#1-运行容器" class="headerlink" title="1. 运行容器"></a>1. 运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行容器需要定制具体镜像，如果镜像不存在，会直接下载</span><br><span class="line"><span class="meta">#</span><span class="bash">简单操作</span></span><br><span class="line">docker run 镜像的标识|镜像的名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">常用的参数</span></span><br><span class="line">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span><br><span class="line"><span class="meta">#</span><span class="bash">-d:代表后台运行容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--name 容器名称:指定容器的名称</span></span><br></pre></td></tr></table></figure><h3 id="2-查看正在运行的容器"><a href="#2-查看正在运行的容器" class="headerlink" title="2. 查看正在运行的容器"></a>2. 查看正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看全部正在运行的容器信息</span><br><span class="line">docker ps [-qa]</span><br><span class="line"><span class="meta">#</span><span class="bash">-a 查看全部的容器，包括没有运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-q 只查看容器的标识</span></span><br></pre></td></tr></table></figure><h3 id="3-查看容器日志"><a href="#3-查看容器日志" class="headerlink" title="3. 查看容器日志"></a>3. 查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看容器日志，以查看容器运行的信息</span><br><span class="line">docker logs -f 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">-f：可以滚动查看日志的最后几行</span></span><br></pre></td></tr></table></figure><h3 id="4-进入容器的内部"><a href="#4-进入容器的内部" class="headerlink" title="4. 进入容器的内部"></a>4. 进入容器的内部</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以进入容器的内部进行操作</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><h3 id="5-复制内容到容器"><a href="#5-复制内容到容器" class="headerlink" title="5. 复制内容到容器"></a>5. 复制内容到容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将宿主机的文件复制到容器内部的指定目录</span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br></pre></td></tr></table></figure><h3 id="6-重启-amp-启动-amp-停止-amp-删除容器"><a href="#6-重启-amp-启动-amp-停止-amp-删除容器" class="headerlink" title="6. 重启 &amp; 启动 &amp; 停止 &amp; 删除容器"></a>6. 重启 &amp; 启动 &amp; 停止 &amp; 删除容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">容器的启动，停止，删除等操作，后续会经常使用到</span><br><span class="line"><span class="meta">#</span><span class="bash">重新启动容器</span></span><br><span class="line">docker restart 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">启动停止运行的容器</span></span><br><span class="line">docker start 容器id</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">停止指定的容器(删除容器前，需要先停止容器)</span></span><br><span class="line">docker stop 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">停止全部容器</span></span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"><span class="meta">#</span><span class="bash">删除指定容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">删除全部容器</span></span><br><span class="line">docker rm $(docker ps -qa)</span><br></pre></td></tr></table></figure><h2 id="五、Docker-应用"><a href="#五、Docker-应用" class="headerlink" title="五、Docker 应用"></a>五、Docker 应用</h2><h3 id="1-docker-安装-tomcat"><a href="#1-docker-安装-tomcat" class="headerlink" title="1.docker 安装 tomcat"></a>1.docker 安装 tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行Tomcat容器，为部署ssm工程做准备</span><br><span class="line"> </span><br><span class="line">docker run -d -p 8080:8080 --name tomcat  daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line"><span class="meta">#</span><span class="bash">或者已经下载了tomcat镜像</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat 镜像的标识</span><br></pre></td></tr></table></figure><h3 id="2-运行-MySQL-容器"><a href="#2-运行-MySQL-容器" class="headerlink" title="2. 运行 MySQL 容器"></a>2. 运行 MySQL 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4</span><br></pre></td></tr></table></figure><h3 id="3-部署-ssm-工程"><a href="#3-部署-ssm-工程" class="headerlink" title="3. 部署 ssm 工程"></a>3. 部署 ssm 工程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改SSM工程环境，设置为Linux中Docker容器的信息</span><br><span class="line">通过Maven的package重新打成war包</span><br><span class="line">将Windows下的war包复制到Linux中</span><br><span class="line">通过docker命令将宿主机的war包复制到容器内部</span><br><span class="line">docker cp 文件名称 容器id:容器内部路径</span><br><span class="line">测试访问SSM工程</span><br></pre></td></tr></table></figure><h3 id="六、数据卷"><a href="#六、数据卷" class="headerlink" title="六、数据卷"></a>六、数据卷</h3><p>为了部署 SSM 的工程，需要使用到 cp 的命令将宿主机内的 ssm.war 文件复制到容器内部。</p><p>数据卷：将宿主机的一个目录映射到容器的一个目录中。</p><p>可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。  </p><h3 id="1-创建数据卷"><a href="#1-创建数据卷" class="headerlink" title="1. 创建数据卷"></a>1. 创建数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</span></span><br><span class="line">docker volume create 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="2-查看全部数据卷"><a href="#2-查看全部数据卷" class="headerlink" title="2. 查看全部数据卷"></a>2. 查看全部数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看全部数据卷信息</span></span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><h3 id="3-查看数据卷详情"><a href="#3-查看数据卷详情" class="headerlink" title="3. 查看数据卷详情"></a>3. 查看数据卷详情</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</span></span><br><span class="line">docker volume inspect 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="4-删除数据卷"><a href="#4-删除数据卷" class="headerlink" title="4. 删除数据卷"></a>4. 删除数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除指定的数据卷</span></span><br><span class="line">docker volume rm 数据卷名称</span><br></pre></td></tr></table></figure><h3 id="5-容器映射数据卷"><a href="#5-容器映射数据卷" class="headerlink" title="5. 容器映射数据卷"></a>5. 容器映射数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat -v 数据卷名称:容器内部的路径 镜像id</span><br><span class="line"> </span><br><span class="line"><span class="comment">#通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</span></span><br><span class="line">docker run -d -p 8080:8080 --name tomcat -v 路径(/root/自己创建的文件夹):容器内部的路径 镜像id</span><br></pre></td></tr></table></figure><h2 id="七、Dockerfile-自定义镜像"><a href="#七、Dockerfile-自定义镜像" class="headerlink" title="七、Dockerfile 自定义镜像"></a>七、Dockerfile 自定义镜像</h2><h3 id="1-Dockerfile"><a href="#1-Dockerfile" class="headerlink" title="1.Dockerfile"></a>1.Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建自定义镜像就需要创建一个Dockerfiler,如下为Dockerfile的语言</span><br><span class="line"> </span><br><span class="line">from：指定当前自定义镜像依赖的环境</span><br><span class="line">copy：将相对路径下的内容复制到自定义镜像中</span><br><span class="line">workdir：声明镜像的默认工作目录</span><br><span class="line">run：执行的命令，可以编写多个</span><br><span class="line">cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">示例：</span></span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="2-通过-Dockerfile-制作镜像"><a href="#2-通过-Dockerfile-制作镜像" class="headerlink" title="2. 通过 Dockerfile 制作镜像"></a>2. 通过 Dockerfile 制作镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编写完Dockerfile后需要通过命令将其制作为镜像，并且要在Dockerfile的当前目录下，之后即可在镜像中查看到指定的镜像信息，注意最后的 .</span></span><br><span class="line">docker build -t 镜像名称[:tag] ./</span><br></pre></td></tr></table></figure><h2 id="八、Docker-Compose"><a href="#八、Docker-Compose" class="headerlink" title="八、Docker-Compose"></a>八、Docker-Compose</h2><h3 id="1-下载并安装-Docker-Compose"><a href="#1-下载并安装-Docker-Compose" class="headerlink" title="1. 下载并安装 Docker-Compose"></a>1. 下载并安装 Docker-Compose</h3><h3 id="1-1-下载-Docker-Compose"><a href="#1-1-下载-Docker-Compose" class="headerlink" title="1.1 下载 Docker-Compose"></a>1.1 下载 Docker-Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">去github官网搜索docker-compose，下载1.24.1版本的Docker-Compose</span></span><br><span class="line">下载路径：https://github.com/docker/compose/releases/download/1.24.1/docker-compose-Linux-x86_64</span><br></pre></td></tr></table></figure><h3 id="1-2-设置权限"><a href="#1-2-设置权限" class="headerlink" title="1.2 设置权限"></a>1.2 设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#需要将DockerCompose文件的名称修改一下，给予DockerCompose文件一个可执行的权限</span><br><span class="line">mv docker-compose-Linux-x86_64 docker-compose</span><br><span class="line">chmod 777 docker-compose</span><br></pre></td></tr></table></figure><h3 id="1-3-配置环境变量"><a href="#1-3-配置环境变量" class="headerlink" title="1.3 配置环境变量"></a>1.3 配置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">方便后期操作，配置一个环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将docker-compose文件移动到了/usr/<span class="built_in">local</span>/bin，修改了/etc/profile文件，给/usr/<span class="built_in">local</span>/bin配置到了PATH中</span></span><br><span class="line"> </span><br><span class="line">mv docker-compose /usr/local/bin</span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">添加内容：<span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>:/usr/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在任意目录下输入docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-Docker-Compose-管理-MySQL-和-Tomcat-容器"><a href="#2-Docker-Compose-管理-MySQL-和-Tomcat-容器" class="headerlink" title="2.Docker-Compose 管理 MySQL 和 Tomcat 容器"></a>2.Docker-Compose 管理 MySQL 和 Tomcat 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">yml文件以key:value方式来指定配置信息</span><br><span class="line">多个配置信息以换行+缩进的方式来区分</span><br><span class="line">在docker-compose.yml文件中，不要使用制表符</span><br><span class="line"> </span><br><span class="line">version: '3.1'</span><br><span class="line">services:</span><br><span class="line">  mysql:           # 服务的名称</span><br><span class="line">    restart: always   # 代表只要docker启动，那么这个容器就跟着一起启动</span><br><span class="line">    image: daocloud.io/library/mysql:5.7.4  # 指定镜像路径</span><br><span class="line">    container_name: mysql  # 指定容器名称</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306   #  指定端口号的映射</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root   # 指定MySQL的ROOT用户登录密码</span><br><span class="line">      TZ: Asia/Shanghai        # 指定时区</span><br><span class="line">    volumes:</span><br><span class="line">     - /opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql   # 映射数据卷</span><br><span class="line">  tomcat:</span><br><span class="line">    restart: always</span><br><span class="line">    image: daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">    container_name: tomcat</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span><br></pre></td></tr></table></figure><h3 id="3-使用-docker-compose-命令管理容器"><a href="#3-使用-docker-compose-命令管理容器" class="headerlink" title="3. 使用 docker-compose 命令管理容器"></a>3. 使用 docker-compose 命令管理容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">1.基于docker-compose.yml启动管理的容器</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2.关闭并删除容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">3.开启|关闭|重启已经存在的由docker-compose维护的容器</span></span><br><span class="line">docker-compose start|stop|restart</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">4.查看由docker-compose管理的容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">5.查看日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h3 id="4-docker-compose-配合-Dockerfile-使用"><a href="#4-docker-compose-配合-Dockerfile-使用" class="headerlink" title="4.docker-compose 配合 Dockerfile 使用"></a>4.docker-compose 配合 Dockerfile 使用</h3><p>使用 docker-compose.yml 文件以及 Dockerfile 文件在生成自定义镜像的同时启动当前镜像，并且由 docker-compose 去管理容器  </p><h3 id="4-1docker-compose-文件"><a href="#4-1docker-compose-文件" class="headerlink" title="4.1docker-compose 文件"></a>4.1docker-compose 文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">编写docker-compose文件</span><br><span class="line"> </span><br><span class="line"><span class="comment"># yml文件</span></span><br><span class="line">version: <span class="string">'3.1'</span></span><br><span class="line">services:</span><br><span class="line">  ssm:</span><br><span class="line">    restart: always</span><br><span class="line">    build:            <span class="comment"># 构建自定义镜像</span></span><br><span class="line">      context: ../      <span class="comment"># 指定dockerfile文件的所在路径</span></span><br><span class="line">      dockerfile: Dockerfile   <span class="comment"># 指定Dockerfile文件名称</span></span><br><span class="line">    image: ssm:1.0.1</span><br><span class="line">    container_name: ssm</span><br><span class="line">    ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br></pre></td></tr></table></figure><h3 id="4-2-Dockerfile-文件"><a href="#4-2-Dockerfile-文件" class="headerlink" title="4.2 Dockerfile 文件"></a>4.2 Dockerfile 文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编写Dockerfile文件</span><br><span class="line"> </span><br><span class="line">from daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">copy ssm.war /usr/<span class="built_in">local</span>/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="4-3-运行"><a href="#4-3-运行" class="headerlink" title="4.3 运行"></a>4.3 运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以直接基于docker-compose.yml以及Dockerfile文件构建的自定义镜像</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像</span></span><br><span class="line"><span class="comment">#重新构建自定义镜像</span></span><br><span class="line">docker-compose build</span><br><span class="line"><span class="comment">#运行当前内容，并重新构建</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure><h2 id="九、CI、CD-介绍及准备"><a href="#九、CI、CD-介绍及准备" class="headerlink" title="九、CI、CD 介绍及准备"></a>九、CI、CD 介绍及准备</h2><h3 id="1-CI、CD-引言"><a href="#1-CI、CD-引言" class="headerlink" title="1.CI、CD 引言"></a>1.CI、CD 引言</h3><p>项目部署  </p><ol><li>将项目通过 maven 进行编译打包  </li><li>将文件上传到指定的服务器中  </li><li>将 war 包放到 tomcat 的目录中  </li><li>通过 Dockerfile 将 Tomcat 和 war 包转成一个镜像，由 DockerCompose 去运行容器<br>项目更新后，需要将上述流程再次的从头到尾的执行一次，如果每次更新一次都执行一次上述操作，很费时，费力。我们就可以通过 CI、CD 帮助我们实现持续集成，持续交付和部署  </li></ol><h3 id="2-CI-介绍"><a href="#2-CI-介绍" class="headerlink" title="2.CI 介绍"></a>2.CI 介绍</h3><p>CI（continuous intergration）持续集成<br>持续集成：编写代码时，完成了一个功能后，立即提交代码到 Git 仓库中，将项目重新的构建并且测试。</p><ol><li>快速发现错误。  </li><li>防止代码偏离主分支。  </li></ol><h3 id="3-搭建-Gitlab-服务器"><a href="#3-搭建-Gitlab-服务器" class="headerlink" title="3. 搭建 Gitlab 服务器"></a>3. 搭建 Gitlab 服务器</h3><h3 id="3-1-准备环境"><a href="#3-1-准备环境" class="headerlink" title="3.1. 准备环境"></a>3.1. 准备环境</h3><p>实现 CI，需要使用到 Gitlab 远程仓库，先通过 Docker 搭建 Gitlab<br>创建一个全新的虚拟机，并且至少指定 4G 的运行内存，4G 运行内存是 Gitlab 推荐的内存大小。<br>并且安装 Docker 以及 Docker-Compose  </p><h3 id="3-2-修改-ssh-的-22-端口"><a href="#3-2-修改-ssh-的-22-端口" class="headerlink" title="3.2 修改 ssh 的 22 端口"></a>3.2 修改 ssh 的 22 端口</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将ssh的默认22端口，修改为60022端口，因为Gitlab需要占用22端口</span></span><br><span class="line"> </span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">  PORT 22 -&gt; 60022</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h3 id="3-3-编写-docker-compose-yml"><a href="#3-3-编写-docker-compose-yml" class="headerlink" title="3.3 编写 docker-compose.yml"></a>3.3 编写 docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker-compose.yml文件去安装gitlab（下载和运行的时间比较长的）</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">version:</span> <span class="string">'3.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">gitlab:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">'twang2218/gitlab-ce-zh:11.1.4'</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">"gitlab"</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">'gitlab'</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">   <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">   <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">external_url</span> <span class="string">'http://xxx.xxx.xxx.xxx'</span></span><br><span class="line">    <span class="string">gitlab_rails['time_zone']</span> <span class="string">=</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">    <span class="string">gitlab_rails['smtp_enable']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">22</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">'22:22'</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/config:/etc/gitlab</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/data:/var/opt/gitlab</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">/opt/docker_gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><h2 id="十、搭建-GitlabRunner"><a href="#十、搭建-GitlabRunner" class="headerlink" title="十、搭建 GitlabRunner"></a>十、搭建 GitlabRunner</h2><h3 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1. 准备文件"></a>1. 准备文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemon.json</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">“registry-mirrors”: [“https://registry.docker-cn.com”],</span><br><span class="line">“insecure-registries”: [ip:ports]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">文件夹 environment里面准备maven安装包，jdk1.8安装包，Dockerfile，daemon.json以及docker-compose</span><br></pre></td></tr></table></figure><h3 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2. 开始搭建"></a>2. 开始搭建</h3><p>创建工作目录 /usr/local/docker_gitlab-runner<br>将 docker-compose.yml 文件以及 environment 目录全部复制到上述目录中<br>在宿主机启动 docker 程序后先执行 sudo chown root:root /var/run/docker.sock (如果重启过 docker, 重新执行)<br>在 / usr/local/docker_gitlab-runner 目录中执行 docker-compose up -d –build 启动容器<br>添加容器权限，保证容器可以使用宿主机的 dockerdocker exec -it gitlab-runner usermod -aG root gitlab-runner<br>注册 Runner 信息到 gitlab  </p><h3 id="3-进入后续步骤"><a href="#3-进入后续步骤" class="headerlink" title="3. 进入后续步骤"></a>3. 进入后续步骤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab-runner gitlab-runner register</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 GitLab 地址</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):</span><br><span class="line">http://192.168.199.109/</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 GitLab Token</span></span><br><span class="line">Please enter the gitlab-ci token for this runner:</span><br><span class="line">1Lxq_f1NRfCfeNbE5WRh</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 Runner 的说明</span></span><br><span class="line">Please enter the gitlab-ci description for this runner:</span><br><span class="line">可以为空</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span></span><br><span class="line">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class="line">deploy</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里选择 <span class="literal">true</span> ，可以用于代码上传后直接执行（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to run untagged builds [true/false]:</span><br><span class="line">true</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里选择 <span class="literal">false</span>，可以直接回车，默认为 <span class="literal">false</span>（根据版本，也会没有次选项）</span></span><br><span class="line">Whether to lock Runner to current project [true/false]:</span><br><span class="line">false</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择 runner 执行器，这里我们选择的是 shell</span></span><br><span class="line">Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><h2 id="十一、整合项目入门测试"><a href="#十一、整合项目入门测试" class="headerlink" title="十一、整合项目入门测试"></a>十一、整合项目入门测试</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>创建 maven 工程，添加 web.xml 文件，编写 HTML 页面  </p><h3 id="2-编写-gitlab-ci-yml-文件"><a href="#2-编写-gitlab-ci-yml-文件" class="headerlink" title="2. 编写. gitlab-ci.yml 文件"></a>2. 编写. gitlab-ci.yml 文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">first</span> <span class="string">test</span> <span class="string">ci</span>   <span class="comment"># 输入的命令</span></span><br></pre></td></tr></table></figure><h3 id="3-将-maven-工程推送到-gitlab-中"><a href="#3-将-maven-工程推送到-gitlab-中" class="headerlink" title="3. 将 maven 工程推送到 gitlab 中"></a>3. 将 maven 工程推送到 gitlab 中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行git命令推送到Gitlab</span><br><span class="line"> </span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="4-查看效果"><a href="#4-查看效果" class="headerlink" title="4. 查看效果"></a>4. 查看效果</h3><p>可以在 gitlab 中查看到 gitlab-ci.yml 编写的内容  </p><h2 id="十二、完善项目配置"><a href="#十二、完善项目配置" class="headerlink" title="十二、完善项目配置"></a>十二、完善项目配置</h2><p>添加 Dockerfile 以及 docker-compose.yml， 并修改. gitlab-ci.yml 文件  </p><h3 id="1-创建-Dockerfile"><a href="#1-创建-Dockerfile" class="headerlink" title="1. 创建 Dockerfile"></a>1. 创建 Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile</span></span><br><span class="line">FROM daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">COPY testci.war /usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><h3 id="2-创建-docker-compose-yml"><a href="#2-创建-docker-compose-yml" class="headerlink" title="2. 创建 docker-compose.yml"></a>2. 创建 docker-compose.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">testci:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">docker</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">testci</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure><h3 id="3-修改-gitlab-ci-yml"><a href="#3-修改-gitlab-ci-yml" class="headerlink" title="3. 修改. gitlab-ci.yml"></a>3. 修改. gitlab-ci.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ci.yml</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">first</span> <span class="string">test</span> <span class="string">ci</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/usr/local/maven/apache-maven-3.6.3/bin/mvn</span> <span class="string">package</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">target/testci-1.0-SNAPSHOT.war</span> <span class="string">docker/testci.war</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">down</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span> <span class="string">--build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rmi</span> <span class="string">$(docker</span> <span class="string">images</span> <span class="string">-qf</span> <span class="string">dangling=true)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://search.bilibili.com/video?keyword=elastic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考b站教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、Docker-介绍&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ElasticSearch</title>
    <link href="http://yoursite.com/2020/07/12/ES/"/>
    <id>http://yoursite.com/2020/07/12/ES/</id>
    <published>2020-07-12T13:44:15.000Z</published>
    <updated>2020-08-08T06:47:43.110Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1Qz411e7yx?t=269&amp;p=5" target="_blank" rel="noopener">参考</a></p><h1 id="ES简介"><a href="#ES简介" class="headerlink" title="ES简介"></a>ES简介</h1><p>ES是使用java 语言并且基于lucence编写的搜索引擎框架，他提供了分布式的全文搜索功能，提供了一个统一的基于restful风格的web 接口。</p><p>lucence:一个搜索引擎底层</p><p>分布式：突出ES的横向扩展能力</p><p>全文检索：将一段词语进行分词，并将分出的词语统一的放在一个分词库中，再搜索时，根据关键字取分词库中检索，找到匹配的内容（倒排索引）。</p><p>restful风格的web 接口：只要发送一个http请求，并且根据请求方式的不同，携带参数的不同，执行相应的功能。</p><p>应用广泛：WIKI, github,Gold man</p><h2 id="ES的由来"><a href="#ES的由来" class="headerlink" title="ES的由来"></a>ES的由来</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。</span><br><span class="line"></span><br><span class="line">直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。</span><br><span class="line"></span><br><span class="line">后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。</span><br><span class="line"></span><br><span class="line">第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。</span><br><span class="line"></span><br><span class="line">据说，Shay 的妻子还在等着她的食谱搜索引擎…</span><br></pre></td></tr></table></figure><h2 id="ES和solr"><a href="#ES和solr" class="headerlink" title="ES和solr"></a>ES和solr</h2><p>1.solr 查询死数据，速度比es快。但是数据如果是改变的，solr查询速度会降低很多，ES的查询速度没有明显的改变</p><p>2.solr搭建集群 依赖ZK，ES本身就支持集群搭建</p><p>3.最开始solr 的社区很火爆，针对国内文档 少，ES出现后，国内社区火爆程度 上升，，ES的文档非常健全</p><p>4.ES对云计算和大数据支持很好</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><img src="image-20200727144457339.png" alt="image"></p><p>1.将存放的数据以一定的方式进行分词，并将分词的内容存放到一个单独的分词库中。</p><p>2.当用户取查询数据时，会将用户的查询关键字进行分词，然后去分词库中匹配内容，最终得到数据的id标识</p><p>3.根据id标识去存放数据的位置拉去指定数据</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="elasticsearch-安装"><a href="#elasticsearch-安装" class="headerlink" title="elasticsearch 安装"></a>elasticsearch 安装</h2><p><a href="http://hub.daocloud.io/" target="_blank" rel="noopener">http://hub.daocloud.io/</a>    docker 镜像工厂地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elasticsearch:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/elasticsearch:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">   <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">daocloud.io/library/kibana:6.5.4</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">5601</span><span class="string">:5601</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch_url=10.1.XX.XX:9200</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br></pre></td></tr></table></figure><p>或者本地下载</p><p>2.2</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官方给的安装的办法</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip</span><br></pre></td></tr></table></figure><p>本地自己安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.8.10.zip </span><br><span class="line">下载好后，</span><br><span class="line">执行 mvn clean package  打包（注意pom文件中的es的版本，如果和自己的es的版本不一致，手动改下）</span><br><span class="line">elasticsearch-analysis-ik-6.8.10\target\releases  中压缩包的内容copy到 elasticsearch-6.8.10\plugins\ik 下</span><br></pre></td></tr></table></figure><p>kibana 主要用到 Dev Tools   和 Management</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES的基本操作"><a href="#ES的基本操作" class="headerlink" title="ES的基本操作"></a>ES的基本操作</h1><h2 id="es的结构"><a href="#es的结构" class="headerlink" title="es的结构"></a>es的结构</h2><h3 id="索引indx，分片，备份"><a href="#索引indx，分片，备份" class="headerlink" title="索引indx，分片，备份"></a>索引indx，分片，备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES服务中会创建多个索引</span><br><span class="line">每个缩影默认被分成5个分片</span><br><span class="line">每个分片存在至少一个备份分片</span><br><span class="line">备份分片 不会帮助检索数据（当ES检索压力特别大的时候才，备份分片才会帮助检索数据）</span><br><span class="line">备份的分片必须放在不同的服务器中</span><br></pre></td></tr></table></figure><p><img src="image-20200727174836230.png" alt="png"></p><h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个索引下可以创建多个类型</span><br><span class="line">PS:版本不同,类型的创建也不同</span><br></pre></td></tr></table></figure><p><img src="image-20200727175427524.png" alt="png"></p><h3 id="文档document"><a href="#文档document" class="headerlink" title="文档document"></a>文档document</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个类型下可以有多个文档，这个文档就相当于mysql表中的多行数据</span><br></pre></td></tr></table></figure><p><img src="image-20200727175655572.png" alt="png"></p><p>3.1.4 属性field</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个文档中可以包含多个属性，类似于mysql 表中的一行数据有多个列</span><br></pre></td></tr></table></figure><p><img src="ES笔记.assets/image-20200727180642583.png" alt="image-20200727180642583"></p><h2 id="操作ES的restful语法"><a href="#操作ES的restful语法" class="headerlink" title="操作ES的restful语法"></a>操作ES的restful语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET请求：</span><br><span class="line">http://ip:port/index :查询索引信息</span><br><span class="line">http://ip:port/index/type/doc_id :查询指定的文档信息</span><br><span class="line">POST请求：</span><br><span class="line">    http://ip:port/index/type/_search: 查询文档，可以在请求体中添加json字符串来代表查询条件</span><br><span class="line">    http://ip:port/index/type/doc_id/_update: 修改文档，在请求体中添加json字符串来代表修改的信息</span><br><span class="line">PUT请求：</span><br><span class="line">    http://ip:port/index : 创建一个索引，需要在请求体中指定索引的信息</span><br><span class="line">    http://ip:port/index/type/_mappings:代表创建索引时，指定索引文档存储属性的信息</span><br><span class="line">DELETE 请求：</span><br><span class="line">    http://ip:port/index： 删除跑路</span><br><span class="line">    http://ip:port/index/type/doc_id:  删除指定的文档</span><br></pre></td></tr></table></figure><h2 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h2><h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建一个索引</span><br><span class="line">#number_of_shards  分片</span><br><span class="line">#number_of_replicas 备份</span><br><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>, </span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看一个索引"><a href="#查看一个索引" class="headerlink" title="查看一个索引"></a>查看一个索引</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.management</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">#查看索引信息</span><br><span class="line">GET /person</span><br></pre></td></tr></table></figure><h3 id="删除-索引"><a href="#删除-索引" class="headerlink" title="删除 索引"></a>删除 索引</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.management</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">#删除索引</span><br><span class="line">DELETE /person</span><br></pre></td></tr></table></figure><h2 id="ES中Field可以指定的类型"><a href="#ES中Field可以指定的类型" class="headerlink" title="ES中Field可以指定的类型"></a>ES中Field可以指定的类型</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.8/mapping-types.html</a>  官方 文档</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">字符串类型:</span><br><span class="line">  text: 一般用于全文检索，将当前field 进行分词</span><br><span class="line">  keyword:当前field  不会进行分词</span><br><span class="line">数值类型：</span><br><span class="line">  long:</span><br><span class="line">  Intger:</span><br><span class="line">  short:</span><br><span class="line">  byte:</span><br><span class="line">  double:</span><br><span class="line">  float:</span><br><span class="line">  half_float: 精度比float 小一半</span><br><span class="line">  scaled_float:根据一个long 和scaled 来表达一个浮点型 long-345, -scaled 100 -&gt;3.45</span><br><span class="line">时间类型：</span><br><span class="line">  date类型,根据时间类型指定具体的格式</span><br><span class="line">    PUT my_index</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_doc"</span>: &#123;</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"date"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:   <span class="string">"date"</span>,</span><br><span class="line">              <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">布尔类型：</span><br><span class="line">  boolean 类型，表达true 和false</span><br><span class="line">二进制类型：</span><br><span class="line">  binary类型暂时支持Base64编码的字符串</span><br><span class="line">范围类型：</span><br><span class="line">  integer_range：</span><br><span class="line">  float_range：</span><br><span class="line">  long_range：赋值时，无需指定具体的内容，只需存储一个范围即可，gte,lte,gt,lt,</span><br><span class="line">  double_range：</span><br><span class="line">  date_range：</span><br><span class="line">  ip_range：</span><br><span class="line"></span><br><span class="line">    PUT range_index</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_doc"</span>: &#123;</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"expected_attendees"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"integer_range"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"time_frame"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"date_range"</span>, </span><br><span class="line">              <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT range_index/_doc/1?refresh</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"expected_attendees"</span> : &#123; </span><br><span class="line">        <span class="attr">"gte"</span> : <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"lte"</span> : <span class="number">20</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"time_frame"</span> : &#123; </span><br><span class="line">        <span class="attr">"gte"</span> : <span class="string">"2015-10-31 12:00:00"</span>, </span><br><span class="line">        <span class="attr">"lte"</span> : <span class="string">"2015-11-01"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">经纬度类型：</span><br><span class="line">  geo_point:用来存储经纬度</span><br><span class="line">IP类型：</span><br><span class="line">  ip:可以存储IPV4 和IPV6</span><br><span class="line">其他的数据类型，参考官网</span><br></pre></td></tr></table></figure><h2 id="创建索引并指定数据结构"><a href="#创建索引并指定数据结构" class="headerlink" title="创建索引并指定数据结构"></a>创建索引并指定数据结构</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#创建索引，指定数据类型</span><br><span class="line">PUT /book</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    #分片数</span><br><span class="line">    "number_of_shards": 5,</span><br><span class="line">    #备份数</span><br><span class="line">    "number_of_replicas": 1</span><br><span class="line">  &#125;,</span><br><span class="line">    #指定数据类型</span><br><span class="line"> "mappings": &#123;</span><br><span class="line">    #类型 Type</span><br><span class="line">   "novel":&#123;</span><br><span class="line">    #文档存储的field</span><br><span class="line">     "properties":&#123;</span><br><span class="line">       #field属性名</span><br><span class="line">       "name":&#123;</span><br><span class="line">         #类型</span><br><span class="line">         "type":"text",</span><br><span class="line">         #指定分词器</span><br><span class="line">         "analyzer":"ik_max_word",</span><br><span class="line">         #指定当前的field可以被作为查询的条件</span><br><span class="line">         "index":true,</span><br><span class="line">         #是否需要额外存储</span><br><span class="line">         "store":false</span><br><span class="line">       &#125;,</span><br><span class="line">       "author":&#123;</span><br><span class="line">         "type":"keyword"</span><br><span class="line">       &#125;,</span><br><span class="line">       "count":&#123;</span><br><span class="line">         "type":"long"</span><br><span class="line">       &#125;,</span><br><span class="line">       "on-sale":&#123;</span><br><span class="line">         "type":"date",</span><br><span class="line">           #指定时间类型的格式化方式</span><br><span class="line">         "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"</span><br><span class="line">       &#125;,</span><br><span class="line">        "descr":&#123;</span><br><span class="line">          "type":"text",</span><br><span class="line">          "analyzer":"ik_max_word"</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文档在ES服务中的唯一标识， _indx ,_type,_id  三个内容为组合，锁定一个文档，操作时添加还时修改操作，</span><br></pre></td></tr></table></figure><h3 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">自动生成id</span><br><span class="line">#添加文档，自动生成id</span><br><span class="line">POST /book/novel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"盘龙"</span>,</span><br><span class="line">  <span class="attr">"author"</span>:<span class="string">"我吃西红柿"</span>,</span><br><span class="line">  <span class="attr">"count"</span>:<span class="number">100000</span>,</span><br><span class="line">  <span class="attr">"on-sale"</span>:<span class="string">"2001-01-01"</span>,</span><br><span class="line">  <span class="attr">"descr"</span>:<span class="string">"大小的血睛鬃毛狮，力大无穷的紫睛金毛猿，毁天灭地的九头蛇皇，携带着毁灭雷电的恐怖雷龙……这里无奇不有，这是一个广博的魔幻世界。强者可以站在黑色巨龙的头顶遨游天际，恐怖的魔法可以焚烧江河，可以毁灭城池，可以夷平山岳……"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#添加文档,手动指定id</span><br><span class="line">PUT /book/novel/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"红楼梦"</span>,</span><br><span class="line">  <span class="attr">"author"</span>:<span class="string">"曹雪芹"</span>,</span><br><span class="line">  <span class="attr">"count"</span>:<span class="number">10000000</span>,</span><br><span class="line">  <span class="attr">"on-sale"</span>:<span class="string">"2501-01-01"</span>,</span><br><span class="line">  <span class="attr">"descr"</span>:<span class="string">"中国古代章回体长篇小说，中国古典四大名著之一，一般认为是清代作家曹雪芹所著。小说以贾、史、王、薛四大家族的兴衰为背景，以富贵公子贾宝玉为视角，以贾宝玉与林黛玉、薛宝钗的爱情婚姻悲剧为主线，描绘了一批举止见识出于须眉之上的闺阁佳人的人生百态，展现了真正的人性美和悲剧美"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><p>1.覆盖式修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#添加文档,手动指定id</span><br><span class="line">PUT /book/novel/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;红楼梦&quot;,</span><br><span class="line">  &quot;author&quot;:&quot;曹雪芹&quot;,</span><br><span class="line">  &quot;count&quot;:1000444,</span><br><span class="line">  &quot;on-sale&quot;:&quot;2501-01-01&quot;,</span><br><span class="line">  &quot;descr&quot;:&quot;中国古代章回体长篇小说，中国古典四大名著之一，一般认为是清代作家曹雪芹所著。小说以贾、史、王、薛四大家族的兴衰为背景，以富贵公子贾宝玉为视角，以贾宝玉与林黛玉、薛宝钗的爱情婚姻悲剧为主线，描绘了一批举止见识出于须眉之上的闺阁佳人的人生百态，展现了真正的人性美和悲剧美&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用doc修改方式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#修改文档，使用doc 方式</span><br><span class="line">POST /book/novel/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span>:&#123;</span><br><span class="line">      #指定需要修改的field和对应的值</span><br><span class="line">    "count":566666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#根据id删除文档</span><br><span class="line">DELETE /book/novel/3mEnk3MBaSKoGN4T2olw</span><br></pre></td></tr></table></figure><h1 id="Java-操作ElasticSearch"><a href="#Java-操作ElasticSearch" class="headerlink" title="Java 操作ElasticSearch"></a>Java 操作ElasticSearch</h1><h2 id="Java-连接ES"><a href="#Java-连接ES" class="headerlink" title="Java 连接ES"></a>Java 连接ES</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">创建maven工程</span><br><span class="line">导入依赖</span><br><span class="line"><span class="comment">&lt;!--        1.elasticsearch--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        2.elasticsearch 高级API--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        3.junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        4.lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建client链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestHighLevelClient <span class="title">getClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//  创建 HttpHost</span></span><br><span class="line">        HttpHost httpHost = <span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>,<span class="number">9200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RestClientBuilder</span></span><br><span class="line">        RestClientBuilder builder = RestClient.builder(httpHost);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 RestHighLevelClient</span></span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备关于索引的setting</span></span><br><span class="line">        Settings.Builder settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                .put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.准备关于索引的mapping</span></span><br><span class="line">        XContentBuilder mappings = JsonXContent.contentBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                    .startObject(<span class="string">"properties"</span>)</span><br><span class="line">                        .startObject(<span class="string">"name"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"age"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"birthday"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                    .endObject()</span><br><span class="line">                .endObject();</span><br><span class="line">        <span class="comment">// 3.将settings和mappings 封装到到一个Request对象中</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(index)</span><br><span class="line">                .settings(settings)</span><br><span class="line">                .mapping(type,mappings);</span><br><span class="line">        <span class="comment">// 4.使用client 去连接ES</span></span><br><span class="line">        CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"response:"</span>+response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查索引是否存在，删除索引"><a href="#检查索引是否存在，删除索引" class="headerlink" title="检查索引是否存在，删除索引"></a>检查索引是否存在，删除索引</h2><h3 id="检查索引存在"><a href="#检查索引存在" class="headerlink" title="检查索引存在"></a>检查索引存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">existTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1.准备request 对象</span></span><br><span class="line">        GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过client 去 操作</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 3输出结果</span></span><br><span class="line">        System.out.println(exists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.EsClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.support.master.AcknowledgedResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RequestOptions;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.indices.GetIndexRequest;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.json.JsonXContent;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取request</span></span><br><span class="line"></span><br><span class="line">        DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.使用client 操作request</span></span><br><span class="line">        AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//  3.输出结果</span></span><br><span class="line">        System.out.println(delete.isAcknowledged());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java操作文档"><a href="#Java操作文档" class="headerlink" title="Java操作文档"></a>Java操作文档</h2><h3 id="添加文档操作"><a href="#添加文档操作" class="headerlink" title="添加文档操作"></a>添加文档操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDocTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  1.准备一个json数据</span></span><br><span class="line">        Person person  = <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">33</span>,<span class="keyword">new</span> Date());</span><br><span class="line">        String json = mapper.writeValueAsString(person);</span><br><span class="line">        <span class="comment">//  2.创建一个request对象(手动指定的方式创建)</span></span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(index,type,person.getId().toString());</span><br><span class="line">        request.source(json, XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.使用client 操作request对象生成doc</span></span><br><span class="line">        IndexResponse response = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出返回结果</span></span><br><span class="line">        System.out.println(response.getResult().toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = &quot;person&quot;;</span><br><span class="line">    String type=&quot;man&quot;;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void updateDocTest() throws Exception&#123;</span><br><span class="line">        // 1.创建要跟新的Map</span><br><span class="line">        Map&lt;String,Object&gt;  doc = new HashMap&lt;&gt;();</span><br><span class="line">        doc.put(&quot;name&quot;,&quot;张三三&quot;);</span><br><span class="line"></span><br><span class="line">        // 2.创建request, 将doc 封装进去</span><br><span class="line">        UpdateRequest request = new UpdateRequest(index,type,&quot;1&quot;);</span><br><span class="line">        request.doc(doc);</span><br><span class="line"></span><br><span class="line">        // 3. client 去操作 request</span><br><span class="line">        UpdateResponse response = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">        // 4.输出 更新结果</span><br><span class="line">        System.out.println(response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;</span><br><span class="line">    String type=<span class="string">"man"</span>;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDocTest</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">//  1.封装删除对象</span></span><br><span class="line">        DeleteRequest request = <span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2 client 操作 request对象</span></span><br><span class="line">        DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//  3.输出结果</span></span><br><span class="line">        System.out.println(response.getResult().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java批量操作文档"><a href="#java批量操作文档" class="headerlink" title="java批量操作文档"></a>java批量操作文档</h2><p>批量操作 新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">      <span class="comment">// 1.准备多个json 对象</span></span><br><span class="line">      Person p1 = <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">23</span>,<span class="keyword">new</span> Date());</span><br><span class="line">      Person p2 = <span class="keyword">new</span> Person(<span class="number">2</span>,<span class="string">"里斯"</span>,<span class="number">24</span>,<span class="keyword">new</span> Date());</span><br><span class="line">      Person p3 = <span class="keyword">new</span> Person(<span class="number">3</span>,<span class="string">"王武"</span>,<span class="number">24</span>,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">      String json1  = mapper.writeValueAsString(p1);</span><br><span class="line">      String json2  = mapper.writeValueAsString(p2);</span><br><span class="line">      String json3  = mapper.writeValueAsString(p3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.创建request</span></span><br><span class="line"></span><br><span class="line">      BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">      bulkRequest.add(<span class="keyword">new</span> IndexRequest(index,type,p1.getId().toString()).source(json1,XContentType.JSON))</span><br><span class="line">              .add(<span class="keyword">new</span> IndexRequest(index,type,p2.getId().toString()).source(json2,XContentType.JSON))</span><br><span class="line">              .add(<span class="keyword">new</span> IndexRequest(index,type,p3.getId().toString()).source(json3,XContentType.JSON));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.client 执行</span></span><br><span class="line">      BulkResponse responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.输出结果</span></span><br><span class="line">      System.out.println(responses.getItems().toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>批量删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request 对象</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"1"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"2"</span>));</span><br><span class="line">    bulkRequest.add(<span class="keyword">new</span> DeleteRequest(index,type,<span class="string">"3"</span>));</span><br><span class="line">    <span class="comment">// 2.执行</span></span><br><span class="line">    BulkResponse re = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出结果</span></span><br><span class="line">    System.out.println(re.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ES-练习"><a href="#ES-练习" class="headerlink" title="ES 练习"></a>ES 练习</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引：sms-logs-index</span><br><span class="line">类型：sms-logs-type</span><br></pre></td></tr></table></figure><p><img src="image-20200728173057412.png" alt="png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备关于索引的setting</span></span><br><span class="line">        Settings.Builder settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                .put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.准备关于索引的mapping</span></span><br><span class="line">        XContentBuilder mappings = JsonXContent.contentBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                    .startObject(<span class="string">"properties"</span>)</span><br><span class="line">                        .startObject(<span class="string">"corpName"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"createDate"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"fee"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"long"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"ipAddr"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"ip"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"longCode"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"mobile"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"operatorId"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"province"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"keyword"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"replyTotal"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"sendDate"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"date"</span>)</span><br><span class="line">                            .field(<span class="string">"format"</span>, <span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"smsContent"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">                            .field(<span class="string">"analyzer"</span>, <span class="string">"ik_max_word"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"state"</span>)</span><br><span class="line">                            .field(<span class="string">"type"</span>, <span class="string">"integer"</span>)</span><br><span class="line">                        .endObject()</span><br><span class="line">                    .endObject()</span><br><span class="line">                .endObject();</span><br><span class="line">        <span class="comment">// 3.将settings和mappings 封装到到一个Request对象中</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(index)</span><br><span class="line">                .settings(settings)</span><br><span class="line">                .mapping(type,mappings);</span><br><span class="line">        <span class="comment">// 4.使用client 去连接ES</span></span><br><span class="line">        CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"response:"</span>+response.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">bulkCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1.准备多个json 对象</span></span><br><span class="line">        String longcode = <span class="string">"1008687"</span>;</span><br><span class="line">        String mobile =<span class="string">"138340658"</span>;</span><br><span class="line">        List&lt;String&gt; companies = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        companies.add(<span class="string">"腾讯课堂"</span>);</span><br><span class="line">        companies.add(<span class="string">"阿里旺旺"</span>);</span><br><span class="line">        companies.add(<span class="string">"海尔电器"</span>);</span><br><span class="line">        companies.add(<span class="string">"海尔智家公司"</span>);</span><br><span class="line">        companies.add(<span class="string">"格力汽车"</span>);</span><br><span class="line">        companies.add(<span class="string">"苏宁易购"</span>);</span><br><span class="line">        List&lt;String&gt; provinces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        provinces.add(<span class="string">"北京"</span>);</span><br><span class="line">        provinces.add(<span class="string">"重庆"</span>);</span><br><span class="line">        provinces.add(<span class="string">"上海"</span>);</span><br><span class="line">        provinces.add(<span class="string">"晋城"</span>);</span><br><span class="line"></span><br><span class="line">        BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;<span class="number">16</span> ; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            SmsLogs s1 = <span class="keyword">new</span> SmsLogs();</span><br><span class="line">            s1.setId(i);</span><br><span class="line">            s1.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">            s1.setSendDate(<span class="keyword">new</span> Date());</span><br><span class="line">            s1.setLongCode(longcode+i);</span><br><span class="line">            s1.setMobile(mobile+<span class="number">2</span>*i);</span><br><span class="line">            s1.setCorpName(companies.get(i%<span class="number">5</span>));</span><br><span class="line">            s1.setSmsContent(SmsLogs.doc.substring((i-<span class="number">1</span>)*<span class="number">100</span>,i*<span class="number">100</span>));</span><br><span class="line">            s1.setState(i%<span class="number">2</span>);</span><br><span class="line">            s1.setOperatorId(i%<span class="number">3</span>);</span><br><span class="line">            s1.setProvince(provinces.get(i%<span class="number">4</span>));</span><br><span class="line">            s1.setIpAddr(<span class="string">"127.0.0."</span>+i);</span><br><span class="line">            s1.setReplyTotal(i*<span class="number">3</span>);</span><br><span class="line">            s1.setFee(i*<span class="number">6</span>+<span class="string">""</span>);</span><br><span class="line">            String json1  = mapper.writeValueAsString(s1);</span><br><span class="line">            bulkRequest.add(<span class="keyword">new</span> IndexRequest(index,type,s1.getId().toString()).source(json1, XContentType.JSON));</span><br><span class="line">            System.out.println(<span class="string">"数据"</span>+i+s1.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.client 执行</span></span><br><span class="line">        BulkResponse responses = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.输出结果</span></span><br><span class="line">        System.out.println(responses.getItems().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch的各种查询"><a href="#ElasticSearch的各种查询" class="headerlink" title="ElasticSearch的各种查询"></a>ElasticSearch的各种查询</h1><h2 id="term-和terms-查询"><a href="#term-和terms-查询" class="headerlink" title="term 和terms 查询"></a>term 和terms 查询</h2><h3 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term 查询是代表完全匹配，搜索之前不会对你搜索的关键字进行分词，直接拿 关键字 去文档分词库中匹配内容</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#term查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  #limit ?</span><br><span class="line">  "from": 0,  </span><br><span class="line">  #limit x,?</span><br><span class="line">  "size":5,</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "province": &#123;</span><br><span class="line">        "value": "北京"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termSearchTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.from(<span class="number">0</span>);</span><br><span class="line">        builder.size(<span class="number">5</span>);</span><br><span class="line">        builder.query(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>));</span><br><span class="line"></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(sourceAsMap);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terms 和 term 查询的机制一样，搜索之前不会对你搜索的关键字进行分词，直接拿 关键字 去文档分词库中匹配内容</span><br><span class="line">terms:是针对一个字段包含多个值</span><br><span class="line">term : where province =北京</span><br><span class="line">terms: where province = 北京  or  province =?  (类似于mysql 中的 in)</span><br><span class="line">也可针对 text,  只是在分词库中查询的时候不会进行分词</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#terms 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"terms"</span>: &#123;</span><br><span class="line">      <span class="attr">"province"</span>: [</span><br><span class="line">        <span class="string">"北京"</span>,</span><br><span class="line">        <span class="string">"晋城"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TermSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termsSearchTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.query(QueryBuilders.termsQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>,<span class="string">"晋城"</span>));</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match 查询属于高级查询，会根据你查询字段的类型不一样，采用不同的查询方式</span><br><span class="line">查询的是日期或者数值，他会将你基于字符串的查询内容转换为日期或数值对待</span><br><span class="line">如果查询的内容是一个不能被分词的内容（keyword）,match 不会将你指定的关键字进行分词</span><br><span class="line">如果查询的内容是一个可以被分词的内容（text）,match 查询会将你指定的内容根据一定的方式进行分词，去分词库中匹配指定的内容</span><br><span class="line">match 查询，实际底层就是多个term 查询，将多个term查询的结果给你封装到一起</span><br></pre></td></tr></table></figure><h3 id="math-all"><a href="#math-all" class="headerlink" title="math_all"></a>math_all</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询全部内容，不指定查询条件</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#match_all 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchAllSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">         <span class="comment">//  ES 默认只查询10条数据</span></span><br><span class="line">        builder.size(<span class="number">20</span>);</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.getHits().getHits().length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h3><p>指定一个field 作为查询条件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#match 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: <span class="string">"伟大战士"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.创建查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"伟大战士"</span>));</span><br><span class="line">        <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">        builder.size(<span class="number">20</span>);</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出查询结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.getHits().getHits().length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔match-查询"><a href="#布尔match-查询" class="headerlink" title="布尔match 查询"></a>布尔match 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于一个field 匹配的内容，按照 and 或者or的方式连接</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#布尔match查询 </span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: &#123;</span><br><span class="line">         # 既包含 战士 也包含 团队</span><br><span class="line">        "query": "战士 团队",</span><br><span class="line">        "operator": "and"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#布尔match查询 </span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: &#123;</span><br><span class="line">         # 既包含 战士 或者 团队</span><br><span class="line">        "query": "战士 团队",</span><br><span class="line">        "operator": "or"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">booleanMatchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.创建查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"战士 团队"</span>).operator(Operator.AND));</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.size(<span class="number">20</span>);</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(response.getHits().getHits().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match 针对一个field 做检索，multi_math 针对多个field 进行检索，多个field对应一个文本。</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#multi_math 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"北京"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [<span class="string">"province"</span>,<span class="string">"smsContent"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiMatchSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.创建查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.multiMatchQuery(<span class="string">"北京"</span>,<span class="string">"province"</span>,<span class="string">"smsContent"</span>));</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------</span></span><br><span class="line">    builder.size(<span class="number">20</span>);</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(response.getHits().getHits().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他查询"><a href="#其他查询" class="headerlink" title="其他查询"></a>其他查询</h2><h3 id="id-查询"><a href="#id-查询" class="headerlink" title="id 查询"></a>id 查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#id 查询</span><br><span class="line">GET /sms-logs-index/sms-logs-type/1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGetSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建GetRequest对象</span></span><br><span class="line">        GetRequest request = <span class="keyword">new</span> GetRequest(index,type,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  执行查询</span></span><br><span class="line">        GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(response.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ids查询"><a href="#ids查询" class="headerlink" title="ids查询"></a>ids查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据多个id 查询,类似 mysql 中的 where in (id1,id2...)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#ids 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"ids"</span>: &#123;</span><br><span class="line">      <span class="attr">"values"</span>: [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByIds</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.idsQuery().addIds(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prefix-查询"><a href="#prefix-查询" class="headerlink" title="prefix 查询"></a>prefix 查询</h3><p>前缀查询，可以通过一个关键字去指定一个field 的前缀，从而查询到指定文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#prefix 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#match 查询 在这里是什么都查不到的 和上边的prefix 做比较</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: <span class="string">"海"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByPrefix</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.prefixQuery(<span class="string">"corpName"</span>,<span class="string">"阿"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fuzzy-查询"><a href="#fuzzy-查询" class="headerlink" title="fuzzy 查询"></a>fuzzy 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模糊查询，我们可以输入一个字符的大概，ES 可以根据输入的大概去匹配内容。查询结果不稳定</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#fuzzy 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"腾讯客堂"</span>,</span><br><span class="line">          #指定前边几个字符是不允许出现错误的</span><br><span class="line">        "prefix_length": 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public  void findByFuzzy() throws IOException &#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = new SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = new SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.fuzzyQuery("corpName","腾讯客堂").prefixLength(2));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    for (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wildcard-查询"><a href="#wildcard-查询" class="headerlink" title="wildcard 查询"></a>wildcard 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通配查询，同mysql中的like 是一样的，可以在查询时，在字符串中指定通配符*和占位符？</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#wildcard 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海尔*"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#wildcard 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">      <span class="attr">"corpName"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"海尔??"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByWildCard</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.wildcardQuery(<span class="string">"corpName"</span>,<span class="string">"海尔*"</span>));</span><br><span class="line">        <span class="comment">//------------------------------------------------------</span></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="rang-查询"><a href="#rang-查询" class="headerlink" title="rang 查询"></a>rang 查询</h3><p>范围查询，只针对数值类型，对一个field 进行大于或者小于的范围指定</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#rang 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"gte"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"lte"</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByRang</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  创建request对象</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        <span class="comment">//--------------------------------------------------</span></span><br><span class="line">        builder.query(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).gt(<span class="number">10</span>).lte(<span class="number">30</span>));</span><br><span class="line">        <span class="comment">//------------------------------------------------------</span></span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="regexp-查询"><a href="#regexp-查询" class="headerlink" title="regexp 查询"></a>regexp 查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正则查询，通过你编写的正则表达式去匹配内容</span><br><span class="line">Ps:prefix wildcard  fuzzy 和regexp 查询效率比较低 ,在要求效率比较高时，避免使用</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#regexp 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">      <span class="attr">"mobile"</span>: <span class="string">"138[0-9]&#123;8&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">findByRegexp</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//  创建request对象</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line">    builder.query(QueryBuilders.regexpQuery(<span class="string">"mobile"</span>,<span class="string">"138[0-9]&#123;8&#125;"</span>));</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深分页-scrol-l"><a href="#深分页-scrol-l" class="headerlink" title="深分页 scrol l"></a>深分页 scrol l</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ES 对from +size时又限制的，from +size 之和 不能大于1W,超过后 效率会十分低下</span><br><span class="line">原理：</span><br><span class="line">  from+size  ES查询数据的方式，</span><br><span class="line">  第一步将用户指定的关键词进行分词，</span><br><span class="line">  第二部将词汇去分词库中进行检索，得到多个文档id,</span><br><span class="line">  第三步去各个分片中拉去数据， 耗时相对较长</span><br><span class="line">  第四步根据score 将数据进行排序， 耗时相对较长</span><br><span class="line">  第五步根据from 和size 的值 将部分数据舍弃，</span><br><span class="line">  第六步，返回结果。</span><br><span class="line">  </span><br><span class="line">  scroll +size ES 查询数据的方式</span><br><span class="line">  第一步将用户指定的关键词进行分词，</span><br><span class="line">  第二部将词汇去分词库中进行检索，得到多个文档id,</span><br><span class="line">  第三步，将文档的id放在一个上下文中</span><br><span class="line">  第四步，根据指定的size去ES中检索指定个数数据，拿完数据的文档id,会从上下文中移除</span><br><span class="line">  第五步，如果需要下一页的数据，直接去ES的上下文中找后续内容。</span><br><span class="line">  第六步，循环第四步和第五步</span><br><span class="line">  scroll 不适合做实时查询。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#scroll 查询,返回第一页数据，并将文档id信息存放在ES上下文中，并指定生存时间</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"order"</span>: <span class="string">"desc"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#根据scroll 查询下一页数据</span><br><span class="line">POST _search/scroll</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scroll_id"</span>:<span class="string">"DnF1ZXJ5VGhlbkZldGNoAwAAAAAAABbqFk04VlZ1cjlUU2t1eHpsQWNRY1YwWWcAAAAAAAAW7BZNOFZWdXI5VFNrdXh6bEFjUWNWMFlnAAAAAAAAFusWTThWVnVyOVRTa3V4emxBY1FjVjBZZw=="</span>,</span><br><span class="line">  <span class="attr">"scroll"</span>:<span class="string">"1m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#删除scroll上下文中的数据</span><br><span class="line">DELETE _search/scroll/DnF1ZXJ5VGhlbkZldGNoAwAAAAAAABchFk04VlZ1cjlUU2t1eHpsQWNRY1YwWWcAAAAAAAAXIBZNOFZWdXI5VFNrdXh6bEFjUWNWMFlnAAAAAAAAFx8WTThWVnVyOVRTa3V4emxBY1FjVjBZZw==</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollSearch</span> </span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建request</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        searchRequest.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2.指定scroll信息,过期时间</span></span><br><span class="line">        searchRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.size(<span class="number">4</span>);</span><br><span class="line">        builder.sort(<span class="string">"fee"</span>, SortOrder.DESC);</span><br><span class="line">        searchRequest.source(builder);</span><br><span class="line">        <span class="comment">// 4.获取返回结果scrollId,获取source</span></span><br><span class="line">        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        String scrollId = response.getScrollId();</span><br><span class="line">        System.out.println(<span class="string">"-------------首页数据---------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 5.创建scroll request</span></span><br><span class="line"></span><br><span class="line">            SearchScrollRequest scrollRequest = <span class="keyword">new</span> SearchScrollRequest(scrollId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.指定scroll 有效时间</span></span><br><span class="line">            scrollRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.执行查询，返回查询结果</span></span><br><span class="line">            SearchResponse scroll = client.scroll(scrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.判断是否查询到数据，查询到输出</span></span><br><span class="line">            SearchHit[] searchHits =  scroll.getHits().getHits();</span><br><span class="line">            <span class="keyword">if</span>(searchHits!=<span class="keyword">null</span> &amp;&amp; searchHits.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"-------------下一页数据---------------------"</span>);</span><br><span class="line">                <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">                    System.out.println(hit.getSourceAsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//  9.没有数据，结束</span></span><br><span class="line">                System.out.println(<span class="string">"-------------结束---------------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.创建 clearScrollRequest</span></span><br><span class="line">        ClearScrollRequest clearScrollRequest = <span class="keyword">new</span> ClearScrollRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11.指定scrollId</span></span><br><span class="line">        clearScrollRequest.addScrollId(scrollId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//12.删除scroll</span></span><br><span class="line">        ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 13.输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"删除scroll:"</span>+clearScrollResponse.isSucceeded());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete-by-query"><a href="#delete-by-query" class="headerlink" title="delete-by-query"></a>delete-by-query</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据term,match 等查询方式去删除大量索引</span><br><span class="line">PS:如果你要删除的内容，时index下的大部分数据，推荐创建一个新的index,然后把保留的文档内容，添加到全新的索引</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Delet-by-query 删除</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"range"</span>: &#123;</span><br><span class="line">      <span class="attr">"fee"</span>: &#123;</span><br><span class="line">        <span class="attr">"lt"</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建DeleteByQueryRequest</span></span><br><span class="line">    DeleteByQueryRequest request = <span class="keyword">new</span> DeleteByQueryRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定条件</span></span><br><span class="line">    request.setQuery(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).lt(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.执行</span></span><br><span class="line">    BulkByScrollResponse response = client.deleteByQuery(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.输出返回结果</span></span><br><span class="line">    System.out.println(response.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">复合过滤器，将你的多个查询条件 以一定的逻辑组合在一起，</span><br><span class="line"></span><br><span class="line">must:所有条件组合在一起，表示 and 的意思</span><br><span class="line">must_not: 将must_not中的条件，全部都不匹配，表示not的意思</span><br><span class="line">should:所有条件用should 组合在一起，表示or 的意思</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#省是 晋城 或者北京</span><br><span class="line"># 运营商不能是联通</span><br><span class="line">#smsContent 包含 战士 和的</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"province"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"晋城"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"province"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"北京"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"operatorId"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="string">"2"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"smsContent"</span>: <span class="string">"战士"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"smsContent"</span>: <span class="string">"的"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">boolSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1.创建 searchRequest</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line">        <span class="comment">// 2.指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = <span class="keyword">new</span> BoolQueryBuilder();</span><br><span class="line">        <span class="comment">// #省是 晋城 或者北京</span></span><br><span class="line">        boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>));</span><br><span class="line">        boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"晋城"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//# 运营商不能是联通</span></span><br><span class="line">        boolQueryBuilder.mustNot(QueryBuilders.termQuery(<span class="string">"operatorId"</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//#smsContent 包含 战士 和的</span></span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"战士"</span>));</span><br><span class="line">        boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"的"</span>));</span><br><span class="line"></span><br><span class="line">        builder.query(boolQueryBuilder);</span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="comment">//  3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(hit.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="boosting-查询"><a href="#boosting-查询" class="headerlink" title="boosting 查询"></a>boosting 查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boosting 查询可以帮助我们去影响查询后的score</span><br><span class="line">   positive:只有匹配上positive 查询的内容，才会被放到返回的结果集中</span><br><span class="line">   negative: 如果匹配上了positive 也匹配上了negative, 就可以 降低这样的文档score.</span><br><span class="line">   negative_boost:指定系数,必须小于1   0.5 </span><br><span class="line">关于查询时，分数时如何计算的：</span><br><span class="line">搜索的关键字再文档中出现的频次越高，分数越高</span><br><span class="line">指定的文档内容越短，分数越高。</span><br><span class="line">我们再搜索时，指定的关键字也会被分词，这个被分词的内容，被分词库匹配的个数越多，分数就越高。</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#boosting 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"boosting"</span>: &#123;</span><br><span class="line">      <span class="attr">"positive"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"smsContent"</span>: <span class="string">"战士"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, </span><br><span class="line">      <span class="attr">"negative"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"smsContent"</span>: <span class="string">"团队"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"negative_boost"</span>: <span class="number">0.2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">boostSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.创建 searchRequest</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">// 2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoostingQueryBuilder boost = QueryBuilders.boostingQuery(</span><br><span class="line">            QueryBuilders.matchQuery(<span class="string">"smsContent"</span>, <span class="string">"战士"</span>),</span><br><span class="line">            QueryBuilders.matchQuery(<span class="string">"smsContent"</span>, <span class="string">"团队"</span>)</span><br><span class="line">    ).negativeBoost(<span class="number">0.2f</span>);</span><br><span class="line">    builder.query(boost);</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//  3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter-查询"><a href="#filter-查询" class="headerlink" title="filter  查询"></a>filter  查询</h2><p>query 查询：根据你的查询条件，去计算文档的匹配度得到一个分数，并根据分数排序，不会做缓存的。</p><p>filter 查询：根据查询条件去查询文档，不去计算分数，而且filter会对经常被过滤的数据进行缓存。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#filter 查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"term"</span>: &#123;</span><br><span class="line">            <span class="attr">"corpName"</span>: <span class="string">"海尔智家公司"</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"range"</span>:&#123;</span><br><span class="line">            <span class="attr">"fee"</span>:&#123;</span><br><span class="line">              <span class="attr">"lte"</span>:<span class="number">50</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.searchRequest</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    searchRequest.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoolQueryBuilder boolBuilder = QueryBuilders.boolQuery();</span><br><span class="line">    boolBuilder.filter(QueryBuilders.termQuery(<span class="string">"corpName"</span>,<span class="string">"海尔智家公司"</span>));</span><br><span class="line">    boolBuilder.filter(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).gt(<span class="number">20</span>));</span><br><span class="line">    sourceBuilder.query(boolBuilder);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.执行</span></span><br><span class="line">    SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  4. 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">        System.out.println(hit.getId()+<span class="string">"的分数是："</span>+hit.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高亮查询就是用户输入的关键字，以一定特殊样式展示给用户，让用户知道为什么这个结果被检索出来</span><br><span class="line">高亮展示的数据，本身就是文档中的一个field,单独将field以highlight的形式返回给用户</span><br><span class="line">ES提供了一个highlight 属性，他和query 同级别。</span><br><span class="line"> frament_size: 指定高亮数据展示多少个字符回来</span><br><span class="line"> pre_tags:指定前缀标签&lt;front color=&quot;red&quot;&gt;</span><br><span class="line"> post_tags:指定后缀标签 &lt;/font&gt;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#highlight 高亮查询</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>: <span class="string">"团队"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"smsContent"</span>:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"pre_tags"</span>:<span class="string">"&lt;font color='red'&gt;"</span>,</span><br><span class="line">    <span class="attr">"post_tags"</span>:<span class="string">"&lt;/font&gt;"</span>,</span><br><span class="line">    <span class="attr">"fragment_size"</span>:<span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">highLightQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">// 1.创建request</span></span><br><span class="line">       SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">       request.types(type);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2.指定查询条件，指定高亮</span></span><br><span class="line">       SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">       builder.query(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"团队"</span>));</span><br><span class="line">       HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">       highlightBuilder.field(<span class="string">"smsContent"</span>,<span class="number">10</span>)</span><br><span class="line">               .preTags(<span class="string">"&lt;font colr='red'&gt;"</span>)</span><br><span class="line">               .postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">       builder.highlighter(highlightBuilder);</span><br><span class="line">       request.source(builder);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.执行</span></span><br><span class="line">       SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4. 输出结果</span></span><br><span class="line">       <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">           System.out.println(hit.getHighlightFields().get(<span class="string">"smsContent"</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES的聚合查询和mysql 的聚合查询类似，ES的聚合查询相比mysql 要强大得多。ES提供的统计数据的方式多种多样。</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ES 聚合查询的RSTFul 语法</span><br><span class="line">POST /index/type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">        <span class="attr">"(名字)agg"</span>:&#123;</span><br><span class="line">            <span class="attr">"agg_type"</span>:&#123;</span><br><span class="line">                "属性"："值"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去重计数聚合查询"><a href="#去重计数聚合查询" class="headerlink" title="去重计数聚合查询"></a>去重计数聚合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">去重计数，cardinality 先将返回的文档中的一个指定的field进行去重，统计一共有多少条</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 去重计数 查询 province</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"provinceAgg"</span>: &#123;</span><br><span class="line">      <span class="attr">"cardinality"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"province"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggCardinalityC</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.aggregation(AggregationBuilders.cardinality(<span class="string">"provinceAgg"</span>).field(<span class="string">"province"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.输出返回结果</span></span><br><span class="line">    Cardinality agg = response.getAggregations().get(<span class="string">"provinceAgg"</span>);</span><br><span class="line">    System.out.println(agg.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围统计"><a href="#范围统计" class="headerlink" title="范围统计"></a>范围统计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">统计一定范围内出现的文档个数，比如，针对某一个field 的值再0~100,100~200,200~300 之间文档出现的个数分别是多少</span><br><span class="line">范围统计 可以针对 普通的数值，针对时间类型，针对ip类型都可以响应。</span><br><span class="line">数值 rang    </span><br><span class="line">时间  date_rang     </span><br><span class="line">ip   ip_rang</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#针对数值方式的范围统计  from 带等于效果 ，to 不带等于效果</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"fee"</span>,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">30</span></span><br><span class="line">          &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">30</span>,</span><br><span class="line">            <span class="attr">"to"</span>: <span class="number">60</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="number">60</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#时间方式统计</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"date_range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"sendDate"</span>,</span><br><span class="line">        <span class="attr">"format"</span>: <span class="string">"yyyy"</span>, </span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="string">"2000"</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="string">"2000"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#ip 方式 范围统计</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"ip_range"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"ipAddr"</span>,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"to"</span>: <span class="string">"127.0.0.8"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"from"</span>: <span class="string">"127.0.0.8"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggRang</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 1.创建request</span></span><br><span class="line">       SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">       request.types(type);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">       SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">       builder.aggregation(AggregationBuilders.range(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>)</span><br><span class="line">                           .addUnboundedTo(<span class="number">30</span>)</span><br><span class="line">                           .addRange(<span class="number">30</span>,<span class="number">60</span>)</span><br><span class="line">                           .addUnboundedFrom(<span class="number">60</span>));</span><br><span class="line">       request.source(builder);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3.执行查询</span></span><br><span class="line">       SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4.输出返回结果</span></span><br><span class="line">       Range agg = response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">       <span class="keyword">for</span> (Range.Bucket bucket : agg.getBuckets()) &#123;</span><br><span class="line">           String key = bucket.getKeyAsString();</span><br><span class="line">           Object from = bucket.getFrom();</span><br><span class="line">           Object to = bucket.getTo();</span><br><span class="line">           <span class="keyword">long</span> docCount = bucket.getDocCount();</span><br><span class="line">           System.out.println(String.format(<span class="string">"key: %s ,from: %s ,to: %s ,docCount: %s"</span>,key,from,to,docCount));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="统计聚合"><a href="#统计聚合" class="headerlink" title="统计聚合"></a>统计聚合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他可以帮你查询指定field 的最大值，最小值，平均值，平方和...</span><br><span class="line">使用 extended_stats</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#统计聚合查询 extended_stats</span><br><span class="line">POST /sms-logs-index/sms-logs-type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"agg"</span>: &#123;</span><br><span class="line">      <span class="attr">"extended_stats"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"fee"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java实现   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggExtendedStats</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.aggregation(AggregationBuilders.extendedStats(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>));</span><br><span class="line">        request.source(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.输出返回结果</span></span><br><span class="line">       ExtendedStats extendedStats =  response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">        System.out.println(<span class="string">"最大值："</span>+extendedStats.getMaxAsString()+<span class="string">",最小值："</span>+extendedStats.getMinAsString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="其他聚合查询-查看官方文档"><a href="#其他聚合查询-查看官方文档" class="headerlink" title="其他聚合查询 查看官方文档"></a>其他聚合查询 查看官方文档</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-aggregations-metrics-weight-avg-aggregation.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-aggregations-metrics-weight-avg-aggregation.html</a></p><h2 id="6-10-地图经纬度搜索"><a href="#6-10-地图经纬度搜索" class="headerlink" title="6.10 地图经纬度搜索"></a>6.10 地图经纬度搜索</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#创建一个经纬度索引,指定一个 name ,一个location</span><br><span class="line">PUT /map</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"map"</span>:&#123;</span><br><span class="line">      <span class="attr">"properties"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"location"</span>:&#123;</span><br><span class="line">          <span class="attr">"type"</span>:<span class="string">"geo_point"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#添加测试数据</span><br><span class="line">PUT /map/map/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"天安门"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.403694</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">39.914492</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /map/map/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"百望山"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.26284</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">40.036576</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /map/map/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"北京动物园"</span>,</span><br><span class="line">  <span class="attr">"location"</span>:&#123;</span><br><span class="line">    <span class="attr">"lon"</span>: <span class="number">116.347352</span>,</span><br><span class="line">    <span class="attr">"lat"</span>:<span class="number">39.947468</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES-的地图检索方式"><a href="#ES-的地图检索方式" class="headerlink" title="ES 的地图检索方式"></a>ES 的地图检索方式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geo_distance :直线距离检索方式</span><br><span class="line">geo_bounding_box: 以2个点确定一个矩形，获取再矩形内的数据</span><br><span class="line">geo_polygon:以多个点，确定一个多边形，获取多边形的全部数据</span><br></pre></td></tr></table></figure><h3 id="基于RESTFul-实现地图检索"><a href="#基于RESTFul-实现地图检索" class="headerlink" title="基于RESTFul 实现地图检索"></a>基于RESTFul 实现地图检索</h3><p>geo_distance</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#geo_distance </span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_distance"</span>:&#123;</span><br><span class="line">        #确定一个点</span><br><span class="line">      "location":&#123;</span><br><span class="line">        "lon":116.434739,</span><br><span class="line">        "lat":39.909843</span><br><span class="line">      &#125;,</span><br><span class="line">      #确定半径</span><br><span class="line">      "distance":20000,</span><br><span class="line">      #指定形状为圆形</span><br><span class="line">      "distance_type":"arc"</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#geo_bounding_box</span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"geo_bounding_box"</span>:&#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">        <span class="attr">"top_left"</span>:&#123;</span><br><span class="line">          <span class="attr">"lon"</span>:<span class="number">116.327805</span>,</span><br><span class="line">          <span class="attr">"lat"</span>:<span class="number">39.95499</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"bottom_right"</span>:&#123;</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">116.363162</span>,</span><br><span class="line">          <span class="attr">"lat"</span>:<span class="number">39.938395</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#geo_polygon</span><br><span class="line">POST /map/map/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;</span><br><span class="line">    <span class="attr">"geo_polygon"</span>:&#123;</span><br><span class="line">      <span class="attr">"location"</span>:&#123;</span><br><span class="line">          # 指定多个点确定 位置</span><br><span class="line">       "points":[</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.220296</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">40.075013</span></span><br><span class="line">         &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.346777</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">40.044751</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">"lon"</span>:<span class="number">116.236106</span>,</span><br><span class="line">           <span class="attr">"lat"</span>:<span class="number">39.981533</span></span><br><span class="line">         &#125; </span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-实现-geo-polygon"><a href="#Java-实现-geo-polygon" class="headerlink" title="Java 实现 geo_polygon"></a>Java 实现 geo_polygon</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeoDemo</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"map"</span>;</span><br><span class="line">    String type=<span class="string">"map"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">GeoPolygon</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//  1.创建searchRequest</span></span><br><span class="line">            SearchRequest request  = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">            request.types(type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2.指定 检索方式</span></span><br><span class="line"></span><br><span class="line">            SearchSourceBuilder builder =  <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">            List&lt;GeoPoint&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">40.075013</span>,<span class="number">116.220296</span>));</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">40.044751</span>,<span class="number">116.346777</span>));</span><br><span class="line">            points.add(<span class="keyword">new</span> GeoPoint(<span class="number">39.981533</span>,<span class="number">116.236106</span>));</span><br><span class="line">            builder.query(QueryBuilders.geoPolygonQuery(<span class="string">"location"</span>,points));</span><br><span class="line">            request.source(builder);</span><br><span class="line">            <span class="comment">// 3.执行</span></span><br><span class="line">            SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">            <span class="comment">// 4.输出结果</span></span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">                System.out.println(hit.getSourceAsMap());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Qz411e7yx?t=269&amp;amp;p=5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ES简介&quot;&gt;&lt;a href=&quot;#ES简
      
    
    </summary>
    
    
      <category term="information retrieval" scheme="http://yoursite.com/categories/information-retrieval/"/>
    
    
  </entry>
  
  <entry>
    <title>Rank For Expert Retrieval</title>
    <link href="http://yoursite.com/2020/07/12/rank/"/>
    <id>http://yoursite.com/2020/07/12/rank/</id>
    <published>2020-07-12T13:44:15.000Z</published>
    <updated>2020-07-13T05:15:51.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h3><ul><li><strong>P@notic Model</strong><br>  以作者为中心, 将作者所有的文本汇集(mate-document),并且向量化(vec-mate), 通过query与vec-mate的相似度来排序.进而获取专家排序.  - 简单但是准确度低.</li><li><p><strong>Voting Model</strong><br>  以文档为中心, 首先计算出query与document的相似度.并排序.</p><script type="math/tex; mode=display">\text {RRFscore}(d)=\sum_{i} \frac{1}{k+r_{i}(d)}, \quad k=0 \text { (for this example)}</script><p>  $r_i$ the rank of i,比如 候选作者是排名第2,3,7的文档的作者, 则他的得分为<br>  <script type="math/tex">\frac{1}{2} + \frac{1}{3} +\frac{1}{7} = 0.976</script>.将相关作者得分排序的到结果.<br>  将最相关的文档的作者,和作者的文章数量都考虑到了.<br>  其他技术:</p><pre><code>  Comb*:综合各个方式结果.</code></pre></li><li><p><strong>Propagation Model</strong><br>  传播模型是基于图的方式.因为文档与作者之间天然就是一个二分图. :<br>  采用随机游走的方式,让图收敛.<br>目前来看的话, 投票模型的效果是最好的. </p></li></ul><p><strong>Modeling Multi-step Relevance Propagation for Expert Finding</strong></p><ol><li>不仅仅将专家文本的内容作为专家线索, 并且将其相连或者间接相连的文章作为证据. </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Rank&quot;&gt;&lt;a href=&quot;#Rank&quot; class=&quot;headerlink&quot; title=&quot;Rank&quot;&gt;&lt;/a&gt;Rank&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P@notic Model&lt;/strong&gt;&lt;br&gt;  以作者为中心, 将作者所有的文本汇集(m
      
    
    </summary>
    
    
      <category term="information retrieval" scheme="http://yoursite.com/categories/information-retrieval/"/>
    
    
  </entry>
  
  <entry>
    <title>检索系统的评价</title>
    <link href="http://yoursite.com/2020/07/12/Evaluation/"/>
    <id>http://yoursite.com/2020/07/12/Evaluation/</id>
    <published>2020-07-12T13:42:15.000Z</published>
    <updated>2020-08-07T12:29:50.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检索系统的评价"><a href="#检索系统的评价" class="headerlink" title="检索系统的评价"></a>检索系统的评价</h1><h3 id="无序的检索结果评价"><a href="#无序的检索结果评价" class="headerlink" title="无序的检索结果评价."></a>无序的检索结果评价.</h3><p>如果有测试集的话,那么系统效果常用的两个基本指标就是正确率和召回率.不考虑结果的顺序的话.那就和分类的评价差不多.</p><ul><li>正确率:返回与query相关文档所占比例;</li></ul><script type="math/tex; mode=display">Precision = \frac{\text { 返同结果中相关文档的数目 }}{\text { 返同结果的数目 }}=P(\text { relevant } \mid \text { retrieved })</script><ul><li>召回率:返回相关文档所占所有相关文档的比例;</li></ul><script type="math/tex; mode=display">Recall =\frac{\text { 返同结果中相关文档的数目 }}{\text { 所有相关文档的数目 }}=P(\text { retrieved } \mid \text { relevant })</script><div class="table-container"><table><thead><tr><th></th><th>相关(relevant)</th><th>不相关(nonrelevant)</th></tr></thead><tbody><tr><td>retrieved</td><td>true positives(tp)</td><td>false positives(fp)</td></tr><tr><td>not retrieved</td><td>false negatives(fn)</td><td>true negatives(tn)</td></tr></tbody></table></div><p>则有:</p><script type="math/tex; mode=display">\begin{array}{l}P=t p /(t p+f p) \\R=t p /(t p+f n)\end{array}</script><p>在这有个问题就是精确度(accuracy)对于信息检索不是一个很好的指标, 因为信息检索中数据极度不平衡.通常99.99%以上都是不相关文档. 全判定为不相关精确度都很高.<br>采用正确率() 和 召回率() 两个指标的有个有点,他能根据场景不同来确定指标的重要性.<br>如果两种都需要,直觉来看就是平均值, 这就出现了一个新的指标 F</p><script type="math/tex; mode=display">F=\frac{1}{\alpha \frac{1}{P}+(1-\alpha) \frac{1}{R}}=\frac{\left(\beta^{2}+1\right) P R}{\beta^{2} P+R}</script><p>其中, $\beta^{2} = \frac{1 - \alpha}{\alpha} , \alpha \in [0, 1]$,</p><h3 id="有序检索结果的评价方法"><a href="#有序检索结果的评价方法" class="headerlink" title="有序检索结果的评价方法"></a>有序检索结果的评价方法</h3><p>正确率、召回率和F值都是基于集合的评价方法,它们都利用无序的文档集合进行计算.所以需要其他的评价方式.<br>在结果有序的情况下，通常很自然地会将前面k个（k=1,2,…）检索结果组成合适的返回文档子集。对每个这样的集合，都可以得到正确率和召回率，分别以它们作为纵坐标和横<br>坐标在平面上描点并连接便可以得到所示的正确率—召回率曲线<br><img src="20200711110949009_8654.png" alt="png"><br>在某个召回率水平r上的插值正确率（interpolated precision，记为pinterp）定义为对于任意不小于r的召回率水平r′ 所对应的最大正确率，即</p><script type="math/tex; mode=display">p_{\text {interp }}(r)=\max _{r^{\prime} \mathrm{H} r} p\left(r^{\prime}\right)</script><p>根据插值正确率.画出插值正确率—召回率平均曲线<br><img src="20200711111350026_26373.png" alt="png"></p><ul><li>MAP(mean average precision)平均正确率值列表.<br>形式化地，假定信息需求qj∈Q对应的所有相关文档集合<br>为${d<em>1, . . . d</em>{mj}}，R_{jk}$是返回结果中直到遇见$d_k$后其所在位置前（含$d_k$）的所有文档集合，则有</li></ul><script type="math/tex; mode=display">\operatorname{MAP}(Q)=\frac{1}{|Q|} \sum_{j=1}^{|Q|} \frac{1}{m_{j}} \sum_{k=1}^{m_{j}} \operatorname{Prcision}\left(R_{j k}\right)</script><p>如果某篇相关文档未返回，那么上式中其对应的正确率值为0。对于单个信息需求来说，平均正确率是未插值的正确率—召回率曲线下面的面积的近似值，因此，MAP可以粗略地认为是某个查询集合对应的多条正确率—召回率曲线下面积的平均值<br><img src="20200711141728462_15451.png" alt="png"><br><a href="https://blog.csdn.net/leviopku/article/details/80835929" target="_blank" rel="noopener">MAP参考</a></p><ul><li><p>P@k, 在上述基础上,只计算前K个结果的正确率, 该指标的优点九十一不需要计算相关文档的集合数目, 缺点是不稳定, 因为相关文档的总数会对P@k有非常强的影响.</p></li><li><p>R-precision</p></li><li>ROC</li><li>NDCG</li></ul><p>CG表示将每个结果相关性的分值累加后作为整个列表的得分</p><script type="math/tex; mode=display">C G_{k}=\sum_{i=1}^{k} r e l_{i}$$此时没有考虑顺序.$$DCG_k = \sum_{i = 1}^{k} \frac{2^{rel_i} - 1}{log_2(i + 1)}</script><p>同指标P@k一样，它基于前k个检索结果进行计算。设$R(j,d)$是评价人员给出的文档d对查询 j 的相关性得分，那么有</p><script type="math/tex; mode=display">\operatorname{NDCG}(Q, k)=\frac{1}{|Q|} \sum_{j=1}^{|Q|} Z_{j, k} \sum_{m=1}^{k} \frac{2^{R(j, m)}-1}{\log (1+m)}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检索系统的评价&quot;&gt;&lt;a href=&quot;#检索系统的评价&quot; class=&quot;headerlink&quot; title=&quot;检索系统的评价&quot;&gt;&lt;/a&gt;检索系统的评价&lt;/h1&gt;&lt;h3 id=&quot;无序的检索结果评价&quot;&gt;&lt;a href=&quot;#无序的检索结果评价&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="information retrieval" scheme="http://yoursite.com/categories/information-retrieval/"/>
    
    
  </entry>
  
  <entry>
    <title>Learn to rank</title>
    <link href="http://yoursite.com/2020/07/12/Learn2Rank/"/>
    <id>http://yoursite.com/2020/07/12/Learn2Rank/</id>
    <published>2020-07-12T06:56:15.000Z</published>
    <updated>2020-07-12T07:06:43.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learn-to-rank"><a href="#Learn-to-rank" class="headerlink" title="Learn to rank"></a>Learn to rank</h1><p>在信息检索中, 检索rank可以由多种算法获得, 或者是检索的结果还可以受外部信息所影响.将这些信息融合起来排名可能会获得更好的排序结果.<br>如:<br><img src="20200711163650350_6358.png" alt="png"><br>我们可以看到有不同的排序结果.将这多组数据进行在排序.在这 我们将得分 以$s_i(d)$表示, $i$ 为rank. d- document, $r_i(d)$</p><h3 id="无监督的reranking方法"><a href="#无监督的reranking方法" class="headerlink" title="无监督的reranking方法"></a>无监督的reranking方法</h3><h4 id="Score-based-methods"><a href="#Score-based-methods" class="headerlink" title="Score-based methods"></a>Score-based methods</h4><ul><li><p>Comb*</p><script type="math/tex; mode=display">CombMAX(d) = max\{s_0(d), ...,s_n(d)\}</script><script type="math/tex; mode=display">CombMIN(d) = min\{s_0(d), ...,s_n(d)\}</script><script type="math/tex; mode=display">CombSUM(d) = \sum_i(s_i(d))</script><script type="math/tex; mode=display">\operatorname{CombMNZ}(d)=\left|\left\{i \mid d \in \operatorname{Rank}_{i}\right\}\right| \cdot \sum_{i} s_{i}(d)</script><p>  CombSUM 例子:<br>  <img src="20200711165912563_19363.png" alt="png"><br>  我们也可以将数据归一化之后再进行SUM操作.</p><script type="math/tex; mode=display">\frac {score - u} {\alpha}</script><p>  直接Comb的方式过于简单,我们很容易想到将不同的rank赋予不同的权重.</p><script type="math/tex; mode=display">\operatorname{wCombSUM}(d)=\sum_{i} w_{i} s_{i}(d)</script><script type="math/tex; mode=display">\operatorname{wComb} M N Z(d)=\left|\left\{i \mid d \in \operatorname{Rank}_{i}\right\}\right| \cdot \operatorname{w} \operatorname{CombSUM}(d)</script></li></ul><p>那么如何来确定这些权重呢.?</p><ol><li>我们凭借经验手动设置</li><li>通过机器学习的方式.<h4 id="Rank-based-融合"><a href="#Rank-based-融合" class="headerlink" title="Rank-based 融合"></a>Rank-based 融合</h4></li></ol><ul><li><p>Bordafuse</p><p> 混合排名将每种排名分数加起来. 即就纯粹根据各种算法的排名来打分.如图:<br> <img src="20200711171554979_372.png" alt="png"></p></li><li>Condorect<br>根据各种算法战胜其他算法的次数进行排名.<br><img src="20200712082852047_29522.png" alt="png"><br><img src="20200712083012487_27249.png" alt="png">   </li><li><p>Reciprocal Rank Fusion(RRF)<br>根据排名的倒数作为其文档的权重.</p><script type="math/tex; mode=display">RRFscore(d) = \sum_i \frac{1}{k + r_i{d}}</script><p>k 作为参数可以调节.<br><img src="20200712083312233_23519.png" alt="png"></p><h4 id="Learning-to-Rank"><a href="#Learning-to-Rank" class="headerlink" title="Learning to Rank"></a>Learning to Rank</h4><p><img src="20200712084032594_18408.png" alt="png"><br>使用机器学习的方式自动学习到如何rank.</p></li><li><p>逐点的方式.<br>  对相关分数进行回归，将文档分类为“相关”和“非相关”<br>  以$(q, d, r)$ 三元数据集合进行训练.出模型.通过$q,d$ 预测 $s$</p></li><li>逐对的方式.<br>  给定两个文档，预测部分排名<br>  通过预测部分排名来查找全局的顺序:<br>  <img src="20200712084724596_13505.png" alt="png"></li><li>逐列的方式.<br>  给出两个相同项目的排名列表，哪个更好.<ul><li>考虑许多排名特征.</li><li>排名模型是加权线性模型.</li><li>线性模型优化最终排名的顺序.<script type="math/tex; mode=display">ReRanker(d)=w_{1} s_{1}(d)+w_{2} s_{2}(d)+\ldots+w_{n} s_{n}(d)</script><img src="20200712085133960_17800.png" alt="png"></li></ul></li></ul><ul><li>参考 · André Mourão, João Magalhães</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Learn-to-rank&quot;&gt;&lt;a href=&quot;#Learn-to-rank&quot; class=&quot;headerlink&quot; title=&quot;Learn to rank&quot;&gt;&lt;/a&gt;Learn to rank&lt;/h1&gt;&lt;p&gt;在信息检索中, 检索rank可以由多种算法获得, 或
      
    
    </summary>
    
    
      <category term="information retrieval" scheme="http://yoursite.com/categories/information-retrieval/"/>
    
    
  </entry>
  
  <entry>
    <title>同时考虑距离因素和分布因素的多样化近邻图DPG——TKDE顶刊论文阅读笔记</title>
    <link href="http://yoursite.com/2020/05/17/anns-dpg/"/>
    <id>http://yoursite.com/2020/05/17/anns-dpg/</id>
    <published>2020-05-17T07:47:22.000Z</published>
    <updated>2021-02-26T14:41:29.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p>Approximate Nearest Neighbor Search on High Dimensional Data — Experiments, Analyses, and Improvement</p><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><h3 id="作者与单位"><a href="#作者与单位" class="headerlink" title="作者与单位"></a>作者与单位</h3><p>Wen Li(Wen.Li@uts.edu.au); Nanjing Audit University; University of Technology Sydney;</p><p>Ying Zhang(Ying.Zhang@uts.edu.au); University of Technology Sydney;</p><p>Yifang Sun(yifangs@cse.unsw.edu.au); The University of New South Wales;</p><p>Wei Wang(weiw@cse.unsw.edu.au); The University of New South Wales;</p><p>Mingjie Li(Mingjie.Li@student.uts.edu.au); University of Technology Sydney;</p><p>Wenjie Zhang(zhangw@cse.unsw.edu.au); The University of New South Wales</p><p>Xuemin Lin(lxue@cse.unsw.edu.au); The University of New South Wales</p><h3 id="出处与时间"><a href="#出处与时间" class="headerlink" title="出处与时间"></a>出处与时间</h3><p>Transactions on Knowledge and Data Engineering(2019数据库/数据挖掘/内容检索A类期刊); 2019</p><h2 id="作者拟解决的主要问题"><a href="#作者拟解决的主要问题" class="headerlink" title="作者拟解决的主要问题"></a>作者拟解决的主要问题</h2><p>尽管目前已有很多近似最近邻算法，但是它们的性能没有得到全面的评估和分析。本文对各类近似最近邻算法进行了一个全面的评估，这样做的目的有以下三点：</p><ol><li>各个领域的算法和数据集可能会”并行提出”。某一领域的解决方案可能已在另一领域中存在，而不必重复开发。而且，不同领域的算法很少能放在一起比较的。</li><li>忽略了评估标准和设置。一个近似最近邻算法可从各个角度来评估。比如，搜索时间、搜索质量、索引尺寸、可扩展性（关于数据集的规模和维数）、鲁棒性（数据集、查询负载和参数设置）、可更新性，调参工作量等。</li><li>现存结果的差异。同一个算法不同的实施结果差别很大，我们需要一个一致性的比较结果。</li></ol><p>而且，通过实验和分析，本文提出了一种新的基于近邻图的近似最近邻搜索算法——DPG。该方法在构建k近邻图时同时考虑了数据点的距离和数据点的分布，这不同于之前的<a href="https://mp.weixin.qq.com/s/S2tnLEyhwfICKcY6ulBV3g" target="_blank" rel="noopener">NN-Descent</a>和<a href="https://mp.weixin.qq.com/s/ZKynr1jM7eo--dpCULvg0A" target="_blank" rel="noopener">Wang</a>提出的方法。</p><h2 id="论文主要研究内容"><a href="#论文主要研究内容" class="headerlink" title="论文主要研究内容"></a>论文主要研究内容</h2><ol><li>对现存一些主要的近似最近邻算法做一个全面的评估。</li><li>分析造成各种算法在不同情况下的优劣的原因。</li><li>构建一个更有效的基于近邻图的近似最近邻算法。</li></ol><h2 id="论文使用的方法"><a href="#论文使用的方法" class="headerlink" title="论文使用的方法"></a>论文使用的方法</h2><h3 id="动机案例"><a href="#动机案例" class="headerlink" title="动机案例"></a>动机案例</h3><p>近邻图的构建一般只考虑数据点与它的邻居点的距离。但是，本文不仅考虑这一点，它还考虑邻居点的分布，为什么要这样呢？请看图1。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2020-05-16_211609.png" width="700">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1 考虑邻居点分布的作用示例</div></center><p>图1中， $a_3$ 和 $a_4$ 是 $p$ 的最近邻，在2-NN图中，如果查询点为 $q$ ，搜索执行到 $p$ 时是无法继续收敛到 $q$ 的最近邻点 $b$ 的。$a_1$ ， $a_2$ ， $a_3$ ，$a_4$ 之间离得很近，可以认为它们处于同一个集簇，这个时候$a_3$ 和 $a_4$ 都在 $p$ 的邻居列表中其实作用不大。本文在<strong>连边时不仅考虑距离的远近，而且还考虑方向的多样性</strong>，从而构建一个多样化近邻图（Diversified Proximity Graph, DPG）。在图1中，如果 $p$ 的邻居是 $a_3$ 和 $b$ ，那将更有意义。</p><p>假设现在有向边 $\langle p, a_4 \rangle$ 已经没了，现在 $p$ 的邻居是 $a_3$ 和 $b$ 。另一个问题又发生了， $p$ 只有出边而没有入边，因为 $p$ 周围的点距 $p$ 都挺远的， $p$ 不是这些点前两个最近邻点。这将导致 $p$ 左右两边的两个聚簇其实是不连通的，有研究表明，这一现象在高维数据中更普遍。因此，本文在<strong>连边时添加的边是双向边</strong>。</p><h3 id="DPG的构建过程"><a href="#DPG的构建过程" class="headerlink" title="DPG的构建过程"></a>DPG的构建过程</h3><p>给定点 $p$ ，它的最近邻列表为 $L$ ，在 $p$ 的最近邻列表中的两点 $x$ 和 $y$ 的相似性定义为角度 $\measuredangle xpy$ ，表示为 $\theta (x,y)$ 。我们的目标就是在 $L$ 中找一个子集 $S$ ，其中 $\lvert S \rvert = k$ ，使得在 $S$ 中，任意两点的夹角的平均值最大，这样的 $S$ 中的点与 $p$ 连边。</p><p><strong>核心选边过程：</strong> $S$ 初始化为 $L$ 中距 $p$ 最近的点，接下来就是 $k-1$ 次迭代选边过程，此过程同时考虑距离和分布两个因素。在每一次迭代，从集合 $L \setminus S$ 中移出一个点到 $S$ 中，并且移出的这个点是使 $S$ 中各点对之间的夹角的平均值最小的点（类似于经典的求最短路径的算法）。这个过程的时间复杂度为 $O(k^2 K n)$ 。</p><p><strong>时间复杂度推导过程：</strong> 现数据集中一共有 $n$ 个点，给其中一个点 $p$ 选边，它的最近邻列表 $L$ 中有 $K$ 个点，表示为： $v_1, v_2, \cdots, v_K$ ，假设它们已按距 $p$ 的距离升序排好序。开始时先将 $v_1$ （作为 $s_1$）加入集合 $S$ ，接着，从 $L$ 中剩下的 $K-1$ 个点里面选一个 $s_2$ ，使得 $\measuredangle s_1 p s_2$ 最大，因此需要 $K-1$ 次计算。$s_2$ 找到后，$L$ 里面还剩下 $K-2$ 个点，从其中选一个 $s_3$ ，使得 $\measuredangle s_1 p s_3$ 与 $\measuredangle s_2 p s_3$之和最大，因此需要 $2(K-2)$ 次计算，……</p><p>因此，从 $L$ 中选择 $k$ 个点到 $S$ 中，需要的总计算次数为</p><script type="math/tex; mode=display">\sum_{i=1}^{k-1} i(k-i)</script><p>化简可得</p><script type="math/tex; mode=display">\frac{k(k-1)}{2} K - \frac{k(k-1)(2k-1)}{6}</script><p>即为</p><script type="math/tex; mode=display">O(k^2 K) - O(k^3)=O(k^2 K)</script><p>因此，给所有点选边的理论时间复杂度为 $O(k^2 K n)$ 。</p><p>$K$ 值是权衡距离因素和分布因素的一个重要参数，作者在实验中得出，$K=2k$ 时能够实现最好的性能。</p><p>在实际实施时，本文并不是完全按照上述描述来执行的，因为上述过程的时间复杂度还是挺高的，作者通过对上述过程近似实施了一个简化版本，它的时间复杂度为 $O(K^2 n)$ 。</p><p><strong>简化版本选边过程：</strong> 给 $p$ 选边时，为它的 $K$ 近邻列表 $L$ 中的每个点都设置一个计数器。比如，对于点对 $u$ 和 $v$，如果 $v$ 到 $u$ 的距离小于 $v$ 到 $p$ 的距离，则 $v$ 的计数器加一，对 $L$ 中的任意两个点都执行上述操作。之后，保留 $k$ 个计数器的值最小的点作为 $p$ 的邻居。这样做的直觉是： 对于点 $x$，如果有很多点与之处于同一方向，则 $x$ 的计数器的值就会很大。这个简化版本的选边与<a href="https://blog.csdn.net/whenever5225/article/details/106061653/" target="_blank" rel="noopener">HNSW</a>有一点点类似的。</p><h2 id="论文的创新点"><a href="#论文的创新点" class="headerlink" title="论文的创新点"></a>论文的创新点</h2><ol><li>实践了更全面的对近似最近邻搜索算法进行评估的方法；</li><li>近邻图构建时把选边过程的约束总结为两个因素，并分析说明数据分布因素对构建一个面向近似最近邻搜索的近邻图的重要性；</li><li>提出了按角度选边这种数据分布因素的具体实施方式；</li><li>提出了能够和按角度选边实现近似效果的简化版本实施数据分布因素的选边方式。</li></ol><h2 id="论文的结论"><a href="#论文的结论" class="headerlink" title="论文的结论"></a>论文的结论</h2><p>先看一个搜索性能图</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2020-05-17_153519.png" width="800">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图2 搜索性能比较</div></center><p>由图2可见，大部分情况下，HNSW的搜索性能是最优的，本文提出的DPG只在少数情况下是最优。而且，HNSW的性能在各种数据集下是最稳定的。因此，整体而言，HNSW的选边策略还是更好一些，它的分层结构可能也做出了一些贡献。</p><p>另一方面，DPG性能普遍优于KGraph，特别在召回率区域，这说明了考虑数据分布因素的必要性。</p><h2 id="我的观点或思考"><a href="#我的观点或思考" class="headerlink" title="我的观点或思考"></a>我的观点或思考</h2><p>要构建一个面向相似性搜索的近邻图，只考虑距离因素是不行的，如何实施一个数据分布因素是一个值得考虑的问题。</p><p>近邻图构建的常用思路： 先提出抽象构建思路，这个过程一般可以很容易的符号化描述，一些性质也可严密推导，但一般其构建的时间复杂度较高，因此，会有一个近似的版本，近似版本可与抽象版本实现非常接近的效果（或者稍微差一点），而且近似版本一般还可显著降低构建的时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论文题目&quot;&gt;&lt;a href=&quot;#论文题目&quot; class=&quot;headerlink&quot; title=&quot;论文题目&quot;&gt;&lt;/a&gt;论文题目&lt;/h2&gt;&lt;p&gt;Approximate Nearest Neighbor Search on High Dimensional Data —
      
    
    </summary>
    
    
      <category term="近似最近邻搜索" scheme="http://yoursite.com/categories/%E8%BF%91%E4%BC%BC%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="ANNS" scheme="http://yoursite.com/tags/ANNS/"/>
    
      <category term="近邻图" scheme="http://yoursite.com/tags/%E8%BF%91%E9%82%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>NN-Descent构建K近邻图——论文超详细注解</title>
    <link href="http://yoursite.com/2020/04/18/NN-Descent/"/>
    <id>http://yoursite.com/2020/04/18/NN-Descent/</id>
    <published>2020-04-18T06:09:29.000Z</published>
    <updated>2021-02-26T14:39:53.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p>Efficient K-Nearest Neighbor Graph Construction for Generic Similarity Measures</p><h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><h3 id="作者与单位"><a href="#作者与单位" class="headerlink" title="作者与单位"></a>作者与单位</h3><p>Wei Dong(wdong@cs.princeton.edu);</p><p>Moses Charikar(moses@cs.princeton.edu);</p><p>Kai Li(li@cs.princeton.edu).</p><p>Department of Computer Science, Princeton University</p><h3 id="出处与时间"><a href="#出处与时间" class="headerlink" title="出处与时间"></a>出处与时间</h3><p>In Proceedings of the 20th international conference on World wide web; 2011</p><h2 id="作者拟解决的主要问题"><a href="#作者拟解决的主要问题" class="headerlink" title="作者拟解决的主要问题"></a>作者拟解决的主要问题</h2><p>K近邻图的构建在很多基于Web的应用上是一个重要的操作，比如协同过滤（基于用户的邻居作推荐）、相似性搜索等。一个有效地构建方法将使K近邻图的应用更加广泛。</p><p>暴力构建K近邻图的时间复杂度为$O(n^2)$，为了能更高效的构建K近邻图，现存的工作扩展性都不太好，而且一般都特定于具体的相似性度量。</p><p>有效的K近邻图构建仍然是一个开放的问题，解决该问题的已知方案中没有一个是通用、有效和可扩展的。因此，本文提出了NN-Descent方法，该方法具有以下优点：</p><ol><li>通用。适用于任意的相似性度量准则。</li><li><p>可扩展。随着数据集尺寸的增加，Recall仅有很小的下降。由于对每一个数据点的局部信息进行操作，因此适用于分布式计算环境（MapReduce）.</p></li><li><p>节省空间。整个构建过程仅涉及到一种数据结构——近邻图。</p></li><li>快速、精确。百分之几的相似性比较便可实现90%以上的召回率。</li><li>容易实施。主要代码不超过200行（C++）。</li></ol><h2 id="论文主要研究内容"><a href="#论文主要研究内容" class="headerlink" title="论文主要研究内容"></a>论文主要研究内容</h2><p>如何有效地构建一个K近邻图，具体如下：</p><ol><li>适用任意相似性度量的K近邻图构建方法。</li><li>在较短的时间内快速构建K近邻图的方法。</li><li>构建一个在其上能快速、精确执行搜索的K近邻图。</li><li>适用于MapReduce框架的K近邻图构建方案。</li></ol><h2 id="论文使用的方法"><a href="#论文使用的方法" class="headerlink" title="论文使用的方法"></a>论文使用的方法</h2><h3 id="抽象描述注解"><a href="#抽象描述注解" class="headerlink" title="抽象描述注解"></a>抽象描述注解</h3><p>$V$表示数据集，数据集尺寸为$N=|V|$，相似性度量$\sigma$：$V \times V \rightarrow R$。$\forall v \in V$，$B_K(v)$表示$v$的$K$个最近邻，$R_K(v)= \lbrace u \in V | v \in B_K(u) \rbrace$表示$v$的反向K个最近邻。$B[v]$和$R[v]$分别表示$B_K(v)$和$R_K(v)$的近似。$\overline{B}[v]=B[v] \cup R[v]$表示$v$的一般邻居。</p><p>当在$V$上的度量方式为距离度量时，即$d$：$V \times V \rightarrow [0,\ +\infty]$。$\forall r \in [0,\ +\infty]$，以$v$为球心的r-球定义为：$B_r(v)=\lbrace u \in V | d(u, \ v) \leq r\rbrace$。</p><p>如果$\exists c$满足：</p><script type="math/tex; mode=display">|B_{2r}(v)| \leq c|B_{r}(v)|, \ \forall v \in V \tag{1}</script><p>则称度量空间V<strong>增长受限</strong>，$c$是增长常量。</p><h3 id="基础算法注解"><a href="#基础算法注解" class="headerlink" title="基础算法注解"></a>基础算法注解</h3><p>基本思想：<strong>邻居的邻居更可能是邻居</strong>。</p><h4 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h4><p>我们可以从$V$中每一个点的现有的近似K近邻出发，通过探索该点邻居的邻居（在当前近似K近邻中）而不断完善该点的K近邻。换句话说，可从粗略的K近邻图出发通过改进而不断完善它。对这一观点的量化表达如下：</p><p>让$K=c^3$（后面公式推导要用到，$K$取此值是方便推导），假定已有的近似K近邻图（可以随机给每个点选邻居构建，也可通过其它数据结构辅助构建，如哈希，树等）为$B$。$\forall v \in V$，$B^\prime[v]=\bigcup <em>{v^\prime \in B[v]} B[v^\prime]$表示$v$所有邻居的邻居集合，它也是在完善$v$的K近邻时的候选点集。当B的精度比较高时（迭代完善了一定次数或通过某种更好的方式初始化B），高到什么程度呢？就是给定一个固定的半径$r$，对$\forall v \in V$，$B[v]$包含的K个邻居均匀地分布在$B_r(v)$中。这样的话，当各事件相互独立且$K&lt;&lt; |B</em>{r/2}(v)|$时，$B^\prime [v]$很可能包含在$B_{r/2}(v)$中的K个邻居。换句话说，对$\forall v \in V$，通过探索$B^\prime [v]$来使$v$到它的近似K近邻的距离减半。</p><p>对$B<em>{r/2}(v)$中的一点$u$，要从$B^\prime[v]$里面找到，则至少存在一点$v^\prime$，使得$v^\prime \in B[v]$，且$u \in B[v^\prime]$。接下来，我们只需要找满足上述条件的$v^\prime$即可。而若$v^\prime \in B</em>{r/2}(v)$，则有以下几个不等式成立：</p><ol><li>$v^\prime \in B<em>r(v)$，因此，$P\lbrace v^\prime \in B[v]\rbrace \geq K/|B_r(v)|$，$P\lbrace v^\prime \in B[v]\rbrace$表示概率。<strong>注解：</strong>$v^\prime \in B</em>{r/2}(v)$，则$v^\prime \in B<em>r(v)$必然成立。若$v$的$K$个邻居都在$B_r(v)$中取的话，则一共有$C</em>{|B<em>r(v)|}^K$种情况，而$B_r(v)$中的一点不是$v$的邻居的情况有$C</em>{|B<em>r(v)|-1}^K$种，$B_r(v)$中的一点不是$v$的邻居的概率为$C</em>{|B<em>r(v)|-1}^K/C</em>{|B<em>r(v)|}^K$，即为$(|B_r(v)|-K)/|B_r(v)|$，因此$B_r(v)$中的一点是$v$的邻居的概率为$1-C</em>{|B<em>r(v)|-1}^K/C</em>{|B<em>r(v)|}^K$，即为$K/|B_r(v)|$。$B</em>{r/2}(v)$中的一点更可能是$v$的邻居，故$v^\prime$是$v$的邻居的概率大于等于$K/|B_r(v)|$。</li><li>$d(u,\ v^\prime) \leq d(u, \ v) + d(v, \ v^\prime) \leq r$，因此，$P\lbrace u \in B[v^\prime]\rbrace \geq K/|B_r(v^\prime)|$。<strong>注解：</strong>由第一条推论可知，因此$B_r(v^\prime)$中的一点是$v^\prime$的邻居的概率为$K/|B_r(v^\prime)|$，而$u$与$v^\prime$的距离小于等于$r$，故$u$是$v^\prime$的邻居的概率大于等于$K/|B_r(v^\prime)|$。</li><li>$|B<em>r(v)| \leq c|B</em>{r/2}(v)|$，且$|B<em>r(v^\prime)| \leq c|B</em>{r/2}(v^\prime)| \leq c|B<em>r(v)| \leq c^2|B</em>{r/2}(v)|$。<strong>注解：</strong>重点是$|B_{r/2}(v^\prime)| \leq |B_r(v)|$部分的推导，而此处可由图1明显推出。由于$v^\prime$在$v$的$r/2$-球中，$v^\prime$的$r/2$-球一定包含于$v$的$r$-球中。</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="NN-Descent1.jpg" width="300">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图1 不等式推导二维辅助理解图</div></center><p>由以上3个不等式和假定的各事件的独立性可得：</p><script type="math/tex; mode=display">P\lbrace v^\prime \in B[v] \land u \in B[v^\prime]\rbrace \geq K/|B_{r/2}(v)|^2 \tag{2}</script><p><strong>注解：</strong>上式其实就是1.与2.两个事件同时发生的概率再由3.式化简的结果。它的意义是，对于$B<em>{r/2}[v]$中的确定的点$v^\prime$，它既是$v$的邻居又是$u$的反向邻居的概率大于等于$K/|B</em>{r/2}(v)|^2$。</p><p>因此，当$v$的邻居从$B<em>{r/2}(v)$中取时，在$B</em>{r/2}(v)$中的一点$u$属于$v$的邻居的邻居的概率为：</p><script type="math/tex; mode=display">P\lbrace u \in B^\prime[v]\rbrace \geq 1-(1-K/|B_{r/2}(v)|^2)^{|B_{r/2(v)}|} \approx K/|B_{r/2(v)}| \tag{3}</script><p><strong>注解：</strong>先考虑$u$不是$v$的邻居的邻居的概率。此时，从$B<em>{r/2}(v)$中取出的一点设为$x$，$x$不是$v$的邻居或者$u$不是$x$的邻居，发生这种情况的概率由式（2）可得应为$1-K/|B</em>{r/2}(v)|^2$，$B<em>{r/2}(v)$中一共有$|B</em>{r/2}(v)|$个点，它们都不满足上述情况（$x$不是$v$的邻居或者$u$不是$x$的邻居）的概率为：$(1-K/|B<em>{r/2}(v)|^2)^{|B</em>{r/2(v)}|}$，这便是$u$不是$v$的邻居的邻居的概率，从而$u$是$v$的邻居的邻居的概率为：$1-(1-K/|B<em>{r/2}(v)|^2)^{|B</em>{r/2(v)}|}$。下面对该式进行化简，由于$K&lt;&lt; |B<em>{r/2}(v)|$，因此$K/|B</em>{r/2}(v)|^2$是无穷小，化简过程用到一个重要极限：</p><script type="math/tex; mode=display">\lim_{x \rightarrow \infty}(1+\frac{1}{x})^x=e \tag{4}</script><p>一个等价无穷小公式：</p><script type="math/tex; mode=display">e^x -1 \sim x</script><p>整个数据集的直径设为$\Delta$，式（3）表明，<strong>只要我们取一个足够大的$K$（取决于增长因子$c$），即使我们从一个随机的K近邻图开始，通过探索每一个对象邻居的邻居，便可找到该对象的处于半径为$\Delta/2$的范围内的K个近邻。不断的迭代这一过程，每个对象的邻居距离该对象的距离会不断收缩，最终，构建一个高质量近似K近邻图。</strong></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2020-04-18_093617.png" width="500">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">算法1 NN-Descent基础算法</div></center><p><strong>注解：</strong>(1)处为更新统计，如果某一个对象的K近邻列表更新了，$c$就会加1。算法1的终止条件为自然终止，即没有更新时（$c=0$）终止。</p><h3 id="改进算法注解"><a href="#改进算法注解" class="headerlink" title="改进算法注解"></a>改进算法注解</h3><h4 id="局部连接"><a href="#局部连接" class="headerlink" title="局部连接"></a>局部连接</h4><p>让每一个对象探索它邻居的邻居的操作也可通过<strong>局部连接</strong>等价实现。局部连接可这样理解：给定一点$v$，它的邻居集为$\overline{B}[v]$，在$\overline{B}[v]$上的局部连接是计算每一对不同的$p$和$q$之间的相似性（$p，q \in \overline{B}[v]$），并且根据此相似性更新$B[p]$与$B[q]$。通俗的将，<strong>局部连接就是每一个点介绍它的邻居去了解彼此</strong>。</p><p>局部连接能代替一个对象探索它邻居的邻居的操作吗？看下面的示例：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="NN-Descent2.jpg" width="100">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图2 局部连接实现示例</div></center><p>如图2所示，$b \in B_K(a)$，$c \in B_K(b)$。在算法1中，当探索到$a$时，我们需要比较$a$与$c$，当探索到$c$时，我们也需要比较$a$与$c$，这是冗余计算的一种情况，可通过索引编号的顺序来解决。同样地，$a$与$c$之间的比较可通过对$\overline{B}[b]$进行局部连接来实现。</p><p>局部连接实现起来很简单，那么它有什么好处呢？</p><ol><li>增强了数据的局部性，使执行更有效。如果每一个对象的邻居的个数平均为$\overline{K}$，算法1每次迭代探索每一个对象的邻居的邻居时将接触到$\overline{K}^2$个点，而局部连接只需要接触$\overline{K}$个点。</li><li>单机实施时，提升了cache的命中率，从而加速了K近邻图的构建。分布式实施时，能减少机器之间数据的复制。</li></ol><h4 id="增量搜索"><a href="#增量搜索" class="headerlink" title="增量搜索"></a>增量搜索</h4><p>随着算法的执行，每一个对象的K近邻更新的幅度逐渐减小。而且，在某次迭代中参与比较的两个点，就更可能在之前的迭代中已经比较过了。这就造成冗余计算，而增量搜索就是要解决这个问题的。</p><ol><li>给每一个点的K近邻列表中的每一个对象附加一个布尔标记，当一个新对象插入到该列表中的某个条目时，它的标记初始化为true。</li><li>只有当两个对象至少一个的标记为true，它们才进行局部连接。一个对象参与局部连接之后，它被标记为false（true变false，false还是false）。</li></ol><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>采样是为了解决以下两个问题：</p><ol><li>局部连接的高成本。一次迭代，就算只考虑K近邻，时间复杂度为$K^2N$，如果再考虑反向近邻，时间复杂度更高。</li><li>冗余计算。两个点同时连接到多个不同对象，这两个点将比较多次。</li></ol><p>使用采样来<strong>缓解</strong>这两个问题的具体方案如下：</p><ol><li>邻居取样。局部连接之前，对用于局部连接的每一个对象，从标记为true的K近邻中取样$\rho K$个对象（$\rho \in (0, 1]$）。每一次迭代，仅仅这些被取出的数据被标记为false。</li><li>反向邻居。只根据取样对象和标记为false的对象来构建反向邻居列表。对构建得的反向邻居列表再次取样。</li><li>在标记为true对象之间进行局部连接，以及在标记为true对象与标记为false对象之间进行局部连接。</li></ol><p>因此，我们就可以通过取样率$\rho$来进行精度和速度的trade-off。</p><h4 id="提前终止"><a href="#提前终止" class="headerlink" title="提前终止"></a>提前终止</h4><p>一个很自然的终止标准是：某次迭代中，K近邻图不再被改善。实际上，开始迭代时，K近邻图能充分的更新，而随着迭代的进行，K近邻图更新的次数快速收缩，此时的迭代就显得意义不大了，考虑到迭代的计算成本，这些迭代其实没必要执行。为了解决这个问题，本文采取的方案是：在每次迭代中，统计所有对象K近邻列表更新的次数$count$，当$count &lt; \delta KN $时终止发生，其中$\delta$是精度参数，它粗略反应了由于提前终止允许错过的真正的K近邻的比例。</p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2020-04-18_094259.png" width="500">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">算法2 NN-Descent改进算法</div></center><p><strong>注解：</strong>算法2是在算法1的基础上结合了四个改进（局部连接；增量搜索；采样；提前终止），注意算法2其实也不能完全避免冗余计算，先理解一下这个算法，然后我会给出示例。</p><p>(1)、(2)属于增量搜索和采样部分，对于当前对象$v$，在它的邻居列表中取$\rho K$个标记为true的邻居到$new[v]$，并将这些邻居标记为false（对于伪代码中的(3)），在它的邻居列表中取出所有标记为false的邻居到$old[v]$。</p><p>(4)是取$v$的反向邻居，正如取$v$的$old[v]$一样，其它所有点也会取各自的$old$，以所有点的$old$集合中包含的点作为探索范围，检查它们的邻居列表中含$v$的点，含$v$则加入到$old^\prime [v]$，$old^\prime [v]$的意义是：点$v$的反向邻居，且在该反向邻居的邻居表中，$v$被标记为false。$new^\prime$同理。</p><p>(5)是说最后参与局部连接的$old[v]$是由两部分组成：一部分是从$v$的邻居列表中取出的标记为false的邻居集，另一部分是从$old^\prime [v]$中取样的$\rho K$个点。最后参与局部连接的$new[v]$同理（(6)）。</p><p>(7)表示局部连接。$new[v]$里面的点相互之间进行局部连接，为防止重复比较，设定比较顺序。$new[v]$中的点与$old[v]$中的点进行局部连接。</p><p>(8)统计更新，某一对象的邻居列表更新时，新插入的对象标记为true（满足：增量搜索）。</p><p>(9)为终止条件。当更新量小于某一阈值时终止。</p><p><strong>冗余计算示例</strong></p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="NN-Descent3.jpg" width="300">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图3 冗余计算示例</div></center><p>如图3所示，第一次迭代时$v_3$和$v_4$都取样了$v_1$，都没有取样$v_2$，因此，它们的邻居列表中$v_1$都标记为false，$v_2$都标记为true。此时，$new^\prime[v_1]$含$v_3$、$v_4$，若$v_3$、$v_4$都被取样加入到参与局部连接的$new[v_1]$，则$v_3$和$v_4$会进行一次相似性计算。第二次迭代时，$v_3$和$v_4$都取样了$v_2$，然后$v_2$在它们的列表中被标记为false。此时，$new^\prime[v_2]$含$v_3$、$v_4$，若$v_3$、$v_4$都被取样加入到参与局部连接的$new[v_2]$，则$v_3$和$v_4$又会进行一次相似性计算。</p><p>当然，上述分两次迭代的说明也可在一次迭代中发生。不过，上述冗余计算的情况在取样过程的参与下发生的概率是很小的。</p><h2 id="论文的创新点"><a href="#论文的创新点" class="headerlink" title="论文的创新点"></a>论文的创新点</h2><p>一种新的构建K近邻图的方法，具体创新包括：</p><ol><li>对于一个随机K近邻图，通过几次迭代而不断的完善K近邻图，最终得到一个更好的K近邻图。（构图思路）</li><li>处理某个点时，在该点的各邻居之间进行选边。这种方式相较于处理某个点时，该点与该点的邻居的邻居之间进行选边而言，局部性更好。两种方式实现的结果都是一样的。（选边策略）</li></ol><h2 id="论文的结论"><a href="#论文的结论" class="headerlink" title="论文的结论"></a>论文的结论</h2><p>具体实验分析可以看作者的原文。本文提出的NN-Descent方法可使用任意度量方式构建的K近邻图。经验复杂度为$O(n^{1.14})$，很容易实现并行化。</p><h2 id="我的观点或思考"><a href="#我的观点或思考" class="headerlink" title="我的观点或思考"></a>我的观点或思考</h2><p>本文一开始是随机构建一个K近邻图，这样做的优点是简单快速。但是，迭代的过程过多地依赖随机初始化的K近邻图，这样可能不够稳定，某些情况下只需几次迭代，而另一些情况则可能需要很多。因此，一个简单地改进可从初始化K近邻图这个角度入手。</p><p>最近提出的基于近邻图的近似最近邻搜索算法——NSG和NSSG，他们在构建索引时，第一步构建K近邻图与第二部MRNG或SSG选边策略是分开进行的，有没有可能在K近邻图构建的同时执行某一选边策略。</p><p>选边的时候将三角不等式考虑进去，从而避免一些不必要的计算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;论文题目&quot;&gt;&lt;a href=&quot;#论文题目&quot; class=&quot;headerlink&quot; title=&quot;论文题目&quot;&gt;&lt;/a&gt;论文题目&lt;/h2&gt;&lt;p&gt;Efficient K-Nearest Neighbor Graph Construction for Generic Si
      
    
    </summary>
    
    
      <category term="近似最近邻搜索" scheme="http://yoursite.com/categories/%E8%BF%91%E4%BC%BC%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="论文阅读" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
      <category term="ANNS" scheme="http://yoursite.com/tags/ANNS/"/>
    
      <category term="近邻图" scheme="http://yoursite.com/tags/%E8%BF%91%E9%82%BB%E5%9B%BE/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>





<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/echarts.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/echarts.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"scrollpercent":true,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":true,"show_result":true,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="BlockingQueue 介绍BlockingQueue 继承自 Queue 接口, 下面看看阻塞队列提供的接口； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int">
<meta property="og:type" content="website">
<meta property="og:title" content="FILE">
<meta property="og:url" content="http://yoursite.com/doing/源码_ArrayBlockingQueue.html">
<meta property="og:site_name" content="FILE">
<meta property="og:description" content="BlockingQueue 介绍BlockingQueue 继承自 Queue 接口, 下面看看阻塞队列提供的接口； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-05-26T14:48:57.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FILE">
<meta name="twitter:description" content="BlockingQueue 介绍BlockingQueue 继承自 Queue 接口, 下面看看阻塞队列提供的接口； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int">
  <link rel="alternate" href="/atom.xml" title="FILE" type="application/atom+xml">
  <link rel="canonical" href="http://yoursite.com/doing/源码_ArrayBlockingQueue">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | FILE</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FILE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

    
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">

</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
        
          <h2 id="BlockingQueue-介绍"><a href="#BlockingQueue-介绍" class="headerlink" title="BlockingQueue 介绍"></a>BlockingQueue 介绍</h2><p><code>BlockingQueue</code> 继承自 <code>Queue</code> 接口, 下面看看阻塞队列提供的接口；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 插入数据到队列尾部（如果立即可行且不会超过该队列的容量）</span><br><span class="line">     * 在成功时返回 true，如果此队列已满，则抛IllegalStateException。(与offer方法的区别)</span><br><span class="line">     */</span><br><span class="line">    boolean add(E e);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入数据到队列尾部，如果没有空间，直接返回false;</span><br><span class="line">     * 有空间直接插入，返回true。</span><br><span class="line">     */</span><br><span class="line">    boolean offer(E e);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入数据到队列尾部，如果队列没有空间，一直阻塞；</span><br><span class="line">     * 有空间直接插入。</span><br><span class="line">     */</span><br><span class="line">    void put(E e) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入数据到队列尾部，如果没有额外的空间，等待一定的时间，有空间即插入，返回true，</span><br><span class="line">     * 到时间了，还是没有额外空间，返回false。</span><br><span class="line">     */</span><br><span class="line">    boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取出和删除队列中的头元素，如果没有数据，会一直阻塞到有数据</span><br><span class="line">     */</span><br><span class="line">    E take() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取出和删除队列中的头元素，如果没有数据，需要会阻塞一定的时间，过期了还没有数据，返回null</span><br><span class="line">     */</span><br><span class="line">    E poll(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    //除了上述方法还有继承自Queue接口的方法 </span><br><span class="line">    /**</span><br><span class="line">     * 取出和删除队列头元素，如果是空队列直接返回null。</span><br><span class="line">     */</span><br><span class="line">    E poll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取出但不删除头元素，该方法与peek方法的区别是当队列为空时会抛出NoSuchElementException异常</span><br><span class="line">     */</span><br><span class="line">    E element();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取出但不删除头元素，空队列直接返回null</span><br><span class="line">     */</span><br><span class="line">    E peek();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回队列总额外的空间</span><br><span class="line">     */</span><br><span class="line">    int remainingCapacity();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除队列中存在的元素</span><br><span class="line">     */</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 判断队列中是否存在当前元素</span><br><span class="line">    */</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>插入方法</li>
</ul>
<p><code>add(E e)</code>: 添加成功返回 true，失败抛 IllegalStateException 异常</p>
<p><code>offer(E e)</code>: 成功返回 true，如果此队列已满，则返回 false。</p>
<p><code>put(E e)</code>: 将元素插入此队列的尾部，如果该队列已满，则一直阻塞</p>
<ul>
<li>删除方法</li>
</ul>
<p><code>remove(Object o)</code>: 移除指定元素, 成功返回 true，失败返回 false</p>
<p><code>poll()</code>: 获取并移除此队列的头元素，若队列为空，则返回 null</p>
<p><code>take()</code>: 获取并移除此队列的头元素，若队列为空，则一直阻塞</p>
<ul>
<li>检查方法</li>
</ul>
<p><code>peek()</code>: 获取但不移除此队列的头元素，没有元素则抛 NoSuchElementException 异常</p>
<p><code>element()</code>: 获取但不移除此队列的头；若队列为空，则返回 null。</p>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>ArrayBlockingQueue() 是一个用数组实现的有界阻塞队列，内部按先进先出的原则对元素进行排序； 其中 <code>put</code> 方法和 <code>take</code> 方法为添加和删除元素的阻塞方法。</p>
<p>ArrayBlockingQueue 实现的生产者消费者的 Demo，代码只是一个简单的 ArrayBlockingQueue 的 使用，Consumer 消费者和 Producer 生产者通过 ArrayBlockingQueue 来获取（take）和添加（put） 数据。具体代码请访问：<a href="https://github.com/joyang1/JavaInterview/blob/master/datastructure/src/main/java/cn/tommyyang/queue/ArrayBlockingQueueDemo.java" target="_blank" rel="noopener">ABQ demo</a>。</p>
<p>ArrayBlockingQueue 内部的阻塞队列是通过 ReentrantLock 和 Condition 条件队列实现的， 所以 ArrayBlockingQueue 中的元素存在公平和非公平访问的区别，这是因为 ReentrantLock 里面存在公平锁和非公平锁的原因， ReentrantLock 的具体分析会在 Lock 章节进行具体分析的； 对于 Lock 是公平锁的时候， 则被阻塞的队列可以按照阻塞的先后顺序访问队列，Lock 是非公平锁的时候， 阻塞的线程将进入争夺锁资源的过程中，谁先抢到锁就可以先执行，没有固定的先后顺序。</p>
<p>下面对 ArrayBlockingQueue 构造方法进行分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建一个具体容量的队列，默认是非公平队列</span><br><span class="line"> */</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">    this(capacity, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建一个具体容量、是否公平的队列 </span><br><span class="line"> */</span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>ArrayBlockingQueue 除了实现上述 BlockingQueue 接口的方法，其他方法介绍如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//返回队列剩余容量</span><br><span class="line">public int remainingCapacity()</span><br><span class="line"></span><br><span class="line">// 判断队列中是否存在当前元素o</span><br><span class="line">public boolean contains(Object o) </span><br><span class="line"></span><br><span class="line">// 返回一个按正确顺序，包含队列中所有元素的数组</span><br><span class="line">public Object[] toArray()</span><br><span class="line"></span><br><span class="line">// 返回一个按正确顺序，包含队列中所有元素的数组；数组的运行时类型是指定数组的运行时类型</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 自动清空队列中的所有元素</span><br><span class="line">public void clear()</span><br><span class="line"></span><br><span class="line">// 移除队列中所有可用元素，并将他们加入到给定的 Collection 中    </span><br><span class="line">public int drainTo(Collection&lt;? super E&gt; c)</span><br><span class="line"></span><br><span class="line">// 从队列中最多移除指定数量的可用元素，并将他们加入到给定的 Collection 中    </span><br><span class="line">public int drainTo(Collection&lt;? super E&gt; c, int maxElements)</span><br><span class="line"></span><br><span class="line">// 返回此队列中按正确顺序进行迭代的，包含所有元素的迭代器</span><br><span class="line">public Iterator&lt;E&gt; iterator()</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="ArrayBlockingQueue-源码和实现原理分析"><a href="#ArrayBlockingQueue-源码和实现原理分析" class="headerlink" title="ArrayBlockingQueue 源码和实现原理分析"></a>ArrayBlockingQueue 源码和实现原理分析</h3><h4 id="内部成员变量分析"><a href="#内部成员变量分析" class="headerlink" title="内部成员变量分析"></a>内部成员变量分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /** 存储数据的数组 */</span><br><span class="line">    final Object[] items;</span><br><span class="line"></span><br><span class="line">    /** 获取数据的索引，用于下次 take, poll, peek or remove 等方法 */</span><br><span class="line">    int takeIndex;</span><br><span class="line"></span><br><span class="line">    /** 添加元素的索引， 用于下次 put, offer, or add 方法 */</span><br><span class="line">    int putIndex;</span><br><span class="line"></span><br><span class="line">    /** 队列元素的个数 */</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 并发控制使用任何教科书中的经典双条件算法</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /** 控制并发访问的锁 */</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    /** 非空条件对象，用于通知 take 方法中在等待获取数据的线程，队列中已有数据，可以执行获取操作 */</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    /** 未满条件对象，用于通知 put 方法中在等待添加数据的线程，队列未满，可以执行添加操作 */</span><br><span class="line">    private final Condition notFull;</span><br><span class="line"></span><br><span class="line">    /** 迭代器 */</span><br><span class="line">    transient Itrs itrs = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>从上面成员变量中可以看出，内部使用数组对象 items 来存储所有的数据；通过同一个 ReentrantLock 来同时控制添加数据线程和移除数据线程的并发访问，这个与 LinkedBlockingQueue 有很大区别 (下面会进行分析)。</p>
<p>对于 <code>notEmpty</code> 条件对象是用于存放等待调用 (此时队列中没有数据) take 方法的线程，这些线程会加入到 <code>notEmpty</code> 条件对象的等待队列 (单链表) 中，同时当队列中有数据后会通过 <code>notEmpty</code> 条件对象唤醒等待队列 (链表) 中等待的线程 (链表中第一个 <strong><em>non-null 且 status 为 Condition</em></strong> 的线程) 去 take 数据。</p>
<p>对于 <code>notFull</code> 条件对象是用于存放等待调用 (此时队列容量已满) put 方法的线程，这些线程会加入到 <code>notFull</code> 条件对象的等待队列 (单链表) 中，同时当队列中数据被消费后会通过 <code>notFull</code> 条件对象唤醒等待队列 (链表) 中等待的线程去 put 数据。takeIndex 表示的是下一个 (take、poll、peek、remove) 方法被调用时获取数组元素的索引，putIndex 表示的是下一个 (put、offer、add) 被调用时添加元素的索引。</p>
<p>数据出队、入队操作如下：</p>
<p>![][img-1]</p>
<h4 id="添加-阻塞添加-的实现分析"><a href="#添加-阻塞添加-的实现分析" class="headerlink" title="添加 (阻塞添加) 的实现分析"></a>添加 (阻塞添加) 的实现分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在当前 put 位置插入数据，put 位置前进一位，</span><br><span class="line"> * 同时唤醒 notEmpty 条件对象等待队列(链表)中第一个可用线程去 take 数据。</span><br><span class="line"> * 当然这一系列动作只有该线程获取锁的时候才能进行，即只有获取锁的线程</span><br><span class="line"> * 才能执行 enqueue 操作。</span><br><span class="line"> */</span><br><span class="line">// 元素统一入队操作</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[putIndex] == null;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    items[putIndex] = x; // putIndex 位置添加数据</span><br><span class="line">    //putIndex 进行自增，当达到数组长度的时候，putIndex 重头再来，即设置为0</span><br><span class="line">    //为什么呢？下面会具体介绍 </span><br><span class="line">    if (++putIndex == items.length) </span><br><span class="line">        putIndex = 0;</span><br><span class="line">    count++; //元素个数自增</span><br><span class="line">    notEmpty.signal(); //添加完数据后，说明数组中有数据了，所以可以唤醒 notEmpty 条件对象等待队列(链表)中第一个可用线程去 take 数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加数据，数组中元素已满时，直接返回 false。</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 获取锁，保证线程安全</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 当数组元素个数已满时，直接返回false</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 执行入队操作，enqueue 方法在上面分析了</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁，保证其他等待锁的线程可以获取到锁</span><br><span class="line">        // 为什么放到 finally (避免死锁)</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add 方法其实就是调用了 offer 方法来实现，</span><br><span class="line">// 与 offer 方法的区别就是 offer 方法数组满，抛出 IllegalStateException 异常。</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    if (offer(e))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>offer 方法和 add 方法实现很简单，大家只需要知道其区别就好了；这里着重讲一下 enqueue 方法里面留下的疑问，为什么当 putIndex 到了数组最后一个元素之后，是重头再来，设置为 0；首先，你要想到 ArrayBlockingQueue 整个入队和出队操作都是线程安全的，而且 ArrayBlockingQueue 也是先进先出的队列；所以想一想，是不是数据入队后，从第一个数组位置上开始添加数据，依次往后入队；数据出队也是从数组第一个位置出队，出队后该位置数据为空，依次出队，然后这些位置数据都为空；所以只要 count 的个数没有达到数组长度时，虽然 putIndex 达到了数组长度，说明数组前面的位置上已经有数据出队了，所以添加元素，是不是就从头开始就行了 (想明白了其实就很简单了，哈哈)。因为我们有一个 count 成员变量来记录元素的个数，当队列已满时，put 操作是会阻塞，add 操作会抛出异常，offer 操作会直接返回 false；因此我们也不用担心数据会覆盖。这个 putIndex 和 takeIndex 达到数据长度后都会重新设置为 0，重头开始再获取数据，整个过程就是一个无限循环的过程。 通过分析，我们发现有添加操作是不是有两种场景，一个是直接往后添加，一个是达到数据长度后，需要重头再来，</p>
<p>具体操作如下图：</p>
<p>![][img-2]</p>
<p>下面看看阻塞添加方法 (put)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入数据到队列尾部，如果队列已满，阻塞等待空间</span><br><span class="line"> */</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    // 获取锁，期间线程可以打断，打断则不会添加</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过上述分析，我们通过 count 来判断数组中元素个数</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await(); // 元素已满，线程挂起，线程加入 notFull 条件对象等待队列(链表)中，等待被唤醒</span><br><span class="line">        enqueue(e); // 队列未满，直接执行入队操作</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过源码分析，发现 offer, add 都是无阻塞添加方法，两者的具体区别在上面分析过了；而 put 方法确实是一个阻塞方法，当队列已满的时候，线程会挂起，然后将该线程加入到 notFull 条件对象的等待队列 (链表) 中；notFull 条件对象有两种情况，第一种是当队列已满，新来的 put 数据的线程会加入到其等待队列 (链表) 中，第二种情况是，当队列有空间时，会移除队列中的线程，移除成功同时唤醒 put 线程，加入到获取 lock 的等待队列 (双链表) 的尾部。</p>
<p>具体操作，如下图：</p>
<p>![][img-3]</p>
<p>通过以上分析，ArrayBlockingQueue 的 offer、 add、 put 方法已经都详细分析完毕，希望大家可以对其有深入的了解。</p>
<h4 id="提取-阻塞提取-的实现分析"><a href="#提取-阻塞提取-的实现分析" class="headerlink" title="提取 (阻塞提取) 的实现分析"></a>提取 (阻塞提取) 的实现分析</h4><p>提取即移除数组中的元素，下面我们具体来分析 ArrayBlockingQueue 的提取数组中元素的操作。</p>
<p>同上分析，我们首先从 dequeue 方法分析开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 提取 takeIndex 位置上的元素， 然后 takeIndex 前进一位，</span><br><span class="line"> * 同时唤醒 notFull 等待队列(链表)中的第一个可用线程去 put 数据。</span><br><span class="line"> * 这些操作都是在当前线程获取到锁的前提下进行的，</span><br><span class="line"> * 同时也说明了 dequeue 方法线程安全的。</span><br><span class="line"> */</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[takeIndex] != null;</span><br><span class="line">    final Object[] items = this.items; </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E x = (E) items[takeIndex]; // 提取 takeIndex位置上的数据</span><br><span class="line">    items[takeIndex] = null; // 同时清空数组在 takeIndex 位置上的数据</span><br><span class="line">    // takeIndex 向前前进一位，如果前进后位置超过了数组的长度，则将其设置为0；</span><br><span class="line">    // 为什么设置为0，理由在 putIndex 设置为0的时候介绍过了，原因是一样的。</span><br><span class="line">    if (++takeIndex == items.length) </span><br><span class="line">        takeIndex = 0;</span><br><span class="line">    count--; // 同时数组的元素个数进行减1</span><br><span class="line">    if (itrs != null)</span><br><span class="line">        itrs.elementDequeued(); // 同时更新迭代器中的元素，迭代器的具体分析会在下面单独整理</span><br><span class="line">    notFull.signal(); // 提取完数据后，说明数组中有空位，所以可以唤醒 notFull 条件对象的等待队列(链表)中的第一个可用线程去 put 数据</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提取数据，数组中数据为空时，直接返回 null</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); // 加锁，前面也分析过，要执行 dequeue操作时，当前线程必须获取锁，保证线程安全</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : dequeue(); // 元素个数为0时，直接返回 null，不为0时，元素出队</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁，在 finally 中释放可以避免死锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面 poll() 方法分析得很清晰了，内部通过 dequeue 删除队列头元素。下面分析下 peek 方法，与 poll 有较大的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 返回数组上第 i 个元素</span><br><span class="line">final E itemAt(int i) &#123;</span><br><span class="line">    return (E) items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过代码可以看到，peek 是获取元素，而不是提取， 不会删除 takeIndex 位置上的数据。</span><br><span class="line"> * 内部通过 itemAt 方法实现，而不是 dequeue 方法。</span><br><span class="line"> */</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">     return itemAt(takeIndex); //当队列为空时，返回 null</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过上述代码，可以看出 peek 和 poll 的区别，peek 是获取元素，不会删除 takeIndex 位置原有的数据，takeIndex 也不会向前前进一位。</p>
<p>下面来分析下阻塞提取 take 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 从队列头部提取数据，队列中没有元素则阻塞，阻塞期间线程可中断</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly(); //获取锁，期间线程可以打断，打断则不会提取</span><br><span class="line">    try &#123;</span><br><span class="line">        // 元素为0时，当有线程提取元素，则将该线程加入到 notEmpty 条件对象的等待队列中，</span><br><span class="line">        // 直到当队列中有数据之后，会唤醒该线程去提取数据。</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return dequeue(); // 若有数据，直接调用 dequeue 提取数据</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>其实分析完阻塞添加 put 方法后，再来看 take 方法，发现也是非常简单的，队列中有元素，直接提取，没有元素则线程阻塞 (可中断的阻塞)，将该线程加入到 notEmpty 条件对象的等待队列中；等有新的 put 线程添加了数据，分析发现，会在 put 操作中唤醒 notEmpty 条件对象的等待队列中的 take 线程，去执行 take 操作。</p>
<p>具体操作如下图：</p>
<p>![][img-4]</p>
<p>通过以上分析，我们把 poll、take 提取元素的方法分析了，也把 peek 获取元素的方法分析了，我们使用的时候，根据具体的场景使用具体的方法。</p>
<p>分析完提取方法后，我们来分析一下 ArrayBlockingQueue 中的删除元素的 remove 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void removeAt(final int removeIndex) &#123;</span><br><span class="line">    // assert lock.getHoldCount() == 1;</span><br><span class="line">    // assert items[removeIndex] != null;</span><br><span class="line">    // assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    if (removeIndex == takeIndex) &#123;</span><br><span class="line">        // removing front item; just advance</span><br><span class="line">        items[takeIndex] = null;</span><br><span class="line">        if (++takeIndex == items.length)</span><br><span class="line">            takeIndex = 0;</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // an &quot;interior&quot; remove</span><br><span class="line"></span><br><span class="line">        // slide over all others up through putIndex.</span><br><span class="line">        final int putIndex = this.putIndex;</span><br><span class="line">        for (int i = removeIndex;;) &#123;</span><br><span class="line">            int next = i + 1;</span><br><span class="line">            if (next == items.length)</span><br><span class="line">                next = 0;</span><br><span class="line">            if (next != putIndex) &#123;</span><br><span class="line">                items[i] = items[next];</span><br><span class="line">                i = next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                items[i] = null;</span><br><span class="line">                this.putIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.removedAt(removeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    notFull.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) return false;</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            final int putIndex = this.putIndex;</span><br><span class="line">            int i = takeIndex;</span><br><span class="line">            do &#123;</span><br><span class="line">                if (o.equals(items[i])) &#123;</span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (++i == items.length)</span><br><span class="line">                    i = 0;</span><br><span class="line">            &#125; while (i != putIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="ArrayBlockingQueue-的迭代器分析"><a href="#ArrayBlockingQueue-的迭代器分析" class="headerlink" title="ArrayBlockingQueue 的迭代器分析"></a>ArrayBlockingQueue 的迭代器分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /** Index to look for new nextItem; NONE at end */</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    /** Element to be returned by next call to next(); null if none */</span><br><span class="line">    private E nextItem;</span><br><span class="line"></span><br><span class="line">    /** Index of nextItem; NONE if none, REMOVED if removed elsewhere */</span><br><span class="line">    private int nextIndex;</span><br><span class="line"></span><br><span class="line">    /** Last element returned; null if none or not detached. */</span><br><span class="line">    private E lastItem;</span><br><span class="line"></span><br><span class="line">    /** Index of lastItem, NONE if none, REMOVED if removed elsewhere */</span><br><span class="line">    private int lastRet;</span><br><span class="line"></span><br><span class="line">    /** Previous value of takeIndex, or DETACHED when detached */</span><br><span class="line">    private int prevTakeIndex;</span><br><span class="line"></span><br><span class="line">    /** Previous value of iters.cycles */</span><br><span class="line">    private int prevCycles;</span><br><span class="line"></span><br><span class="line">    /** Special index value indicating &quot;not available&quot; or &quot;undefined&quot; */</span><br><span class="line">    private static final int NONE = -1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Special index value indicating &quot;removed elsewhere&quot;, that is,</span><br><span class="line">     * removed by some operation other than a call to this.remove().</span><br><span class="line">     */</span><br><span class="line">    private static final int REMOVED = -2;</span><br><span class="line"></span><br><span class="line">    /** Special value for prevTakeIndex indicating &quot;detached mode&quot; */</span><br><span class="line">    private static final int DETACHED = -3;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 0;</span><br><span class="line">        lastRet = NONE;</span><br><span class="line">        final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count == 0) &#123;</span><br><span class="line">                // assert itrs == null;</span><br><span class="line">                cursor = NONE;</span><br><span class="line">                nextIndex = NONE;</span><br><span class="line">                prevTakeIndex = DETACHED;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">                prevTakeIndex = takeIndex;</span><br><span class="line">                nextItem = itemAt(nextIndex = takeIndex);</span><br><span class="line">                cursor = incCursor(takeIndex);</span><br><span class="line">                if (itrs == null) &#123;</span><br><span class="line">                    itrs = new Itrs(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    itrs.register(this); // in this order</span><br><span class="line">                    itrs.doSomeSweeping(false);</span><br><span class="line">                &#125;</span><br><span class="line">                prevCycles = itrs.cycles;</span><br><span class="line">                // assert takeIndex &gt;= 0;</span><br><span class="line">                // assert prevTakeIndex == takeIndex;</span><br><span class="line">                // assert nextIndex &gt;= 0;</span><br><span class="line">                // assert nextItem != null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isDetached() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        return prevTakeIndex &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int incCursor(int index) &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        if (++index == items.length)</span><br><span class="line">            index = 0;</span><br><span class="line">        if (index == putIndex)</span><br><span class="line">            index = NONE;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns true if index is invalidated by the given number of</span><br><span class="line">     * dequeues, starting from prevTakeIndex.</span><br><span class="line">     */</span><br><span class="line">    private boolean invalidated(int index, int prevTakeIndex,</span><br><span class="line">                                long dequeues, int length) &#123;</span><br><span class="line">        if (index &lt; 0)</span><br><span class="line">            return false;</span><br><span class="line">        int distance = index - prevTakeIndex;</span><br><span class="line">        if (distance &lt; 0)</span><br><span class="line">            distance += length;</span><br><span class="line">        return dequeues &gt; distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adjusts indices to incorporate all dequeues since the last</span><br><span class="line">     * operation on this iterator.  Call only from iterating thread.</span><br><span class="line">     */</span><br><span class="line">    private void incorporateDequeues() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        // assert itrs != null;</span><br><span class="line">        // assert !isDetached();</span><br><span class="line">        // assert count &gt; 0;</span><br><span class="line"></span><br><span class="line">        final int cycles = itrs.cycles;</span><br><span class="line">        final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">        final int prevCycles = this.prevCycles;</span><br><span class="line">        final int prevTakeIndex = this.prevTakeIndex;</span><br><span class="line"></span><br><span class="line">        if (cycles != prevCycles || takeIndex != prevTakeIndex) &#123;</span><br><span class="line">            final int len = items.length;</span><br><span class="line">            // how far takeIndex has advanced since the previous</span><br><span class="line">            // operation of this iterator</span><br><span class="line">            long dequeues = (cycles - prevCycles) * len</span><br><span class="line">                + (takeIndex - prevTakeIndex);</span><br><span class="line"></span><br><span class="line">            // Check indices for invalidation</span><br><span class="line">            if (invalidated(lastRet, prevTakeIndex, dequeues, len))</span><br><span class="line">                lastRet = REMOVED;</span><br><span class="line">            if (invalidated(nextIndex, prevTakeIndex, dequeues, len))</span><br><span class="line">                nextIndex = REMOVED;</span><br><span class="line">            if (invalidated(cursor, prevTakeIndex, dequeues, len))</span><br><span class="line">                cursor = takeIndex;</span><br><span class="line"></span><br><span class="line">            if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0)</span><br><span class="line">                detach();</span><br><span class="line">            else &#123;</span><br><span class="line">                this.prevCycles = cycles;</span><br><span class="line">                this.prevTakeIndex = takeIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called when itrs should stop tracking this iterator, either</span><br><span class="line">     * because there are no more indices to update (cursor &lt; 0 &amp;&amp;</span><br><span class="line">     * nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) or as a special exception, when</span><br><span class="line">     * lastRet &gt;= 0, because hasNext() is about to return false for the</span><br><span class="line">     * first time.  Call only from iterating thread.</span><br><span class="line">     */</span><br><span class="line">    private void detach() &#123;</span><br><span class="line">        // Switch to detached mode</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        // assert cursor == NONE;</span><br><span class="line">        // assert nextIndex &lt; 0;</span><br><span class="line">        // assert lastRet &lt; 0 || nextItem == null;</span><br><span class="line">        // assert lastRet &lt; 0 ^ lastItem != null;</span><br><span class="line">        if (prevTakeIndex &gt;= 0) &#123;</span><br><span class="line">            // assert itrs != null;</span><br><span class="line">            prevTakeIndex = DETACHED;</span><br><span class="line">            // try to unlink from itrs (but not too hard)</span><br><span class="line">            itrs.doSomeSweeping(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For performance reasons, we would like not to acquire a lock in</span><br><span class="line">     * hasNext in the common case.  To allow for this, we only access</span><br><span class="line">     * fields (i.e. nextItem) that are not modified by update operations</span><br><span class="line">     * triggered by queue modifications.</span><br><span class="line">     */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 0;</span><br><span class="line">        if (nextItem != null)</span><br><span class="line">            return true;</span><br><span class="line">        noNext();</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void noNext() &#123;</span><br><span class="line">        final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // assert cursor == NONE;</span><br><span class="line">            // assert nextIndex == NONE;</span><br><span class="line">            if (!isDetached()) &#123;</span><br><span class="line">                // assert lastRet &gt;= 0;</span><br><span class="line">                incorporateDequeues(); // might update lastRet</span><br><span class="line">                if (lastRet &gt;= 0) &#123;</span><br><span class="line">                    lastItem = itemAt(lastRet);</span><br><span class="line">                    // assert lastItem != null;</span><br><span class="line">                    detach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // assert isDetached();</span><br><span class="line">            // assert lastRet &lt; 0 ^ lastItem != null;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E next() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 0;</span><br><span class="line">        final E x = nextItem;</span><br><span class="line">        if (x == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!isDetached())</span><br><span class="line">                incorporateDequeues();</span><br><span class="line">            // assert nextIndex != NONE;</span><br><span class="line">            // assert lastItem == null;</span><br><span class="line">            lastRet = nextIndex;</span><br><span class="line">            final int cursor = this.cursor;</span><br><span class="line">            if (cursor &gt;= 0) &#123;</span><br><span class="line">                nextItem = itemAt(nextIndex = cursor);</span><br><span class="line">                // assert nextItem != null;</span><br><span class="line">                this.cursor = incCursor(cursor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nextIndex = NONE;</span><br><span class="line">                nextItem = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 0;</span><br><span class="line">        final ReentrantLock lock = ArrayBlockingQueue.this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!isDetached())</span><br><span class="line">                incorporateDequeues(); // might update lastRet or detach</span><br><span class="line">            final int lastRet = this.lastRet;</span><br><span class="line">            this.lastRet = NONE;</span><br><span class="line">            if (lastRet &gt;= 0) &#123;</span><br><span class="line">                if (!isDetached())</span><br><span class="line">                    removeAt(lastRet);</span><br><span class="line">                else &#123;</span><br><span class="line">                    final E lastItem = this.lastItem;</span><br><span class="line">                    // assert lastItem != null;</span><br><span class="line">                    this.lastItem = null;</span><br><span class="line">                    if (itemAt(lastRet) == lastItem)</span><br><span class="line">                        removeAt(lastRet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (lastRet == NONE)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            // else lastRet == REMOVED and the last returned element was</span><br><span class="line">            // previously asynchronously removed via an operation other</span><br><span class="line">            // than this.remove(), so nothing to do.</span><br><span class="line"></span><br><span class="line">            if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0)</span><br><span class="line">                detach();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            // assert lastRet == NONE;</span><br><span class="line">            // assert lastItem == null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called to notify the iterator that the queue is empty, or that it</span><br><span class="line">     * has fallen hopelessly behind, so that it should abandon any</span><br><span class="line">     * further iteration, except possibly to return one more element</span><br><span class="line">     * from next(), as promised by returning true from hasNext().</span><br><span class="line">     */</span><br><span class="line">    void shutdown() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        cursor = NONE;</span><br><span class="line">        if (nextIndex &gt;= 0)</span><br><span class="line">            nextIndex = REMOVED;</span><br><span class="line">        if (lastRet &gt;= 0) &#123;</span><br><span class="line">            lastRet = REMOVED;</span><br><span class="line">            lastItem = null;</span><br><span class="line">        &#125;</span><br><span class="line">        prevTakeIndex = DETACHED;</span><br><span class="line">        // Don&apos;t set nextItem to null because we must continue to be</span><br><span class="line">        // able to return it on next().</span><br><span class="line">        //</span><br><span class="line">        // Caller will unlink from itrs when convenient.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int distance(int index, int prevTakeIndex, int length) &#123;</span><br><span class="line">        int distance = index - prevTakeIndex;</span><br><span class="line">        if (distance &lt; 0)</span><br><span class="line">            distance += length;</span><br><span class="line">        return distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called whenever an interior remove (not at takeIndex) occurred.</span><br><span class="line">     *</span><br><span class="line">     * @return true if this iterator should be unlinked from itrs</span><br><span class="line">     */</span><br><span class="line">    boolean removedAt(int removedIndex) &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        if (isDetached())</span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        final int cycles = itrs.cycles;</span><br><span class="line">        final int takeIndex = ArrayBlockingQueue.this.takeIndex;</span><br><span class="line">        final int prevCycles = this.prevCycles;</span><br><span class="line">        final int prevTakeIndex = this.prevTakeIndex;</span><br><span class="line">        final int len = items.length;</span><br><span class="line">        int cycleDiff = cycles - prevCycles;</span><br><span class="line">        if (removedIndex &lt; takeIndex)</span><br><span class="line">            cycleDiff++;</span><br><span class="line">        final int removedDistance =</span><br><span class="line">            (cycleDiff * len) + (removedIndex - prevTakeIndex);</span><br><span class="line">        // assert removedDistance &gt;= 0;</span><br><span class="line">        int cursor = this.cursor;</span><br><span class="line">        if (cursor &gt;= 0) &#123;</span><br><span class="line">            int x = distance(cursor, prevTakeIndex, len);</span><br><span class="line">            if (x == removedDistance) &#123;</span><br><span class="line">                if (cursor == putIndex)</span><br><span class="line">                    this.cursor = cursor = NONE;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (x &gt; removedDistance) &#123;</span><br><span class="line">                // assert cursor != prevTakeIndex;</span><br><span class="line">                this.cursor = cursor = dec(cursor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int lastRet = this.lastRet;</span><br><span class="line">        if (lastRet &gt;= 0) &#123;</span><br><span class="line">            int x = distance(lastRet, prevTakeIndex, len);</span><br><span class="line">            if (x == removedDistance)</span><br><span class="line">                this.lastRet = lastRet = REMOVED;</span><br><span class="line">            else if (x &gt; removedDistance)</span><br><span class="line">                this.lastRet = lastRet = dec(lastRet);</span><br><span class="line">        &#125;</span><br><span class="line">        int nextIndex = this.nextIndex;</span><br><span class="line">        if (nextIndex &gt;= 0) &#123;</span><br><span class="line">            int x = distance(nextIndex, prevTakeIndex, len);</span><br><span class="line">            if (x == removedDistance)</span><br><span class="line">                this.nextIndex = nextIndex = REMOVED;</span><br><span class="line">            else if (x &gt; removedDistance)</span><br><span class="line">                this.nextIndex = nextIndex = dec(nextIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cursor &lt; 0 &amp;&amp; nextIndex &lt; 0 &amp;&amp; lastRet &lt; 0) &#123;</span><br><span class="line">            this.prevTakeIndex = DETACHED;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called whenever takeIndex wraps around to zero.</span><br><span class="line">     *</span><br><span class="line">     * @return true if this iterator should be unlinked from itrs</span><br><span class="line">     */</span><br><span class="line">    boolean takeIndexWrapped() &#123;</span><br><span class="line">        // assert lock.getHoldCount() == 1;</span><br><span class="line">        if (isDetached())</span><br><span class="line">            return true;</span><br><span class="line">        if (itrs.cycles - prevCycles &gt; 1) &#123;</span><br><span class="line">            // All the elements that existed at the time of the last</span><br><span class="line">            // operation are gone, so abandon further iteration.</span><br><span class="line">            shutdown();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//         /** Uncomment for debugging. */</span><br><span class="line">//         public String toString() &#123;</span><br><span class="line">//             return (&quot;cursor=&quot; + cursor + &quot; &quot; +</span><br><span class="line">//                     &quot;nextIndex=&quot; + nextIndex + &quot; &quot; +</span><br><span class="line">//                     &quot;lastRet=&quot; + lastRet + &quot; &quot; +</span><br><span class="line">//                     &quot;nextItem=&quot; + nextItem + &quot; &quot; +</span><br><span class="line">//                     &quot;lastItem=&quot; + lastItem + &quot; &quot; +</span><br><span class="line">//                     &quot;prevCycles=&quot; + prevCycles + &quot; &quot; +</span><br><span class="line">//                     &quot;prevTakeIndex=&quot; + prevTakeIndex + &quot; &quot; +</span><br><span class="line">//                     &quot;size()=&quot; + size() + &quot; &quot; +</span><br><span class="line">//                     &quot;remainingCapacity()=&quot; + remainingCapacity());</span><br><span class="line">//         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      </div>
      
      
      
    </div>
    

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/echarts.png"
      alt="Les">
  <p class="site-author-name" itemprop="name">Les</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue-介绍"><span class="nav-number">1.</span> <span class="nav-text">BlockingQueue 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">2.</span> <span class="nav-text">ArrayBlockingQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayBlockingQueue-源码和实现原理分析"><span class="nav-number">2.1.</span> <span class="nav-text">ArrayBlockingQueue 源码和实现原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部成员变量分析"><span class="nav-number">2.1.1.</span> <span class="nav-text">内部成员变量分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加-阻塞添加-的实现分析"><span class="nav-number">2.1.2.</span> <span class="nav-text">添加 (阻塞添加) 的实现分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提取-阻塞提取-的实现分析"><span class="nav-number">2.1.3.</span> <span class="nav-text">提取 (阻塞提取) 的实现分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBlockingQueue-的迭代器分析"><span class="nav-number">2.1.4.</span> <span class="nav-text">ArrayBlockingQueue 的迭代器分析</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Les</span>
</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
    
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>


<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>

  

</body>
</html>
